# Spring REST API 的指标

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-rest-api-metrics>

## **1。概述**

在本教程中，我们将把**基本指标集成到 Spring REST API** 中。

我们将首先使用简单的 Servlet 过滤器构建度量功能，然后使用 Spring Boot 执行器模块。

## **2。`web.xml`**

让我们首先在应用程序的`web.xml`中注册一个过滤器——“`MetricFilter`”:

[PRE0]

请注意我们是如何映射过滤器以覆盖所有进入的请求–`“/*”`–这当然是完全可配置的。

## **3。Servlet 过滤器**

现在，让我们创建自定义过滤器:

[PRE1]

因为过滤器不是标准的 bean，所以我们不打算注入`metricService`，而是通过`ServletContext`手动检索它。

还要注意，我们在这里通过调用`doFilter` API 继续执行过滤器链。

## **4。度量-状态代码计数**

接下来，让我们来看看简单的`InMemoryMetricService`:

[PRE2]

我们使用内存中的`ConcurrentMap`来保存每种 HTTP 状态代码的计数。

现在，为了显示这个基本指标，我们将把它映射到一个`Controller`方法:

[PRE3]

下面是一个回答示例:

[PRE4]

## **5。指标-按请求的状态代码**

接下来—**让我们按请求记录计数指标**:

[PRE5]

我们将通过 API 显示指标结果:

[PRE6]

这些指标如下所示:

[PRE7]

根据上面的示例，API 具有以下活动:

*   “7”请求“获取`/users`
*   其中“6 个”导致“200”状态代码响应，只有一个导致“409”

## **6。度量–时间序列数据**

总计数在应用程序中有些用处，但是如果系统已经运行了相当长的时间—**,就很难判断这些指标的实际意义了**。

为了使数据有意义并易于解释，你需要当时的背景。

现在，让我们构建一个简单的基于时间的指标；我们将记录每分钟的状态代码计数，如下所示:

[PRE8]

而`getGraphData()`:

[PRE9]

[PRE10]

[PRE11]

我们现在将它映射到 API:

[PRE12]

最后，我们将使用谷歌图表来呈现它:

[PRE13]

## **7。使用 Spring Boot 1.x 致动器**

在接下来的几节中，我们将结合 Spring Boot 的执行器功能来展示我们的指标。

首先，我们需要将致动器依赖性添加到我们的`pom.xml`:

[PRE14]

### **7.1。`MetricFilter`**

接下来——我们可以把`MetricFilter`—变成一个真正的弹簧豆:

[PRE15]

当然，这是一个微小的简化——但是为了摆脱以前手工连接的依赖关系，这是值得做的。

### **7.2。使用`CounterService`**

现在让我们使用`CounterService`来统计每个状态代码的出现次数:

[PRE16]

### **7.3。使用`MetricRepository`** 导出指标

接下来，我们需要使用`MetricRepository`导出指标:

[PRE17]

请注意，我们正在存储每分钟的**状态代码的计数。**

### **7.4。Spring Boot `PublicMetrics`**

我们还可以使用 Spring Boot `PublicMetrics`来导出指标，而不是使用我们自己的过滤器，如下所示:

首先，我们的预定任务是**导出每分钟指标**:

[PRE18]

当然，我们需要初始化 HTTP 状态代码列表:

[PRE19]

然后，我们将使用**状态代码计数**实际更新指标:

[PRE20]

请注意:

*   `PublicMetics`状态计数器名称以`counter.status`开头，例如`counter.status.200.root`
*   我们在列表中记录每分钟的状态计数`statusMetricsByMinute`

**我们可以导出收集到的数据，并将其绘制成图表**，如下所示:

[PRE21]

### **7.5。使用指标绘制图表**

最后，让我们通过一个二维数组来表示这些指标，这样我们就可以用图表来表示它们:

[PRE22]

这是我们的控制器方法`getMetricData()`:

[PRE23]

下面是一个回答示例:

[PRE24]

## **8。使用 Spring Boot 2.x 致动器**

在 Spring Boot 2 中，Spring Actuator 的 API 见证了一个重大的变化。 **Spring 自己的度量已经被替换为 [`Micrometer`](/web/20220625235338/https://www.baeldung.com/micrometer) 。**因此，让我们用`Micrometer`编写上面相同的指标示例。

### **8.1。将`CounterService`替换为`MeterRegistry`**

由于我们的 Spring Boot 应用已经依赖于启动器，千分尺已经自动配置。我们可以注射`MeterRegistry`而不是`CounterService`。我们可以使用不同类型的`Meter`来获取指标。`Counter`是米中的一种:

[PRE25]

### 8.2.查看自定义指标

由于我们的指标现在已经注册到 Micrometer，首先，让我们在应用程序配置中[启用它们。现在我们可以通过导航到`/actuator/metrics`处的致动器端点来查看它们:](/web/20220625235338/https://www.baeldung.com/spring-boot-actuator-enable-endpoints#3-enabling-specific-endpoints)

[PRE26]

在这里，我们可以看到我们的`counter.status.200`指标列在标准执行器指标中。此外，我们还可以通过将 URI 中的选择器设置为`/actuator/metrics/counter.status.200`来获得该指标的最新值:

[PRE27]

### **8.3。使用`MeterRegistry`** 导出计数

以微米为单位，我们可以使用`MeterRegistry:`导出`Counter`值

[PRE28]

### **8.3。发布指标使用`Meters`**

现在我们也可以使用`MeterRegistry's Meters:`来发布指标

[PRE29]

## **9。结论**

在本文中，我们探索了一些简单的方法来将一些基本的度量功能构建到 Spring web 应用程序中。

注意，计数器**不是线程安全的**——所以如果不使用原子序数之类的东西，它们可能不精确。这是故意的，只是因为 delta 应该很小，100%的准确性不是目标——相反，及早发现趋势才是。

当然，在应用程序中记录 HTTP 指标有更成熟的方法，但这是一种简单、轻量级、超级有用的方法，不需要成熟工具的额外复杂性。

本文的完整实现可以在 GitHub 项目中找到。