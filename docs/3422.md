# 带有 Lambda 表达式的 Java 流过滤器

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-stream-filter-lambda>

## **1。简介**

在这个快速教程中，我们将探索在 Java 中使用 [`Streams`时`Stream.filter()`方法的用法。](/web/20220926153229/https://www.baeldung.com/java-8-streams-introduction)

我们将看看如何使用它，以及如何处理带有检查异常的特殊情况。

## 延伸阅读:

## [Java 8 流简介](/web/20220926153229/https://www.baeldung.com/java-8-streams-introduction)

A quick and practical introduction to Java 8 Streams.[Read more](/web/20220926153229/https://www.baeldung.com/java-8-streams-introduction) →

## [如何在 Java 中过滤收藏](/web/20220926153229/https://www.baeldung.com/java-collection-filtering)

A quick tutorial to filtering collections in Java using different approaches.[Read more](/web/20220926153229/https://www.baeldung.com/java-collection-filtering) →

## [Java 8 中的函数接口](/web/20220926153229/https://www.baeldung.com/java-8-functional-interfaces)

Quick and practical guide to Functional Interfaces present in Java 8.[Read more](/web/20220926153229/https://www.baeldung.com/java-8-functional-interfaces) →

## **2。使用`Stream.filter()`**

`filter()`方法是`Stream`接口的中间操作，它允许我们过滤与给定的`Predicate:`匹配的流元素

[PRE0]

为了了解这是如何工作的，让我们创建一个`Customer`类:

[PRE1]

此外，让我们创建一个客户集合:

[PRE2]

### **2.1。过滤收藏**

`filter()`方法的一个常见用例是[处理集合](/web/20220926153229/https://www.baeldung.com/java-collection-filtering)。

让我们列出超过 100 个`points.`的客户。为此，我们可以使用 lambda 表达式:

[PRE3]

我们还可以使用[方法引用](/web/20220926153229/https://www.baeldung.com/java-8-double-colon-operator)，这是 lambda 表达式的简写:

[PRE4]

在这种情况下，我们将`hasOverHundredPoints`方法添加到我们的`Customer`类中:

[PRE5]

在这两种情况下，我们得到相同的结果:

[PRE6]

### **2.2。使用多个标准过滤集合**

此外，我们可以通过`filter()`使用多个条件。例如，我们可以通过`points`和`name`进行过滤:

[PRE7]

## **3。处理异常**

到目前为止，我们一直使用不抛出异常的谓词过滤器。事实上，Java 中的**函数接口没有声明任何检查或未检查的异常**。

接下来我们将展示一些不同的方法来处理 lambda 表达式中的[异常。](/web/20220926153229/https://www.baeldung.com/java-lambda-exceptions)

### **3.1。使用自定义包装器**

首先，我们将开始向我们的`Customer` `:`添加一个`profilePhotoUrl`

[PRE8]

此外，让我们添加一个简单的`hasValidProfilePhoto()`方法来检查概要文件的可用性:

[PRE9]

我们可以看到，`hasValidProfilePhoto()`方法抛出了一个`IOException`。现在，如果我们尝试用这种方法过滤客户:

[PRE10]

我们将看到以下错误:

[PRE11]

为了处理它，我们可以使用的替代方法之一是用 try-catch 块包装它:

[PRE12]

如果我们需要从谓词中抛出一个异常，我们可以像`RuntimeException`一样将它封装在一个未检查的异常中。

### **3.2。使用投掷功能**

或者，我们可以使用 throwing 函数库。

ThrowingFunction 是一个开源库，允许我们在 Java 函数接口中处理检查异常。

让我们从将 [`throwing-function`依赖项](https://web.archive.org/web/20220926153229/https://search.maven.org/search?q=g:pl.touk%20AND%20a:throwing-function%26core%3Dgav)添加到 pom 开始:

[PRE13]

为了处理谓词中的异常，这个库为我们提供了`ThrowingPredicate`类，它有`unchecked()`方法来包装被检查的异常。

让我们来看看它的实际应用:

[PRE14]

## **4。结论**

在本文中，我们看到了一个如何使用`filter()`方法处理流的例子。我们还探索了一些处理异常的替代方法。

和往常一样，完整的代码可以在 GitHub 上找到[。](https://web.archive.org/web/20220926153229/https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-streams)