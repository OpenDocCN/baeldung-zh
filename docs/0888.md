# 修复“java:整数太大”错误

> 原文:[https://web . archive . org/web/20220930061024/https://www . bael dung . com/Java-integer-number-too-large-error](https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-integer-number-too-large-error)

## 1.概观

Java 使用 32 位内存存储`Integer`。因此， **`Integer`(或`int`)的范围是从`-2<sup>31</sup> (-2,147,483,648)`到`2<sup>31</sup>-1 (2,147,483,647)`。**因此，当我们看到类似于`java: integer number too large …`的错误信息时，我们通常可以很容易地找到问题并修复它。

但是，在某些情况下，当我们看到此错误消息时，我们可能不明白为什么会发生错误。解决这个问题需要一些时间。

因此，在本教程中，**我们将仔细看看导致这一错误的几个陷阱，并解决错误背后的原因。**

## 2.整数文字陷阱#1

当我们将一个超出上述整数范围的文字数字赋给一个`int`变量时，Java 编译器会报错。例如，假设我们编译这个赋值:

```
int a = 12345678912345;
```

编译器会报告这个错误:

```
java: integer number too large
```

我们可以通过阅读错误信息快速找到问题。我们可能认为`int`不适合这么大的数字，所以我们将类型改为`long`:

```
long a = 12345678912345;
```

然而，当我们重新编译代码时，我们会得到相同的编译错误:“`integer number too large`”。我们会想为什么编译器仍然抱怨 integer，尽管我们声明变量为`long`？接下来，我们可能会花一些时间仔细检查我们是否正确保存了文件，或者重新启动 IDE，等等。然而，问题仍然存在。

当我们用 Java 编写数字文字时，不管它是在整数范围内还是范围外，Java 都将其视为`Integer/int`类型。如果**我们希望一个整数文字量是`long`，我们必须加上“`L`或者“`l`后缀。**这在 [Java 语言规范](https://web.archive.org/web/20221208143950/https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.1)中也有明确说明:

> 如果以 ASCII 字母`L`或`l` (ell)作为后缀，则整数文字的类型为`long`；否则属于类型`int`

因此，要解决这个问题，我们应该在文字数字后添加一个'`L`':

```
long a = 12345678912345L;
```

值得一提的是**当我们使用不带任何后缀的十进制文字时，Java 将其视为`double`。如果我们希望它们是`float,`，我们必须添加一个“`F`或“`f`”后缀:**

```
float a = 1024.42; // compiler error -  java: incompatible types: possible lossy conversion from double to float
float a = 1024.42F; // compiled
```

## 3.整数文字陷阱#2

现在我们知道应该为类型`long `的整数文字添加后缀`L`。接下来，我们来看另一个例子:

```
long a = 007L;
```

如上面的代码所示，我们这次有了后缀'`L`'，而`a`的类型是`long`。即使有前导零，代码也能顺利编译。如果我们检查`a'`的值，变量`a`的值为 7，和预期的一样。所以，我们可能认为 Java 太聪明了，以至于忽略了数字的前导零。

现在，让我们声明另一个变量:

```
long b = 008L;
```

同样，如果我们编译代码，编译器会报告“`integer number too large`”。

这一次，我们的代码中没有整数的符号。此外，`long a = 007L;`工作起来没有任何问题。为什么`long b = 008L `会失败？解决这个问题可能需要一些时间。

实际上，我们陷入了另一个整数文字陷阱。这是因为，在 Java 中，**整数文字也可以用八进制(基数 8)** 来表示。此外，**一个八进制整数由一个前导零后跟一个或多个数字 0 到 7** 组成。

因此，当我们将'`007L`'赋给一个变量时，一切都很好。这是因为 Java 读取八进制整数文本'`007′`，并将其视为`long.`，然而，当我们将'`008L`'赋给变量时，`008`不是有效的八进制整数。因此，编译器会报告该错误。

在我们了解了问题的原因之后，解决方法非常简单——删除前导零:

```
long b = 8L;
```

## 4.结论

在本文中，我们讨论了在 Java 中使用整数文字时的两个常见陷阱。

了解编译错误背后的原因可能有助于我们快速找到并修复问题。