# 在 Git 中修改指定的提交

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/git-modify-commit>

## 1.概观

在本文中，我们将探索修改 [Git](/web/20220810181114/https://www.baeldung.com/git-guide) 提交的不同方法。

## 2.使用`amend`

我们可以通过简单地使用*修改*选项来修改最新的 Git 提交。它会替换最近的提交。我们可以修改提交消息并更新提交中包含的文件。Git 将修改后的提交视为新的提交。

让我们用一个例子来试试*修正*选项。为了简单起见，让我们更新一个文件并用消息“Commit 1”进行提交。现在，让我们尝试使用*修改*选项来更新提交:

[PRE0]

执行上面的命令会打开一个编辑器来包含更改。让我们更新提交消息并保存更改。关闭编辑器后，我们可以看到更新后的提交，如下所示:

[PRE1]

在修改提交时，我们还可以包含分阶段的更改。让我们创建额外的更改，并使用 *amend* 选项将它们包含在最新的提交中，再次更改提交消息:

[PRE2]

如果我们只想添加阶段化的更改而不更新提交消息，我们可以使用 *no-edit* 选项:

[PRE3]

因此，我们可以看到, *amend* 选项是向最近提交添加更改的一种便捷方式。现在，让我们探索更新 Git 历史中旧提交的不同方法。

## 3.使用 [`rebase`](/web/20220810181114/https://www.baeldung.com/git-merge-vs-rebase#git-rebase)

我们可以使用 *rebase* 命令将一系列提交转移到一个新的基础上。Git 在内部为每个旧的提交创建一个新的提交，并移动到指定的新基础。

使用 *-i* 选项和 *rebase* 命令启动一个交互式会话。在此会话期间，如果需要，我们可以使用以下命令修改每个提交:

*   ***【p】*****->包括具体的提交**
***   ***挤压***->将提交与之前的提交合并*   ***删除** (d)* - >删除具体提交*   ***重新措辞** (r)* - >包含提交并更新提交消息*   ***编辑** (e)* - >包含提交，并带有更新所包含文件的选项**

 **让我们尝试使用上面的命令更新我们示例中的提交历史。在这一步， *git 日志*显示了以下提交:

[PRE4]

假设我们想要更改在提交“`Amended Commit 1 – Added new file`”之后提交的修改。

让我们将上面的提交设置为新的基础:

[PRE5]

这将打开一个编辑器，我们可以在其中根据需要进行更改:

[PRE6]

现在，让我们尝试几个命令来更新 Git 历史:

[PRE7]

在第一个命令之后，我们将看到输出:

[PRE8]

现在，正如 Git 输出中所指定的，我们执行*Git commit–amend*命令并做一些更改:

[PRE9]

关闭编辑器后，我们得到以下输出:

[PRE10]

我们在这里可以看到，我们不仅更新了提交消息，还在提交过程中添加了一个文件。

接下来，我们需要执行*git rebase–continue*命令来进行下一次更新。

我们的下一步涉及到用*提交 3* 挤压*提交 4* 的*和*，它打开了下面的编辑器:

[PRE11]

在上面的编辑器中添加修改后，我们得到下面的输出:

[PRE12]

最后，我们已经请求*删除**提交 5* ，这不需要我们做任何进一步的修改。

### 4.分析日志

执行上述步骤后，我们可以看到`git log`的输出如下:

[PRE13]

在这里，我们可以提出几点意见:

*   *提交 5* 被移除
*   *提交 4* 与*提交 3* 合并
*   *提交 2* 消息被更新

在最终的日志中，我们可以看到提交的 id 现在已经更改。这是因为 Git 已经替换了以前的提交，并创建了修改后的新提交。

我们可以使用`reflog` 命令查看与当前`HEAD`相关的参考日志。它包括与 Git 提交相关的所有更新的历史。

让我们使用 *reflog* 命令来观察我们示例的 git 历史:

[PRE14]

## 5.结论

在本文中，我们探索了改变 Git 历史的不同方法。但是，我们在使用这些选项时应该小心，因为这也可能导致内容丢失。**