["```\r\npublic AWSS3AsyncClient s3AsyncClient() {\r\n   String identity = ...\r\n   String credentials = ...\r\n\r\n   BlobStoreContext context = ContextBuilder.newBuilder(\"aws-s3\").\r\n      credentials(identity, credentials).buildView(BlobStoreContext.class);\r\n\r\n   RestContext<AWSS3Client, AWSS3AsyncClient> providerContext = context.unwrap();\r\n   return providerContext.getAsyncApi();\r\n}\r\n```","```\r\npublic static int getMaximumNumberOfParts(byte[] byteArray) {\r\n   int numberOfParts= byteArray.length / fiveMB; // 5*1024*1024\r\n   if (numberOfParts== 0) {\r\n      return 1;\r\n   }\r\n   return numberOfParts;\r\n}\r\n```","```\r\npublic static List<byte[]> breakByteArrayIntoParts(byte[] byteArray, int maxNumberOfParts) {\r\n   List<byte[]> parts = Lists.<byte[]> newArrayListWithCapacity(maxNumberOfParts);\r\n   int fullSize = byteArray.length;\r\n   long dimensionOfPart = fullSize / maxNumberOfParts;\r\n   for (int i = 0; i < maxNumberOfParts; i++) {\r\n      int previousSplitPoint = (int) (dimensionOfPart * i);\r\n      int splitPoint = (int) (dimensionOfPart * (i + 1));\r\n      if (i == (maxNumberOfParts - 1)) {\r\n         splitPoint = fullSize;\r\n      }\r\n      byte[] partBytes = Arrays.copyOfRange(byteArray, previousSplitPoint, splitPoint);\r\n      parts.add(partBytes);\r\n   }\r\n\r\n   return parts;\r\n}\r\n```","```\r\n@Test\r\npublic void given16MByteArray_whenFileBytesAreSplitInto3_thenTheSplitIsCorrect() {\r\n   byte[] byteArray = randomByteData(16);\r\n\r\n   int maximumNumberOfParts = S3Util.getMaximumNumberOfParts(byteArray);\r\n   List<byte[]> fileParts = S3Util.breakByteArrayIntoParts(byteArray, maximumNumberOfParts);\r\n\r\n   assertThat(fileParts.get(0).length + fileParts.get(1).length + fileParts.get(2).length, \r\n      equalTo(byteArray.length));\r\n   byte[] unmultiplexed = Bytes.concat(fileParts.get(0), fileParts.get(1), fileParts.get(2));\r\n   assertThat(byteArray, equalTo(unmultiplexed));\r\n}\r\n```","```\r\nbyte[] randomByteData(int mb) {\r\n   byte[] randomBytes = new byte[mb * 1024 * 1024];\r\n   new Random().nextBytes(randomBytes);\r\n   return randomBytes;\r\n}\r\n```","```\r\npublic static List<Payload> createPayloadsOutOfParts(Iterable<byte[]> fileParts) {\r\n   List<Payload> payloads = Lists.newArrayList();\r\n   for (byte[] filePart : fileParts) {\r\n      byte[] partMd5Bytes = Hashing.md5().hashBytes(filePart).asBytes();\r\n      Payload partPayload = Payloads.newByteArrayPayload(filePart);\r\n      partPayload.getContentMetadata().setContentLength((long) filePart.length);\r\n      partPayload.getContentMetadata().setContentMD5(partMd5Bytes);\r\n      payloads.add(partPayload);\r\n   }\r\n   return payloads;\r\n}\r\n```","```\r\nHashing.md5().hashBytes(byteArray).asBytes();\r\n```","```\r\nObjectMetadata metadata = ObjectMetadataBuilder.create().key(key).contentMD5(md5Bytes).build();\r\nString uploadId = s3AsyncApi.initiateMultipartUpload(container, metadata).get();\r\n```","```\r\nList<ListenableFuture<String>> ongoingOperations = Lists.newArrayList();\r\nfor (int partNumber = 0; partNumber < filePartsAsByteArrays.size(); partNumber++) {\r\n   ListenableFuture<String> future = s3AsyncApi.uploadPart(\r\n      container, key, partNumber + 1, uploadId, payloads.get(partNumber));\r\n   ongoingOperations.add(future);\r\n}\r\n```","```\r\nFunction<ListenableFuture<String>, String> getEtagFromOp = \r\n  new Function<ListenableFuture<String>, String>() {\r\n   public String apply(ListenableFuture<String> ongoingOperation) {\r\n      try {\r\n         return ongoingOperation.get();\r\n      } catch (InterruptedException | ExecutionException e) {\r\n         throw new IllegalStateException(e);\r\n      }\r\n   }\r\n};\r\nList<String> etagsOfParts = Lists.transform(ongoingOperations, getEtagFromOp);\r\n```","```\r\nMap<Integer, String> parts = Maps.newHashMap();\r\nfor (int i = 0; i < etagsOfParts.size(); i++) {\r\n   parts.put(i + 1, etagsOfParts.get(i));\r\n}\r\n```","```\r\ns3AsyncApi.completeMultipartUpload(container, key, uploadId, parts).get();\r\n```"]