["```\r\npublic static <T> boolean detectCycle(Node<T> head) {\r\n    if (head == null) {\r\n        return false;\r\n    }\r\n\r\n    Node<T> it1 = head;\r\n    int nodesTraversedByOuter = 0;\r\n    while (it1 != null && it1.next != null) {\r\n        it1 = it1.next;\r\n        nodesTraversedByOuter++;\r\n\r\n        int x = nodesTraversedByOuter;\r\n        Node<T> it2 = head;\r\n        int noOfTimesCurrentNodeVisited = 0;\r\n\r\n        while (x > 0) {\r\n            it2 = it2.next;\r\n\r\n            if (it2 == it1) {\r\n                noOfTimesCurrentNodeVisited++;\r\n            }\r\n\r\n            if (noOfTimesCurrentNodeVisited == 2) {\r\n                return true;\r\n            }\r\n\r\n            x--;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n```","```\r\npublic static <T> boolean detectCycle(Node<T> head) {\r\n    if (head == null) {\r\n        return false;\r\n    }\r\n\r\n    Set<Node<T>> set = new HashSet<>();\r\n    Node<T> node = head;\r\n\r\n    while (node != null) {\r\n        if (set.contains(node)) {\r\n            return true;\r\n        }\r\n        set.add(node);\r\n        node = node.next;\r\n    }\r\n\r\n    return false;\r\n}\r\n```","```\r\npublic static <T> CycleDetectionResult<T> detectCycle(Node<T> head) {\r\n    if (head == null) {\r\n        return new CycleDetectionResult<>(false, null);\r\n    }\r\n\r\n    Node<T> slow = head;\r\n    Node<T> fast = head;\r\n\r\n    while (fast != null && fast.next != null) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n\r\n        if (slow == fast) {\r\n            return new CycleDetectionResult<>(true, fast);\r\n        }\r\n    }\r\n\r\n    return new CycleDetectionResult<>(false, null);\r\n}\r\n```","```\r\npublic class CycleDetectionResult<T> {\r\n    boolean cycleExists;\r\n    Node<T> node;\r\n}\r\n```","```\r\npublic class CycleRemovalBruteForce {\r\n    private static <T> void removeCycle(\r\n      Node<T> loopNodeParam, Node<T> head) {\r\n        Node<T> it = head;\r\n\r\n        while (it != null) {\r\n            if (isNodeReachableFromLoopNode(it, loopNodeParam)) {\r\n                Node<T> loopStart = it;\r\n                findEndNodeAndBreakCycle(loopStart);\r\n                break;\r\n            }\r\n            it = it.next;\r\n        }\r\n    }\r\n\r\n    private static <T> boolean isNodeReachableFromLoopNode(\r\n      Node<T> it, Node<T> loopNodeParam) {\r\n        Node<T> loopNode = loopNodeParam;\r\n\r\n        do {\r\n            if (it == loopNode) {\r\n                return true;\r\n            }\r\n            loopNode = loopNode.next;\r\n        } while (loopNode.next != loopNodeParam);\r\n\r\n        return false;\r\n    }\r\n\r\n    private static <T> void findEndNodeAndBreakCycle(\r\n      Node<T> loopStartParam) {\r\n        Node<T> loopStart = loopStartParam;\r\n\r\n        while (loopStart.next != loopStartParam) {\r\n            loopStart = loopStart.next;\r\n        }\r\n\r\n        loopStart.next = null;\r\n    }\r\n}\r\n```","```\r\npublic class CycleRemovalByCountingLoopNodes {\r\n    private static <T> void removeCycle(\r\n      Node<T> loopNodeParam, Node<T> head) {\r\n        int cycleLength = calculateCycleLength(loopNodeParam);\r\n        Node<T> cycleLengthAdvancedIterator = head;\r\n        Node<T> it = head;\r\n\r\n        for (int i = 0; i < cycleLength; i++) {\r\n            cycleLengthAdvancedIterator \r\n              = cycleLengthAdvancedIterator.next;\r\n        }\r\n\r\n        while (it.next != cycleLengthAdvancedIterator.next) {\r\n            it = it.next;\r\n            cycleLengthAdvancedIterator \r\n              = cycleLengthAdvancedIterator.next;\r\n        }\r\n\r\n        cycleLengthAdvancedIterator.next = null;\r\n    }\r\n\r\n    private static <T> int calculateCycleLength(\r\n      Node<T> loopNodeParam) {\r\n        Node<T> loopNode = loopNodeParam;\r\n        int length = 1;\r\n\r\n        while (loopNode.next != loopNodeParam) {\r\n            length++;\r\n            loopNode = loopNode.next;\r\n        }\r\n\r\n        return length;\r\n    }\r\n}\r\n```","```\r\npublic class CycleRemovalWithoutCountingLoopNodes {\r\n    private static <T> void removeCycle(\r\n      Node<T> meetingPointParam, Node<T> head) {\r\n        Node<T> loopNode = meetingPointParam;\r\n        Node<T> it = head;\r\n\r\n        while (loopNode.next != it.next) {\r\n            it = it.next;\r\n            loopNode = loopNode.next;\r\n        }\r\n\r\n        loopNode.next = null;\r\n    }\r\n}\r\n```"]