# JVM 中的实验性垃圾收集器

> 原文:[https://web . archive . org/web/20220930061024/https://www . bael dung . com/JVM-experimental-garbage-collectors](https://web.archive.org/web/20220930061024/https://www.baeldung.com/jvm-experimental-garbage-collectors)

## 1.介绍

在本教程中，我们将讨论 Java 内存管理的基本问题，以及不断寻找更好的方法来实现它的必要性。这将主要涵盖 Java 中引入的名为 Shenandoah 的新的实验性垃圾收集器，以及它与其他垃圾收集器的比较。

## 2.了解垃圾收集中的挑战

垃圾收集器是自动内存管理的一种形式，其中像 JVM 这样的运行时为在其上运行的用户程序管理内存的分配和回收。有几种算法可以实现垃圾收集器。这些包括引用计数、标记清除、标记压缩和复制。

### 2.1.垃圾收集器的注意事项

根据我们用于垃圾收集的算法，它可以**在用户程序挂起时运行，或者与用户程序**同时运行。前者实现了更高的吞吐量，但代价是长时间暂停导致的高延迟，也称为 stop-the-world 暂停。后者旨在获得更好的延迟，但会牺牲吞吐量。

事实上，大多数现代收藏家使用一种混合策略，他们应用停止世界和并发的方法。它通常通过将堆空间分成年轻和老代来工作。分代收集器然后在年轻一代中使用 stop-the-world 收集，在老一代中使用并发收集，可能以增量方式减少暂停。

然而，**真正的最佳点是找到一个垃圾收集器，它以最小的暂停运行并提供高吞吐量**——所有这些都具有可预测的堆大小行为，堆大小可以从小到大变化！这是一场持续的斗争，从早期开始就保持了 Java 垃圾收集的创新步伐。

### 2.2.Java 中现有的垃圾收集器

一些传统的[垃圾收集器](/web/20220627074947/https://www.baeldung.com/jvm-garbage-collectors)包括串行和并行收集器。他们是分代收藏者，年轻一代使用复制，老一代使用标记压缩:

[![](../Images/c55befb897bf16f4e6dff8db77a274dd.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Serial-Parallel-1.jpg)

虽然提供了良好的吞吐量，但它们也有长时间停顿的问题。

Java 1.4 中引入的[并发标记清除(CMS)收集器](https://web.archive.org/web/20220627074947/https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html)是一个分代、并发、低暂停收集器。它适用于年轻一代的复制和老一代的标记清除:

[![](../Images/2b032cb78e4667dfa837ebd246f5c59d.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-CMS-1.jpg)

它试图通过与用户程序同时执行大部分工作来最小化暂停时间。然而，它**仍然存在导致不可预测的暂停**的问题，需要更多的 CPU 时间，并且不适合大于 4 GB 的堆。

作为 CMS 的长期替代品，Java 7 中引入了[垃圾优先(G1)收集器](https://web.archive.org/web/20220627074947/https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm)。G1 是一个分代的、并行的、并发的、增量压缩的低暂停收集器。它在年轻一代中适用于复制，在老一代中适用于标记压缩:

[![](../Images/9d9852abb458c7e3df5d2fed13192d80.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-G1-1.jpg)

然而，G1 也是一个区域化的收集器，它将堆区域构造成更小的区域。这给了它**更多可预测暂停**的好处。针对具有大量内存的多处理器机器，G1 **也不能摆脱暂停**。

因此，寻找更好的垃圾收集器的竞赛仍在继续，尤其是能进一步减少暂停时间的垃圾收集器。JVM 最近推出了一系列实验性的收集器，比如 Z、Epsilon 和 Shenandoah。除此之外，G1 继续得到更多的改善。

我们的目标是尽可能接近一个贫乏的 Java！

## 3.谢南多厄垃圾收集器

[Shenandoah](https://web.archive.org/web/20220627074947/https://wiki.openjdk.java.net/display/shenandoah/Main) 是**一个实验性的收集器，已经在 Java 12 中引入，并被定位为延迟专家**。它试图通过与用户程序同时进行更多的垃圾收集工作来减少暂停时间。

例如，Shenendoah 试图同时执行对象重定位和压缩。这实质上意味着 Shenandoah 中的暂停时间不再与堆大小成正比。因此，它可以**提供一致的低暂停行为，而不管堆大小如何**。

### 3.1.堆结构

和 G1 一样，谢南多厄也是一名地域化的收藏家。这意味着它**将堆区域分成一组大小相等的区域**。区域基本上是内存分配或回收的单位:

[![](../Images/a10a7b4684ae1bbd29a746daf750ee97.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Shenandoah-Heap-Structure.jpg)

但是，与 G1 和其他分代收集者不同，谢南多没有将堆区分成几代。因此，它必须在每个周期标记大多数活动对象，这是分代收集器可以避免的。

### 3.2.对象布局

在 Java 中，内存中的对象不仅仅包括数据字段，它们还携带一些额外的信息。这个额外的信息由头部和标记字组成，头部包含一个指向对象类的指针。标记字有几种用法，如转发指针、年龄位、锁定和散列:

[![](../Images/043c2c2b56ae02cf6d00ea6944526768.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Shenandoah-Object-Layout.jpg)

Shenandoah **给这个对象布局**添加了一个额外的单词。这充当间接指针，并允许 Shenandoah 移动对象，而不更新对它们的所有引用。这就是**，也被称为布鲁克斯指针**。

### 3.3.障碍

在 stop-the-world 模式下执行一个收集周期更简单，但是当我们与用户程序同时执行时，复杂性就会激增。它对收集阶段提出了不同的挑战，如并发标记和压缩。

解决方案在于**通过我们所谓的屏障**拦截所有堆访问。谢南多厄和 G1 等其他并发收集器利用屏障来确保堆的一致性。然而，栅栏是昂贵的操作，并且通常倾向于降低收集器的产量。

例如，收集器可以使用屏障来拦截对对象的读写操作:

[![](../Images/773db7208e7dddf741bad1db095b7ec7.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Barriers.jpg)

Shenandoah **在不同阶段使用多种屏障，如 SATB 屏障、读取屏障和写入屏障**。我们将在后面的章节中看到它们的用途。

### 3.4.模式、试探法和故障模式

模式**定义了 Shenandoah 运行**的方式，比如它使用哪些障碍，它们也定义了它的性能特征。有三种模式可用:正常/SATB、iu 和被动。默认为正常/SATB 模式。

试探法**确定收集应该何时开始以及应该包括哪些区域**。这些策略包括自适应、静态、紧凑和主动，自适应是默认的启发式策略。例如，它可以选择包含 60%或更多垃圾的区域，并在分配了 75%的区域时开始一个收集周期。

Shenandoah 需要比分配堆的用户程序更快地收集堆。但是，**有时，它可能会落后，导致故障模式之一**。这些故障模式包括起搏、退化收集，以及在最坏的情况下，完全收集。

## 4.Shenandoah 收集阶段

Shenandoah 的收集周期主要包括三个阶段:标记、撤离和更新参考文献。尽管这些阶段中的大部分工作与用户程序同时发生，但仍有一小部分必须以停止世界模式发生。

### 4.1.标记

标记是**识别堆中所有对象或其不可达部分的过程**。我们可以从根对象开始，遍历对象图来找到可到达的对象。在遍历时，我们还为每个对象分配三种颜色之一:白色、灰色或黑色:

[![](../Images/a1e43d5b58136e2e3ac1d12ee34681a2.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Shenandoah-Marking-1.jpg)

停止世界模式中的标记更简单，但是在并发模式中变得复杂。这是因为用户程序在打标过程中同时改变了对象图形。Shenandoah 通过使用起始快照(SATB)算法来解决这个问题。

这意味着，任何在标记开始时是活动的对象，或者从标记开始起就被分配的对象都被认为是活动的。Shenandoah **利用 SATB 屏障**来维护堆的 SATB 视图。

虽然**大部分标记是同时完成的**，但仍有一些部分是在停止世界模式下完成的。在 stop-the-world 模式中发生的部分是扫描根集的 init-mark 和清空所有未决队列并重新扫描根集的 final-mark。最终标记还准备了指示要撤离的区域的收集组。

### 4.2.清理和疏散

一旦标记完成，垃圾区域就可以回收了。**垃圾区域是不存在活动对象的区域**。清理同时发生。

现在，下一步是将收集组中的活动对象移动到其他区域。这样做是为了减少内存分配中的碎片，因此也称为压缩。排空或压实完全同时发生。

这就是谢南多和其他收藏家不同的地方。当用户程序继续读写对象时，对象的并发重定位是很棘手的。Shenandoah 设法通过对一个对象的 Brooks 指针执行**比较和交换操作以指向其空间版本来实现这一点:**

[![](../Images/a1f302dd2dafc6d686e3cf261649f6f2.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Shenandoah-Barriers.jpg)

此外，Shenandoah **使用读写屏障来确保在并行撤离期间保持严格的“到空间”不变量**。这意味着读取和写入必须从 to 空间进行，以保证在撤离后仍然存在。

### 4.3.参考更新

收集周期中的这个阶段是**遍历堆并更新对在清空期间被移动的对象的引用**:

[![](../Images/ac5994ae7c95b73815bbf05aadf80367.png)](/web/20220627074947/https://www.baeldung.com/wp-content/uploads/2021/01/Garbage-Collector-Shenandoah-Update-Refs.jpg)

更新参考阶段再次在**大部分同时进行**。初始化更新引用阶段的 init-update-refs 和重新更新根集并从收集集中回收区域的 final-update-refs 有短暂的周期。只有这些需要停止世界模式。

## 5.与其他实验收集器的比较

Shenandoah 并不是最近在 Java 中引入的唯一一个实验性的垃圾收集器。其他包括 Z 和 Epsilon。让我们了解一下他们与谢南多厄的对比。

### 5.1.z 收集器

在 Java 11 中引入的 [Z 收集器](/web/20220627074947/https://www.baeldung.com/jvm-zgc-garbage-collector)是**，它是为非常大的堆大小**设计的单代、低延迟收集器——我们正在谈论数 TB 的领域。Z 收集器的大部分工作与用户程序同时进行，并利用堆引用的负载屏障。

此外，Z 收集器通过一种称为指针着色的技术来利用 64 位指针。这里，彩色指针存储了堆上对象的额外信息。Z 收集器使用指针中存储的额外信息来重新映射对象，以减少内存碎片。

大体上来说，**Z 收藏家的目标和 Shenandoah** 的目标相似。它们都旨在实现与堆大小不成正比的低暂停时间。然而，**与 Z 收集器**相比，Shenandoah 有更多的调谐选项。

### 5.2.ε收集器

同样在 Java 11 中引入的 Epsilon 有一个非常不同的垃圾收集方法。它基本上是**一个被动或“无操作”的收集器，**这意味着它处理内存分配，但不回收它！因此，当堆耗尽内存时，JVM 就会关闭。

但是我们为什么要用这样的收集器呢？基本上，任何垃圾收集器都会对用户程序的性能产生间接影响。很难对一个应用程序进行基准测试，也很难理解垃圾收集对它的影响。

艾司隆正是为此服务的。它简单地**消除了垃圾收集器**的影响，让我们独立运行应用程序。但是，这要求我们对应用程序的内存需求有一个非常清晰的理解。因此，我们可以从应用程序中获得更好的性能。

显然， **Epsilon 与 Shenandoah** 有着非常不同的目标。

## 6.结论

在本文中，我们介绍了 Java 中垃圾收集的基础知识以及不断改进它的必要性。我们详细讨论了 Java 中引入的最新实验收集器——Shenandoah。我们还讨论了它与 Java 中其他实验性收集器的区别。

对通用垃圾收集器的追求不会很快实现！因此，虽然 G1 仍然是默认的收集器，但是这些新增功能为我们提供了在低延迟情况下使用 Java 的选项。但是，我们不应该将它们视为其他高通量收集器的替代产品。