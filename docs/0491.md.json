["```\r\n{\"APPLE\", \"ORANGE\", \"MANGO\"}\r\n```","```\r\n{\r\n    {},\r\n    {\"APPLE\"},\r\n    {\"ORANGE\"},\r\n    {\"APPLE\", \"ORANGE\"},\r\n    {\"MANGO\"},\r\n    {\"APPLE\", \"MANGO\"},\r\n    {\"ORANGE\", \"MANGO\"},\r\n    {\"APPLE\", \"ORANGE\", \"MANGO\"}\r\n}\r\n```","```\r\n{\r\n    {},\r\n    {\"MANGO\"},\r\n    {\"ORANGE\"},\r\n    {\"ORANGE\", \"MANGO\"},\r\n    {\"APPLE\"},\r\n    {\"APPLE\", \"MANGO\"},\r\n    {\"APPLE\", \"ORANGE\"},\r\n    {\"APPLE\", \"ORANGE\", \"MANGO\"}\r\n}\r\n```","```\r\n@Test\r\npublic void givenSet_WhenGuavaLibraryGeneratePowerSet_ThenItContainsAllSubsets() {\r\n    ImmutableSet<String> set = ImmutableSet.of(\"APPLE\", \"ORANGE\", \"MANGO\");\r\n    Set<Set<String>> powerSet = Sets.powerSet(set);\r\n    Assertions.assertEquals((1 << set.size()), powerSet.size());\r\n    MatcherAssert.assertThat(powerSet, Matchers.containsInAnyOrder(\r\n      ImmutableSet.of(),\r\n      ImmutableSet.of(\"APPLE\"),\r\n      ImmutableSet.of(\"ORANGE\"),\r\n      ImmutableSet.of(\"APPLE\", \"ORANGE\"),\r\n      ImmutableSet.of(\"MANGO\"),\r\n      ImmutableSet.of(\"APPLE\", \"MANGO\"),\r\n      ImmutableSet.of(\"ORANGE\", \"MANGO\"),\r\n      ImmutableSet.of(\"APPLE\", \"ORANGE\", \"MANGO\")\r\n   ));\r\n}\r\n```","```\r\nT element = set.iterator().next();\r\nSet<T> subsetWithoutElement = new HashSet<>();\r\nfor (T s : set) {\r\n    if (!s.equals(element)) {\r\n        subsetWithoutElement.add(s);\r\n    }\r\n}\r\n```","```\r\nSet<Set<T>> powersetSubSetWithoutElement = recursivePowerSet(subsetWithoutElement);\r\n```","```\r\nSet<Set<T>> powersetSubSetWithElement = new HashSet<>();\r\nfor (Set<T> subsetWithoutElement : powerSetSubSetWithoutElement) {\r\n    Set<T> subsetWithElement = new HashSet<>(subsetWithoutElement);\r\n    subsetWithElement.add(element);\r\n    powerSetSubSetWithElement.add(subsetWithElement);\r\n}\r\n```","```\r\nSet<Set<T>> powerSet = new HashSet<>();\r\npowerSet.addAll(powerSetSubSetWithoutElement);\r\npowerSet.addAll(powerSetSubSetWithElement);\r\n```","```\r\npublic Set<Set<T>> recursivePowerSet(Set<T> set) {\r\n    if (set.isEmpty()) {\r\n        Set<Set<T>> ret = new HashSet<>();\r\n        ret.add(set);\r\n        return ret;\r\n    }\r\n\r\n    T element = set.iterator().next();\r\n    Set<T> subSetWithoutElement = getSubSetWithoutElement(set, element);\r\n    Set<Set<T>> powerSetSubSetWithoutElement = recursivePowerSet(subSetWithoutElement);\r\n    Set<Set<T>> powerSetSubSetWithElement = addElementToAll(powerSetSubSetWithoutElement, element);\r\n\r\n    Set<Set<T>> powerSet = new HashSet<>();\r\n    powerSet.addAll(powerSetSubSetWithoutElement);\r\n    powerSet.addAll(powerSetSubSetWithElement);\r\n    return powerSet;\r\n} \r\n```","```\r\nMatcherAssert.assertThat(powerSet, IsCollectionWithSize.hasSize((1 << set.size())));\r\n```","```\r\nMap<String, Integer> counter = new HashMap<>();\r\nfor (Set<String> subset : powerSet) { \r\n    for (String name : subset) {\r\n        int num = counter.getOrDefault(name, 0);\r\n        counter.put(name, num + 1);\r\n    }\r\n}\r\ncounter.forEach((k, v) -> Assertions.assertEquals((1 << (set.size() - 1)), v.intValue()));\r\n```","```\r\n@Test\r\npublic void givenSet_WhenPowerSetIsCalculated_ThenItContainsAllSubsets() {\r\n    Set<String> set = RandomSetOfStringGenerator.generateRandomSet();\r\n    Set<Set<String>> powerSet = new PowerSet<String>().recursivePowerSet(set);\r\n    MatcherAssert.assertThat(powerSet, IsCollectionWithSize.hasSize((1 << set.size())));\r\n\r\n    Map<String, Integer> counter = new HashMap<>();\r\n    for (Set<String> subset : powerSet) {\r\n        for (String name : subset) {\r\n            int num = counter.getOrDefault(name, 0);\r\n            counter.put(name, num + 1);\r\n        }\r\n    }\r\n    counter.forEach((k, v) -> Assertions.assertEquals((1 << (set.size() - 1)), v.intValue()));\r\n}\r\n```","```\r\nprivate Map<T, Integer> map = new HashMap<>();\r\nprivate List<T> reverseMap = new ArrayList<>();\r\n\r\nprivate void initializeMap(Collection<T> collection) {\r\n    int mapId = 0;\r\n    for (T c : collection) {\r\n        map.put(c, mapId++);\r\n        reverseMap.add(c);\r\n    }\r\n}\r\n```","```\r\n{\r\n   {} -> {}\r\n   [0] -> {\"APPLE\"}\r\n   [1] -> {\"ORANGE\"}\r\n   [0,1] -> {\"APPLE\", \"ORANGE\"}\r\n   [2] -> {\"MANGO\"}\r\n   [0,2] -> {\"APPLE\", \"MANGO\"}\r\n   [1,2] -> {\"ORANGE\", \"MANGO\"}\r\n   [0,1,2] -> {\"APPLE\", \"ORANGE\", \"MANGO\"}\r\n}\r\n```","```\r\nprivate Set<Set<T>> unMapIndex(Set<Set<Integer>> sets) {\r\n    Set<Set<T>> ret = new HashSet<>();\r\n    for (Set<Integer> s : sets) {\r\n        HashSet<T> subset = new HashSet<>();\r\n        for (Integer i : s) {\r\n            subset.add(reverseMap.get(i));\r\n        }\r\n        ret.add(subset);\r\n    }\r\n    return ret;\r\n}\r\n```","```\r\n{\r\n    [0,0,0] -> {}\r\n    [1,0,0] -> {\"APPLE\"}\r\n    [0,1,0] -> {\"ORANGE\"}\r\n    [1,1,0] -> {\"APPLE\", \"ORANGE\"}\r\n    [0,0,1] -> {\"MANGO\"}\r\n    [1,0,1] -> {\"APPLE\", \"MANGO\"}\r\n    [0,1,1] -> {\"ORANGE\", \"MANGO\"}\r\n    [1,1,1] -> {\"APPLE\", \"ORANGE\", \"MANGO\"}\r\n}\r\n```","```\r\nprivate Set<Set<T>> unMapBinary(Collection<List<Boolean>> sets) {\r\n    Set<Set<T>> ret = new HashSet<>();\r\n    for (List<Boolean> s : sets) {\r\n        HashSet<T> subset = new HashSet<>();\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s.get(i)) {\r\n                subset.add(reverseMap.get(i));\r\n            }\r\n        }\r\n        ret.add(subset);\r\n    }\r\n    return ret;\r\n}\r\n```","```\r\npublic Set<Set<T>> recursivePowerSetIndexRepresentation(Collection<T> set) {\r\n    initializeMap(set);\r\n    Set<Set<Integer>> powerSetIndices = recursivePowerSetIndexRepresentation(0, set.size());\r\n    return unMapIndex(powerSetIndices);\r\n}\r\n```","```\r\nprivate Set<Set<Integer>> recursivePowerSetIndexRepresentation(int idx, int n) {\r\n    if (idx == n) {\r\n        Set<Set<Integer>> empty = new HashSet<>();\r\n        empty.add(new HashSet<>());\r\n        return empty;\r\n    }\r\n    Set<Set<Integer>> powerSetSubset = recursivePowerSetIndexRepresentation(idx + 1, n);\r\n    Set<Set<Integer>> powerSet = new HashSet<>(powerSetSubset);\r\n    for (Set<Integer> s : powerSetSubset) {\r\n        HashSet<Integer> subSetIdxInclusive = new HashSet<>(s);\r\n        subSetIdxInclusive.add(idx);\r\n        powerSet.add(subSetIdxInclusive);\r\n    }\r\n    return powerSet;\r\n}\r\n```","```\r\nprivate Set<List<Boolean>> recursivePowerSetBinaryRepresentation(int idx, int n) {\r\n    if (idx == n) {\r\n        Set<List<Boolean>> powerSetOfEmptySet = new HashSet<>();\r\n        powerSetOfEmptySet.add(Arrays.asList(new Boolean[n]));\r\n        return powerSetOfEmptySet;\r\n    }\r\n    Set<List<Boolean>> powerSetSubset = recursivePowerSetBinaryRepresentation(idx + 1, n);\r\n    Set<List<Boolean>> powerSet = new HashSet<>();\r\n    for (List<Boolean> s : powerSetSubset) {\r\n        List<Boolean> subSetIdxExclusive = new ArrayList<>(s);\r\n        subSetIdxExclusive.set(idx, false);\r\n        powerSet.add(subSetIdxExclusive);\r\n        List<Boolean> subSetIdxInclusive = new ArrayList<>(s);\r\n        subSetIdxInclusive.set(idx, true);\r\n        powerSet.add(subSetIdxInclusive);\r\n    }\r\n    return powerSet;\r\n}\r\n```","```\r\nprivate List<List<Boolean>> iterativePowerSetByLoopOverNumbers(int n) {\r\n    List<List<Boolean>> powerSet = new ArrayList<>();\r\n    for (int i = 0; i < (1 << n); i++) {\r\n        List<Boolean> subset = new ArrayList<>(n);\r\n        for (int j = 0; j < n; j++)\r\n            subset.add(((1 << j) & i) > 0);\r\n        powerSet.add(subset);\r\n    }\r\n    return powerSet;\r\n}\r\n```","```\r\nprivate List<List<Boolean>> iterativePowerSetByLoopOverNumbersWithGrayCodeOrder(int n) {\r\n    List<List<Boolean>> powerSet = new ArrayList<>();\r\n    for (int i = 0; i < (1 << n); i++) {\r\n        List<Boolean> subset = new ArrayList<>(n);\r\n        for (int j = 0; j < n; j++) {\r\n            int grayEquivalent = i ^ (i >> 1);\r\n            subset.add(((1 << j) & grayEquivalent) > 0);\r\n        }\r\n        powerSet.add(subset);\r\n    }\r\n    return powerSet;\r\n}\r\n```","```\r\nabstract class ListIterator<K> implements Iterator<K> {\r\n    protected int position = 0;\r\n    private int size;\r\n    public ListIterator(int size) {\r\n        this.size = size;\r\n    }\r\n    @Override\r\n    public boolean hasNext() {\r\n        return position < size;\r\n    }\r\n}\r\n```","```\r\n@Override\r\npublic Set<E> next() {\r\n    return new Subset<>(map, reverseMap, position++);\r\n}\r\n```","```\r\n@Override\r\npublic int size() { \r\n    return Integer.bitCount(mask);\r\n}\r\n```","```\r\n@Override\r\npublic boolean contains(@Nullable Object o) {\r\n    Integer index = map.get(o);\r\n    return index != null && (mask & (1 << index)) != 0;\r\n}\r\n```","```\r\n@Override\r\npublic boolean hasNext() {\r\n    return remainingSetBits != 0;\r\n}\r\n```","```\r\n@Override\r\npublic E next() {\r\n    int index = Integer.numberOfTrailingZeros(remainingSetBits);\r\n    if (index == 32) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    remainingSetBits &= ~(1 << index);\r\n    return reverseMap.get(index);\r\n}\r\n```","```\r\n@Override\r\npublic int size() {\r\n    return (1 << this.set.size());\r\n}\r\n```","```\r\n@Override\r\npublic boolean contains(@Nullable Object obj) {\r\n    if (obj instanceof Set) {\r\n        Set<?> set = (Set<?>) obj;\r\n        return reverseMap.containsAll(set);\r\n    }\r\n    return false;\r\n}\r\n```","```\r\n@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    if (obj instanceof PowerSet) {\r\n        PowerSet<?> that = (PowerSet<?>) obj;\r\n        return set.equals(that.set);\r\n    }\r\n    return super.equals(obj);\r\n}\r\n```","```\r\n@Override\r\npublic Iterator<Set<E>> iterator() {\r\n    return new ListIterator<Set<E>>(this.size()) {\r\n        @Override\r\n        public Set<E> next() {\r\n            return new Subset<>(map, reverseMap, position++);\r\n        }\r\n    };\r\n}\r\n```"]