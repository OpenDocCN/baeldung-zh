# 杰克逊-双向关系

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jackson-bidirectional-relationships-and-infinite-recursion>

## **1。概述**

在本教程中，我们将回顾在 Jackson 中处理**双向关系的最佳方式。**

我们将讨论 Jackson JSON 无限递归问题，然后——我们将看到如何序列化具有双向关系的实体，最后——我们将反序列化它们。

## **2。无限递归**

首先，让我们看看杰克逊无限递归问题。在下面的例子中，我们有两个实体——“`User`”和“`Item`”——与**有一个简单的一对多关系**:

`User`实体:

[PRE0]

`Item`实体:

[PRE1]

当我们试图序列化一个"`Item`"的实例时，Jackson 会抛出一个`JsonMappingException`异常:

[PRE2]

**满异常**是:

[PRE3]

让我们在接下来的几节课程中，看看如何解决这个问题。

## **3。使用`@JsonManagedReference`、`@JsonBackReference`、**

首先，让我们用`@JsonManagedReference`、`@JsonBackReference`来注释这个关系，以便让 Jackson 更好地处理这个关系:

下面是“`User`”实体:

[PRE4]

`Item`还有那个“:

[PRE5]

现在让我们测试一下新的实体:

[PRE6]

以下是序列化项目对象的输出:

[PRE7]

下面是序列化用户对象的输出:

[PRE8]

请注意:

*   `@JsonManagedReference`是引用的前向部分——正常序列化的部分。
*   `@JsonBackReference`是引用的后半部分——它将从序列化中省略。
*   序列化的`Item`对象不包含对`User`对象的引用。

另外，请注意，我们不能切换注释。以下内容适用于序列化:

[PRE9]

但是当我们试图反序列化对象时会抛出一个异常，因为`@JsonBackReference`不能用于集合。

如果我们想让序列化的项目对象包含对用户的引用，我们需要使用`@JsonIdentityInfo`。我们将在下一节讨论这个问题。

## **4。使用`@JsonIdentityInfo`**

现在，让我们看看如何使用`@JsonIdentityInfo`来帮助具有双向关系的实体的序列化。

我们将类级注释添加到我们的“`User`”实体中:

[PRE10]

和到"`Item`"实体:

[PRE11]

测试时间:

[PRE12]

以下是序列化的输出:

[PRE13]

## **5。使用`@JsonIgnore`**

或者，我们也可以使用`@JsonIgnore`注释来简单地**忽略关系**的一方，从而打破这个链。

在下面的示例中，我们将通过忽略序列化中的"`User`"属性"`userItems`"来防止无限递归:

这里是"`User`"实体:

[PRE14]

这是我们的测试:

[PRE15]

以下是序列化的结果:

[PRE16]

## **6。使用`@JsonView`**

我们还可以使用更新的`@JsonView`注释来排除关系的一方。

在下面的例子中——我们使用**两个 JSON 视图——`Public`和`Internal`T5，其中`Internal`扩展了`Public`:**

[PRE17]

我们将在`Public`视图—**中包含所有的`User`和`Item`字段，除了`User`字段`userItems`** 将包含在`Internal`视图中:

下面是我们的实体"`User`":

[PRE18]

而这里是我们的实体"`Item`":

[PRE19]

当我们使用`Public`视图进行序列化时，它可以正确地工作——**，因为我们将`userItems`** 排除在序列化之外:

[PRE20]

但是如果我们使用`Internal`视图进行序列化，就会抛出`JsonMappingException`,因为所有的字段都包含在内:

[PRE21]

## **7。使用自定义串行器**

接下来，让我们看看如何使用自定义序列化程序来序列化具有双向关系的实体。

在以下示例中，我们将使用自定义序列化程序来序列化“`User`”属性“`userItems`”:

下面是“`User`”实体:

[PRE22]

而这里是“`CustomListSerializer`”:

[PRE23]

现在让我们测试一下序列化程序，看看产生了哪种正确的输出:

[PRE24]

以及**用定制串行化器串行化的最终输出**:

[PRE25]

## **8。用`@JsonIdentityInfo`反序列化**

现在，让我们看看如何使用`@JsonIdentityInfo`反序列化具有双向关系的实体。

这里是"`User`"实体:

[PRE26]

和“`Item`”实体:

[PRE27]

现在让我们编写一个快速测试——从我们想要解析的一些手动 JSON 数据开始，以正确构造的实体结束:

[PRE28]

## **9。使用自定义反序列化器**

最后，让我们使用一个定制的反序列化器来反序列化具有双向关系的实体。

在下面的例子中，我们将使用一个定制的反序列化器来解析“`User`”属性“`userItems`”:

下面是"`User`"实体:

[PRE29]

而这里是我们的“`CustomListDeserializer`”:

[PRE30]

简单的测试是:

[PRE31]

## 10。结论

在本教程中，我们演示了如何使用 Jackson 来序列化/反序列化具有双向关系的实体。

所有这些例子和代码片段**的实现可以在我们的 [GitHub 项目](https://web.archive.org/web/20220628090852/https://github.com/eugenp/tutorials/tree/master/jackson-modules/jackson-annotations#readme "Github Project covering all Jackson examples")** 中找到——这是一个基于 Maven 的项目，所以它应该很容易导入和运行。