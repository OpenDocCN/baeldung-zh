["```\r\nint getKthElementSorted(int[] list1, int[] list2, int k) {\r\n\r\n    int length1 = list1.length, length2 = list2.length;\r\n    int[] combinedArray = new int[length1 + length2];\r\n    System.arraycopy(list1, 0, combinedArray, 0, list1.length);\r\n    System.arraycopy(list2, 0, combinedArray, list1.length, list2.length);\r\n    Arrays.sort(combinedArray);\r\n\r\n    return combinedArray[k-1];\r\n}\r\n```","```\r\npublic static int getKthElementMerge(int[] list1, int[] list2, int k) {\r\n\r\n    int i1 = 0, i2 = 0;\r\n\r\n    while(i1 < list1.length && i2 < list2.length && (i1 + i2) < k) {\r\n        if(list1[i1] < list2[i2]) {\r\n            i1++;\r\n        } else {\r\n            i2++;\r\n        }\r\n    }\r\n\r\n    if((i1 + i2) < k) {\r\n        return i1 < list1.length ? list1[k - i2 - 1] : list2[k - i1 - 1]; \r\n    } else if(i1 > 0 && i2 > 0) {\r\n        return Math.max(list1[i1-1], list2[i2-1]);\r\n    } else {\r\n        return i1 == 0 ? list2[i2-1] : list1[i1-1];\r\n    }\r\n}\r\n```","```\r\nint findKthElement(int k, int[] list1, int[] list2)\r\n    throws NoSuchElementException, IllegalArgumentException {\r\n\r\n    // check input (see below)\r\n\r\n    // handle special cases (see below)\r\n\r\n    // binary search (see below)\r\n}\r\n```","```\r\nint nElementsList2 = k - nElementsList1; \r\n```","```\r\nint right = k;\r\nint left = = 0;\r\ndo {\r\n    nElementsList1 = ((left + right) / 2) + 1;\r\n    nElementsList2 = k - nElementsList1;\r\n\r\n    if(nElementsList2 > 0) {\r\n        if (list1[nElementsList1 - 1] > list2[nElementsList2 - 1]) {\r\n            right = nElementsList1 - 2;\r\n        } else {\r\n            left = nElementsList1;\r\n        }\r\n    }\r\n} while(!kthSmallesElementFound(list1, list2, nElementsList1, nElementsList2));\r\n```","```\r\nprivate static boolean foundCorrectNumberOfElementsInBothLists(int[] list1, int[] list2, int nElementsList1, int nElementsList2) {\r\n\r\n    // we do not take any element from the second list\r\n    if(nElementsList2 < 1) {\r\n        return true;\r\n    }\r\n\r\n    if(list1[nElementsList1-1] == list2[nElementsList2-1]) {\r\n        return true;\r\n    }\r\n\r\n    if(nElementsList1 == list1.length) {\r\n        return list1[nElementsList1-1] <= list2[nElementsList2];\r\n    }\r\n\r\n    if(nElementsList2 == list2.length) {\r\n        return list2[nElementsList2-1] <= list1[nElementsList1];\r\n    }\r\n\r\n    return list1[nElementsList1-1] <= list2[nElementsList2] && list2[nElementsList2-1] <= list1[nElementsList1];\r\n}\r\n```","```\r\nreturn nElementsList2 == 0 ? list1[nElementsList1-1] : max(list1[nElementsList1-1], list2[nElementsList2-1]);\r\n```","```\r\nint right = k;\r\nint left = 0;\r\n```","```\r\n// correct left boundary if k is bigger than the size of list2\r\nint left = k < list2.length ? 0 : k - list2.length - 1;\r\n\r\n// the inital right boundary cannot exceed the list1\r\nint right = min(k-1, list1.length - 1);\r\n```","```\r\n// we are looking for the minimum value\r\nif(k == 1) {\r\n    return min(list1[0], list2[0]);\r\n}\r\n\r\n// we are looking for the maximum value\r\nif(list1.length + list2.length == k) {\r\n    return max(list1[list1.length-1], list2[list2.length-1]);\r\n}\r\n\r\n// swap lists if needed to make sure we take at least one element from list1\r\nif(k <= list2.length && list2[k-1] < list1[0]) {\r\n    int[] list1_ = list1;\r\n    list1 = list2;\r\n    list2 = list1_;\r\n}\r\n```","```\r\nvoid checkInput(int k, int[] list1, int[] list2) throws NoSuchElementException, IllegalArgumentException {\r\n\r\n    if(list1 == null || list2 == null || k < 1) { \r\n        throw new IllegalArgumentException(); \r\n    }\r\n\r\n    if(list1.length == 0 || list2.length == 0) { \r\n        throw new IllegalArgumentException(); \r\n    } \r\n\r\n    if(k > list1.length + list2.length) {\r\n        throw new NoSuchElementException();\r\n    }\r\n}\r\n```","```\r\npublic static int findKthElement(int k, int[] list1, int[] list2) throws NoSuchElementException, IllegalArgumentException {\r\n\r\n    checkInput(k, list1, list2);\r\n\r\n    // we are looking for the minimum value\r\n    if(k == 1) {\r\n        return min(list1[0], list2[0]);\r\n    }\r\n\r\n    // we are looking for the maximum value\r\n    if(list1.length + list2.length == k) {\r\n        return max(list1[list1.length-1], list2[list2.length-1]);\r\n    }\r\n\r\n    // swap lists if needed to make sure we take at least one element from list1\r\n    if(k <= list2.length && list2[k-1] < list1[0]) {\r\n        int[] list1_ = list1;\r\n        list1 = list2;\r\n        list2 = list1_;\r\n    }\r\n\r\n    // correct left boundary if k is bigger than the size of list2\r\n    int left = k < list2.length ? 0 : k - list2.length - 1; \r\n\r\n    // the inital right boundary cannot exceed the list1 \r\n    int right = min(k-1, list1.length - 1); \r\n\r\n    int nElementsList1, nElementsList2; \r\n\r\n    // binary search \r\n    do { \r\n        nElementsList1 = ((left + right) / 2) + 1; \r\n        nElementsList2 = k - nElementsList1; \r\n\r\n        if(nElementsList2 > 0) {\r\n            if (list1[nElementsList1 - 1] > list2[nElementsList2 - 1]) {\r\n                right = nElementsList1 - 2;\r\n            } else {\r\n                left = nElementsList1;\r\n            }\r\n        }\r\n    } while(!kthSmallesElementFound(list1, list2, nElementsList1, nElementsList2));\r\n\r\n    return nElementsList2 == 0 ? list1[nElementsList1-1] : max(list1[nElementsList1-1], list2[nElementsList2-1]);\r\n}\r\n\r\nprivate static boolean foundCorrectNumberOfElementsInBothLists(int[] list1, int[] list2, int nElementsList1, int nElementsList2) {\r\n\r\n    // we do not take any element from the second list\r\n    if(nElementsList2 < 1) {\r\n        return true;\r\n    }\r\n\r\n    if(list1[nElementsList1-1] == list2[nElementsList2-1]) {\r\n        return true;\r\n    }\r\n\r\n    if(nElementsList1 == list1.length) {\r\n        return list1[nElementsList1-1] <= list2[nElementsList2];\r\n    }\r\n\r\n    if(nElementsList2 == list2.length) {\r\n        return list2[nElementsList2-1] <= list1[nElementsList1];\r\n    }\r\n\r\n    return list1[nElementsList1-1] <= list2[nElementsList2] && list2[nElementsList2-1] <= list1[nElementsList1];\r\n}\r\n```","```\r\nint[] sortedRandomIntArrayOfLength(int length) {\r\n    int[] intArray = new Random().ints(length).toArray();\r\n    Arrays.sort(intArray);\r\n    return intArray;\r\n}\r\n```","```\r\nprivate void random() {\r\n\r\n    Random random = new Random();\r\n    int length1 = (Math.abs(random.nextInt())) % 1000 + 1;\r\n    int length2 = (Math.abs(random.nextInt())) % 1000 + 1;\r\n\r\n    int[] list1 = sortedRandomIntArrayOfLength(length1);\r\n    int[] list2 = sortedRandomIntArrayOfLength(length2);\r\n\r\n    int k = (Math.abs(random.nextInt()) + 1) % (length1 + length2);\r\n\r\n    int result = findKthElement(k, list1, list2);\r\n    int result2 = getKthElementSorted(list1, list2, k);\r\n    int result3 = getKthElementMerge(list1, list2, k);\r\n\r\n    assertEquals(result2, result);\r\n    assertEquals(result2, result3);\r\n}\r\n```","```\r\n@Test\r\nvoid randomTests() {\r\n    IntStream.range(1, 100000).forEach(i -> random());\r\n}\r\n```"]