["```\r\npublic class Cell {\r\n    private final int x;\r\n    private final int y;\r\n\r\n    // constructor, getters, and toString\r\n}\r\n```","```\r\npublic class Board {\r\n    private final int[][] board;\r\n    private final int score;\r\n\r\n    public Board(int size) {\r\n        this.board = new int[size][];\r\n        this.score = 0;\r\n\r\n        for (int x = 0; x < size; ++x) {\r\n            this.board[x] = new int[size];\r\n            for (int y = 0; y < size; ++y) {\r\n                board[x][y] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    public int getSize() {\r\n        return board.length;\r\n    }\r\n\r\n    public int getScore() {\r\n        return score;\r\n    }\r\n\r\n    public int getCell(Cell cell) {\r\n        return board[cell.getX()][cell.getY()];\r\n    }\r\n\r\n    public boolean isEmpty(Cell cell) {\r\n        return getCell(cell) == 0;\r\n    }\r\n\r\n    public List<Cell> emptyCells() {\r\n        List<Cell> result = new ArrayList<>();\r\n        for (int x = 0; x < board.length; ++x) {\r\n            for (int y = 0; y < board[x].length; ++y) {\r\n                Cell cell = new Cell(x, y);\r\n                if (isEmpty(cell)) {\r\n                    result.add(cell);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","```\r\nprivate Board(int[][] board, int score) {\r\n    this.score = score;\r\n    this.board = new int[board.length][];\r\n\r\n    for (int x = 0; x < board.length; ++x) {\r\n        this.board[x] = Arrays.copyOf(board[x], board[x].length);\r\n    }\r\n}\r\n```","```\r\npublic Board placeTile(Cell cell, int number) {\r\n    if (!isEmpty(cell)) {\r\n        throw new IllegalArgumentException(\"That cell is not empty\");\r\n    }\r\n\r\n    Board result = new Board(this.board, this.score);\r\n    result.board[cell.getX()][cell.getY()] = number;\r\n    return result;\r\n}\r\n```","```\r\npublic class Computer {\r\n    private final SecureRandom rng = new SecureRandom();\r\n\r\n    public Board makeMove(Board input) {\r\n        List<Cell> emptyCells = input.emptyCells();\r\n\r\n        double numberToPlace = rng.nextDouble();\r\n        int indexToPlace = rng.nextInt(emptyCells.size());\r\n        Cell cellToPlace = emptyCells.get(indexToPlace);\r\n\r\n        return input.placeTile(cellToPlace, numberToPlace >= 0.9 ? 4 : 2);\r\n    }\r\n}\r\n```","```\r\npublic enum Move {\r\n    UP,\r\n    DOWN,\r\n    LEFT,\r\n    RIGHT\r\n}\r\n```","```\r\nprivate static int[][] transpose(int[][] input) {\r\n    int[][] result = new int[input.length][];\r\n\r\n    for (int x = 0; x < input.length; ++x) {\r\n        result[x] = new int[input[0].length];\r\n        for (int y = 0; y < input[0].length; ++y) {\r\n            result[x][y] = input[y][x];\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nprivate static int[][] reverse(int[][] input) {\r\n    int[][] result = new int[input.length][];\r\n\r\n    for (int x = 0; x < input.length; ++x) {\r\n        result[x] = new int[input[0].length];\r\n        for (int y = 0; y < input[0].length; ++y) {\r\n            result[x][y] = input[x][input.length - y - 1];\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n```","```\r\npublic Board move(Move move) {\r\n    int newScore = 0;\r\n\r\n    // Clone the board\r\n    int[][] tiles = new int[this.board.length][];\r\n    for (int x = 0; x < this.board.length; ++x) {\r\n        tiles[x] = Arrays.copyOf(this.board[x], this.board[x].length);\r\n    }\r\n```","```\r\nif (move == Move.LEFT || move == Move.RIGHT) {\r\n    tiles = transpose(tiles);\r\n\r\n}\r\nif (move == Move.DOWN || move == Move.RIGHT) {\r\n    tiles = reverse(tiles);\r\n}\r\n```","```\r\nint[][] result = new int[tiles.length][];\r\nint newScore = 0;\r\n```","```\r\nfor (int x = 0; x < tiles.length; ++x) {\r\n    LinkedList<Integer> thisRow = new LinkedList<>();\r\n    for (int y = 0; y < tiles[0].length; ++y) {\r\n        if (tiles[x][y] > 0) {\r\n            thisRow.add(tiles[x][y]);\r\n        }\r\n    }\r\n```","```\r\nLinkedList<Integer> newRow = new LinkedList<>();\r\nwhile (thisRow.size() >= 2) {\r\n    int first = thisRow.pop();\r\n    int second = thisRow.peek();\r\n    if (second == first) {\r\n        int newNumber = first * 2;\r\n        newRow.add(newNumber);\r\n        newScore += newNumber;\r\n        thisRow.pop();\r\n    } else {\r\n        newRow.add(first);\r\n    }\r\n}\r\nnewRow.addAll(thisRow);\r\n```","```\r\n result[x] = new int[tiles[0].length];\r\n    for (int y = 0; y < tiles[0].length; ++y) {\r\n        if (newRow.isEmpty()) {\r\n            result[x][y] = 0;\r\n        } else {\r\n            result[x][y] = newRow.pop();\r\n        }\r\n    }\r\n}\r\n```","```\r\nif (move == Move.DOWN || move == Move.RIGHT) {\r\n    result = reverse(result);\r\n}\r\nif (move == Move.LEFT || move == Move.RIGHT) {\r\n    result = transpose(result);\r\n}\r\n```","```\r\n return new Board(result, this.score + newScore);\r\n}\r\n```","```\r\npublic class Human {\r\n    private SecureRandom rng = new SecureRandom();\r\n\r\n    public Board makeMove(Board input) {\r\n        Move move = Move.values()[rng.nextInt(4)];\r\n        return input.move(move);\r\n    }\r\n}\r\n```","```\r\nprivate static void printBoard(Board board) {\r\n    StringBuilder topLines = new StringBuilder();\r\n    StringBuilder midLines = new StringBuilder();\r\n    for (int x = 0; x < board.getSize(); ++x) {\r\n        topLines.append(\"+--------\");\r\n        midLines.append(\"|        \");\r\n    }\r\n    topLines.append(\"+\");\r\n    midLines.append(\"|\");\r\n\r\n    for (int y = 0; y < board.getSize(); ++y) {\r\n        System.out.println(topLines);\r\n        System.out.println(midLines);\r\n        for (int x = 0; x < board.getSize(); ++x) {\r\n            Cell cell = new Cell(x, y);\r\n            System.out.print(\"|\");\r\n            if (board.isEmpty(cell)) {\r\n                System.out.print(\"        \");\r\n            } else {\r\n                StringBuilder output = new StringBuilder(Integer.toString(board.getCell(cell)));\r\n                while (output.length() < 8) {\r\n                    output.append(\" \");\r\n                    if (output.length() < 8) {\r\n                        output.insert(0, \" \");\r\n                    }\r\n                }\r\n                System.out.print(output);\r\n            }\r\n        }\r\n        System.out.println(\"|\");\r\n        System.out.println(midLines);\r\n    }\r\n    System.out.println(topLines);\r\n    System.out.println(\"Score: \" + board.getScore());\r\n}\r\n```","```\r\nBoard board = new Board(4);\r\nComputer computer = new Computer();\r\nHuman human = new Human();\r\nfor (int i = 0; i < 2; ++i) {\r\n    board = computer.makeMove(board);\r\n}\r\n```","```\r\nprintBoard(board);\r\ndo {\r\n    System.out.println(\"Human move\");\r\n    System.out.println(\"==========\");\r\n    board = human.makeMove(board);\r\n    printBoard(board);\r\n\r\n    System.out.println(\"Computer move\");\r\n    System.out.println(\"=============\");\r\n    board = computer.makeMove(board);\r\n    printBoard(board);\r\n} while (!board.emptyCells().isEmpty());\r\n\r\nSystem.out.println(\"Final Score: \" + board.getScore());\r\n```","```\r\npublic Board makeMove(Board input) {\r\n    return Arrays.stream(Move.values())\r\n      .map(input::move)\r\n      .max(Comparator.comparingInt(board -> generateScore(board, 0)))\r\n      .orElse(input);\r\n}\r\n```","```\r\nprivate int generateScore(Board board, int depth) {\r\n    if (depth >= 3) {\r\n        return calculateFinalScore(board);\r\n    }\r\n    return board.emptyCells().stream()\r\n      .flatMap(cell -> Stream.of(new Pair<>(cell, 2), new Pair<>(cell, 4)))\r\n      .mapToInt(move -> {\r\n          Board newBoard = board.placeTile(move.getFirst(), move.getSecond());\r\n          int boardScore = calculateScore(newBoard, depth + 1);\r\n          return (int) (boardScore * (move.getSecond() == 2 ? 0.9 : 0.1));\r\n      })\r\n      .sum();\r\n}\r\n```","```\r\nprivate int calculateScore(Board board, int depth) {\r\n    return Arrays.stream(Move.values())\r\n      .map(board::move)\r\n      .mapToInt(newBoard -> generateScore(newBoard, depth))\r\n      .max()\r\n      .orElse(0);\r\n}\r\n```","```\r\nList<List<Integer>> rowsToScore = new ArrayList<>();\r\nfor (int i = 0; i < board.getSize(); ++i) {\r\n    List<Integer> row = new ArrayList<>();\r\n    List<Integer> col = new ArrayList<>();\r\n\r\n    for (int j = 0; j < board.getSize(); ++j) {\r\n        row.add(board.getCell(new Cell(i, j)));\r\n        col.add(board.getCell(new Cell(j, i)));\r\n    }\r\n\r\n    rowsToScore.add(row);\r\n    rowsToScore.add(col);\r\n}\r\n```","```\r\nreturn rowsToScore.stream()\r\n    .mapToInt(row -> {\r\n        int score = 0;\r\n        return score;\r\n    })\r\n    .sum();\r\n```","```\r\nList<Integer> preMerged = row.stream()\r\n  .filter(value -> value != 0)\r\n  .collect(Collectors.toList());\r\n```","```\r\nint numMerges = 0;\r\nint monotonicityLeft = 0;\r\nint monotonicityRight = 0;\r\nfor (int i = 0; i < preMerged.size() - 1; ++i) {\r\n    Integer first = preMerged.get(i);\r\n    Integer second = preMerged.get(i + 1);\r\n    if (first.equals(second)) {\r\n        ++numMerges;\r\n    } else if (first > second) {\r\n        monotonicityLeft += first - second;\r\n    } else {\r\n        monotonicityRight += second - first;\r\n    }\r\n}\r\n```","```\r\nint score = 1000;\r\nscore += 250 * row.stream().filter(value -> value == 0).count();\r\nscore += 750 * numMerges;\r\nscore -= 10 * row.stream().mapToInt(value -> value).sum();\r\nscore -= 50 * Math.min(monotonicityLeft, monotonicityRight);\r\nreturn score;\r\n```","```\r\n@Override\r\npublic boolean equals(Object o) {\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n    }\r\n    Board board1 = (Board) o;\r\n    return Arrays.deepEquals(board, board1.board);\r\n}\r\n```","```\r\nreturn Arrays.stream(Move.values())\r\n    .parallel()\r\n    .map(board::move)\r\n    .filter(moved -> !moved.equals(board))\r\n    ........\r\n```"]