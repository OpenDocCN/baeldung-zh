# 用 Java 管理亚马逊 SQS 队列

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/aws-queues-java>

## **1。概述**

在本教程中，我们将探索如何使用 Java SDK 来**使用亚马逊的 [SQS](https://web.archive.org/web/20220524015952/https://aws.amazon.com/sqs/) (简单队列服务)。**

## **2。先决条件**

使用 Amazon AWS SDK for SQS 所需的 Maven 依赖项、AWS 帐户设置和客户端连接与本文中的[相同。](/web/20220524015952/https://www.baeldung.com/aws-s3-java)

假设我们已经创建了前一篇文章中描述的`AWSCredentials,`的实例，我们可以继续创建我们的 SQS 客户端:

[PRE0]

## **3。创建队列**

一旦我们建立了 SQS 客户端，**创建队列相当简单。**

### **3.1。创建标准队列**

让我们看看如何创建一个标准队列。为此，**我们需要创建一个`CreateQueueRequest:`** 的实例

[PRE1]

### **3.2。创建 FIFO 队列**

创建 FIFO 类似于创建标准队列。我们仍将使用`CreateQueueRequest`的一个实例，就像我们之前做的那样。只是这一次，**我们必须传入队列属性，并将`FifoQueue`属性设置为`true` :**

[PRE2]

## **4。向队列发布消息**

一旦我们设置好队列，我们就可以开始发送消息了。

### **4.1。向标准队列发送消息**

为了向标准队列发送消息，我们将**必须创建一个`SendMessageRequest.`** 的实例

然后，我们将消息属性映射附加到该请求:

[PRE3]

`withDelaySeconds() `指定消息应该在多长时间后到达队列。

### **4.2。向 FIFO 队列发送消息**

在这种情况下，唯一的区别是**我们必须指定消息所属的[`group`](https://web.archive.org/web/20220524015952/https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html):**

[PRE4]

正如您在上面的代码示例中看到的，我们使用`withMessageGroupId().`来指定组

### **4.3。向队列发布多条消息**

我们也可以**使用一个请求向一个队列发送多条消息。**我们将创建一个`SendMessageBatchRequestEntry` 列表，我们将使用`SendMessageBatchRequest`的实例发送该列表:

[PRE5]

## **5。从队列中读取消息**

我们可以通过**调用`ReceiveMessageRequest:`** 实例上的`receiveMessage() `方法来接收队列中的消息

[PRE6]

使用`withMaxNumberOfMessages(),` 我们指定从队列中获取多少消息——尽管应该注意最大值是`10`。

方法`withWaitTimeSeconds()`启用`[long-polling](https://web.archive.org/web/20220524015952/https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html).`长轮询是一种限制我们发送到 SQS 的接收消息请求数量的方法。

简单地说，这意味着我们将等待指定的秒数来检索消息。如果在这段时间内队列中没有消息，那么请求将返回空值。如果消息在此期间到达队列，它将被返回。

我们可以**获得给定消息的属性和正文:**

[PRE7]

## **6。从队列中删除消息**

要删除消息，我们将使用一个`DeleteMessageRequest`:

[PRE8]

## 7 .**。死信队列**

**一个[死信队列](https://web.archive.org/web/20220524015952/https://en.wikipedia.org/wiki/Dead_letter_queue)必须和它的基本队列类型相同—** 如果基本队列是 FIFO，它必须是 FIFO，如果基本队列是标准队列，它必须是标准队列。对于这个例子，我们将使用一个标准队列。

我们需要做的第一件事是**创建将成为死信队列的内容:**

[PRE9]

接下来，我们将**获取我们新创建的队列的 [ARN(亚马逊资源名称)](https://web.archive.org/web/20220524015952/https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) :**

[PRE10]

最后，我们**将这个新创建的队列设置为我们原来的标准队列的死信队列:**

[PRE11]

**在构建我们的`SetQueueAttributesRequest `实例时，我们在`addAttributesEntry()`方法中设置的 JSON 包包含了我们需要的信息**:`maxReceiveCount`是`2`，这意味着如果一个消息被接收了这么多次，它就被认为没有被正确处理，并被发送到我们的死信队列。

属性将我们的标准队列指向我们新创建的死信队列。

## **8。监控**

我们可以**检查给定队列中当前有多少消息，以及有多少[正在使用 SDK](https://web.archive.org/web/20220524015952/https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html)进行处理。**首先，我们需要创建一个`GetQueueAttributesRequest. `

从这里，我们将检查队列的状态:

[PRE12]

使用[亚马逊云手表](https://web.archive.org/web/20220524015952/https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-monitoring-using-cloudwatch.html)可以实现更深入的监控。

## **9。结论**

在本文中，我们看到了如何使用 AWS Java SDK 管理 SQS 队列。

像往常一样，本文中使用的所有代码示例都可以在 GitHub 上找到[。](https://web.archive.org/web/20220524015952/https://github.com/eugenp/tutorials/tree/master/aws-modules/aws-miscellaneous)