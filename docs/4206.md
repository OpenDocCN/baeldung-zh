# 仅序列化符合 Jackson 自定义标准的字段

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jackson-serialize-field-custom-criteria>

## **1。概述**

本教程将说明如何使用 Jackson 来序列化一个满足特定自定义标准的字段。

例如，假设我们只希望序列化一个正值的整数值，如果不是，我们希望完全跳过它。

如果你想更深入地了解和学习其他很酷的事情，你可以用杰克逊 2 号来做——直接去[杰克逊的主要教程](/web/20221129010951/https://www.baeldung.com/jackson "The Jackson JSON Guide")。

## **2。使用杰克逊过滤器控制序列化过程**

首先，我们需要在我们的实体上定义过滤器，使用`@JsonFilter`注释:

[PRE0]

然后，我们需要定义我们的定制`PropertyFilter`:

[PRE1]

该过滤器包含基于其值决定`intValue`字段是否将被**序列化或不被**序列化的实际逻辑。

接下来，我们将这个过滤器挂接到`ObjectMapper`中，并序列化一个实体:

[PRE2]

最后，我们可以检查`intValue`字段确实是**的一部分，而不是被编组的 JSON 输出**的一部分:

[PRE3]

## **3。有条件地跳过对象**

现在，让我们讨论如何在基于属性**值**序列化时跳过对象。我们将跳过属性`hidden`为`true`的所有对象:

### **3.1。隐藏类**

首先，我们来看看我们的`Hidable`界面:

[PRE4]

我们有两个简单的类来实现这个接口`Person`、`Address`:

`Person`类别:

[PRE5]

和`Address`类:

[PRE6]

注意:我们使用了`@JsonIgnoreProperties(“hidden”)`来确保`hidden`属性本身不包含在 JSON 中

### **3.2。自定义串行器**

接下来——这是我们的自定义序列化程序:

[PRE7]

请注意:

*   当对象不会被跳过时，我们将序列化委托给默认的注入序列化程序。
*   我们覆盖了方法`isEmpty()`——以确保在隐藏对象是属性的情况下，属性名也被排除在 JSON 之外。

### **3.3。使用`BeanSerializerModifier`**

最后，我们将需要使用`BeanSerializerModifier`在我们的自定义`HidableSerializer`中注入默认的序列化程序，如下所示:

[PRE8]

### **3.4。样本输出**

下面是一个简单的序列化示例:

[PRE9]

输出是:

[PRE10]

### **3.5。测试**

最后，这里有几个测试案例:

第一种情况，**无所隐瞒**:

[PRE11]

接下来，**只有地址被隐藏**:

[PRE12]

现在，**整个人被隐藏起来**:

[PRE13]

## **4。结论**

这种类型的高级过滤非常强大，在用 Jackson 序列化复杂对象时，允许非常灵活地定制 json。

一个更灵活但也更复杂的替代方案是使用完全定制的序列化程序来控制 JSON 输出——因此，如果这个解决方案不够灵活，可能值得研究一下。

所有这些例子和代码片段的实现**可以在 GitHub** 上找到[——这是一个基于 Maven 的项目，所以它应该很容易导入和运行。](https://web.archive.org/web/20221129010951/https://github.com/eugenp/tutorials/tree/master/jackson-modules/jackson-custom-conversions "Github Project exemplifying how to change the json key of a filed")