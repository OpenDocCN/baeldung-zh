# Java 原语介绍

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-primitives>

## 1.概观

Java 编程语言有八种基本数据类型。

在本教程中，我们将看看这些原语是什么，并检查每种类型。

## 2.原始数据类型

Java 中定义的八个原语分别是`int`、`byte`、`short`、`long`、`float`、`double`、`boolean`和`char`。这些不被认为是对象，代表原始值。

**它们被直接存储在栈**(查看[这篇文章](/web/20221001005356/https://www.baeldung.com/java-initialization)以获得更多关于 Java 内存管理的信息)。

我们将了解存储大小、默认值以及如何使用每种类型的示例。

让我们先快速参考一下:

| 类型 | 大小(位) | 最低限度 | 最高的 | 例子 |
| --- | --- | --- | --- | --- |
| `byte` | eight | -2 ^(7</sup> | 2<sup>7)–1 | `byte b = 100;` |
| `short` | Sixteen | -2 ^(15) | 2^(15)–1 | `short s = 30_000;` |
| `int` | Thirty-two | -2 ^(31) | 2^(31)–1 | `int i = 100_000_000;` |
| `long` | Sixty-four | -2 ^(63) | 2^(63)–1 | `long l = 100_000_000_000_000;` |
| `float` | Thirty-two | -2 ^(-149) | (2-2^(-23)2^(127) | `float f = 1.456f;` |
| `double` | Sixty-four | -2 ^(-1074) | (2-2^(-52)2^(1023) | `double f = 1.456789012345678;` |
| `char` | Sixteen | Zero | 2^(16)–1 | `char c = ‘c';` |
| `boolean` | one | – | – | `boolean b = true;` |

### 2.1.`int`

我们要介绍的第一个原始数据类型是`int`。也称为整数，`int`类型保存大范围的非分数数值。

具体来说， **Java 使用 32 位内存存储。**换句话说，它可以表示从-2147483648(-2^(31))到 2147483647(2^(31)-1)的值。

在 Java 8 中，通过使用新的特殊帮助函数，可以存储高达 4，294，967，295 (2 ^(32) -1)的无符号整数值。

我们可以简单地声明一个`int`:

[PRE0]

**未赋值声明的`int`的默认值为 0。**

如果变量是在方法中定义的，我们必须在使用它之前赋值。

我们可以在`int`上执行所有标准的算术运算。只是要注意，在对整数执行这些运算时，**十进制数值将被砍掉**。

### 2.2.`byte`

`byte` 是一种类似于`int`的原始数据类型，除了**只占用 8 位内存。**这就是我们称之为字节的原因。因为内存太小，`byte`只能保存-128 (-2 ^(7</sup> )到 127(2<sup>7)–1)之间的值。

下面是我们如何创建`byte`:

[PRE1]

**`byte`的默认值也是 0。**

### 2.3.`short`

Java 中原始数据类型列表的下一站是`short`。

如果我们想节省内存并且`byte`太小，我们可以使用`byte`和`int`中间的类型:`short`。

在 16 位内存下，它是`int`的一半，是`byte`的两倍。它的可能值范围是-32，768(-2 ^(15) )到 32，767(2^(15)–1)。

`short`是这样声明的:

[PRE2]

与其他类型类似，默认值为 0。我们也可以使用所有的标准算法。

### 2.4.`long`

我们最后一个与整数相关的原语数据类型是`long`。

`long`是`int`的大哥。**它存储在 64 位内存**中，因此它可以容纳一组更大的可能值。

long 的可能值介于-9，223，372，036，854，775，808 (-2 ^(63) )到 9，223，372，036，854，775，807(2^(63)–1)之间。

我们可以简单地声明一个:

[PRE3]

与其他整数类型一样，默认值也是 0。我们可以在`long`上使用所有在`int`上有效的算法。

### 2.5.`float`

我们在 Java 中使用`float`类型来表示基本的分数。这是一个单精度十进制数。这意味着，如果我们超过了小数点后六位，这个数字就会变得不那么精确，更像是一个估计值。

大多数情况下，我们不在乎精度损失。但是如果我们的计算需要绝对的精度(比如金融操作，登月等。)，我们需要使用为这项工作设计的特定类型。有关更多信息，请查看 Java 类 [Big Decimal](/web/20221001005356/https://www.baeldung.com/java-bigdecimal-biginteger) 。

**这个类型和`int`一样存储在 32 位内存中。**然而，由于小数点浮动，其范围就大不相同了。它可以代表正数和负数。最小的小数是 1.40239846 x 10 ^(-45) ，最大值是 3.40282347 x 10 ^(38) 。

我们声明`float` s 与任何其他类型相同:

[PRE4]

**并且默认值是 0.0 而不是 0。**另外，请注意，我们在文字数字的末尾添加了`f`标记来定义一个浮点数。否则，Java 会抛出一个错误，因为十进制值的默认类型是`double`。

我们还可以在`float`上执行所有标准的算术运算。然而，需要注意的是，我们执行浮点运算的方式与整数运算非常不同。

### 2.6.`double`

接下来我们来看`double`。它的名字来源于它是一个双精度十进制数。

它存储在 64 位内存中。这意味着它比`float`代表了更大范围的可能数字。

尽管如此，它确实受到与`float`相同的精度限制。范围是 4.9406564584124654 x 10^(-324)到 1.7976931348623157 x 10^(308)。该范围也可以是正的或负的。

声明`double`与其他数值类型相同:

[PRE5]

**与** `**float**` **一样，默认值也是 0.0。**与`float,`相似，我们附上字母`D`来指定字面量为双精度。

### 2.7.`boolean`

最简单的原始数据类型是`boolean`。它只能包含两个值:`true`或`false`。**它将其值存储在一位中。**

然而，为了方便起见，Java 填充了该值，并将其存储在一个字节中。

下面是我们如何声明`boolean`:

[PRE6]

不带值声明默认为`false`。`boolean`是控制我们程序流程的基石。我们可以对它们使用布尔运算符(例如，`and`、 `or`等)。).

### 2.8.`char`

最后要查看的原始数据类型是`char`。

`char` 也称为字符，是代表 Unicode 编码字符的 16 位整数。其范围是从 0 到 65，535。在 Unicode 中，这表示从`‘\u0000'`到`‘\uffff'`。

有关所有可能的 Unicode 值的列表，请查看网站，如 [Unicode Table](https://web.archive.org/web/20221001005356/https://unicode-table.com/en/) 。

现在让我们宣布一个`char`:

[PRE7]

在定义变量时，我们可以使用任何字符文字，它们会自动转换成 Unicode 编码。一个角色的默认值是`‘/u0000'`。

### 2.9.泛滥

原始数据类型有大小限制。但是，如果我们试图存储一个大于最大值的值，会发生什么呢？

**我们遇到了一种叫做`overflow`的情况。**

当一个整数溢出时，它翻转到最小值，并从那里开始向上计数。

浮点数因返回无穷大而溢出:

[PRE8]

`Underflow`是相同的问题，除了它涉及存储一个小于最小值的值。当数字下溢时，它们返回 0.0。

### 2.10.自动装箱

每种原始数据类型都有一个完整的 Java 类实现来包装它。例如，`Integer`类可以包装一个`int`。有时需要从原始类型转换到它的对象包装器(例如，通过[泛型](/web/20221001005356/https://www.baeldung.com/java-generics)使用它们)。

幸运的是，Java 可以自动为我们执行这种转换，这个过程叫做`Autoboxing`:

[PRE9]

## 3.结论

在本文中，我们介绍了 Java 支持的八种原始数据类型。

这些是大多数 Java 程序(如果不是全部的话)使用的构件，所以理解它们是如何工作的是很有价值的。