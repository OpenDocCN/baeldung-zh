["```\r\n8 . . . . . . . . \r\n. . 3 6 . . . . . \r\n. 7 . . 9 . 2 . . \r\n. 5 . . . 7 . . . \r\n. . . . 4 5 7 . . \r\n. . . 1 . . . 3 . \r\n. . 1 . . . . 6 8 \r\n. . 8 5 . . . 1 . \r\n. 9 . . . . 4 . .\r\n```","```\r\n8 1 2 7 5 3 6 4 9 \r\n9 4 3 6 8 2 1 7 5 \r\n6 7 5 4 9 1 2 8 3 \r\n1 5 4 2 3 7 8 9 6 \r\n3 6 9 8 4 5 7 2 1 \r\n2 8 7 1 6 9 5 3 4 \r\n5 2 1 9 7 4 3 6 8 \r\n4 3 8 5 2 6 9 1 7 \r\n7 9 6 3 1 8 4 5 2\r\n```","```\r\nint[][] board = {\r\n  { 8, 0, 0, 0, 0, 0, 0, 0, 0 },\r\n  { 0, 0, 3, 6, 0, 0, 0, 0, 0 },\r\n  { 0, 7, 0, 0, 9, 0, 2, 0, 0 },\r\n  { 0, 5, 0, 0, 0, 7, 0, 0, 0 },\r\n  { 0, 0, 0, 0, 4, 5, 7, 0, 0 },\r\n  { 0, 0, 0, 1, 0, 0, 0, 3, 0 },\r\n  { 0, 0, 1, 0, 0, 0, 0, 6, 8 },\r\n  { 0, 0, 8, 5, 0, 0, 0, 1, 0 },\r\n  { 0, 9, 0, 0, 0, 0, 4, 0, 0 } \r\n};\r\n```","```\r\nprivate boolean solve(int[][] board) {\r\n    for (int row = BOARD_START_INDEX; row < BOARD_SIZE; row++) {\r\n        for (int column = BOARD_START_INDEX; column < BOARD_SIZE; column++) {\r\n            if (board[row][column] == NO_VALUE) {\r\n                for (int k = MIN_VALUE; k <= MAX_VALUE; k++) {\r\n                    board[row][column] = k;\r\n                    if (isValid(board, row, column) && solve(board)) {\r\n                        return true;\r\n                    }\r\n                    board[row][column] = NO_VALUE;\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n```","```\r\nprivate boolean isValid(int[][] board, int row, int column) {\r\n    return (rowConstraint(board, row)\r\n      && columnConstraint(board, column) \r\n      && subsectionConstraint(board, row, column));\r\n}\r\n```","```\r\nprivate boolean rowConstraint(int[][] board, int row) {\r\n    boolean[] constraint = new boolean[BOARD_SIZE];\r\n    return IntStream.range(BOARD_START_INDEX, BOARD_SIZE)\r\n      .allMatch(column -> checkConstraint(board, row, constraint, column));\r\n}\r\n```","```\r\nprivate boolean columnConstraint(int[][] board, int column) {\r\n    boolean[] constraint = new boolean[BOARD_SIZE];\r\n    return IntStream.range(BOARD_START_INDEX, BOARD_SIZE)\r\n      .allMatch(row -> checkConstraint(board, row, constraint, column));\r\n}\r\n```","```\r\nprivate boolean subsectionConstraint(int[][] board, int row, int column) {\r\n    boolean[] constraint = new boolean[BOARD_SIZE];\r\n    int subsectionRowStart = (row / SUBSECTION_SIZE) * SUBSECTION_SIZE;\r\n    int subsectionRowEnd = subsectionRowStart + SUBSECTION_SIZE;\r\n\r\n    int subsectionColumnStart = (column / SUBSECTION_SIZE) * SUBSECTION_SIZE;\r\n    int subsectionColumnEnd = subsectionColumnStart + SUBSECTION_SIZE;\r\n\r\n    for (int r = subsectionRowStart; r < subsectionRowEnd; r++) {\r\n        for (int c = subsectionColumnStart; c < subsectionColumnEnd; c++) {\r\n            if (!checkConstraint(board, r, constraint, c)) return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n```","```\r\nboolean checkConstraint(\r\n  int[][] board, \r\n  int row, \r\n  boolean[] constraint, \r\n  int column) {\r\n    if (board[row][column] != NO_VALUE) {\r\n        if (!constraint[board[row][column] - 1]) {\r\n            constraint[board[row][column] - 1] = true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n```","```\r\nprivate void printBoard() {\r\n    for (int row = BOARD_START_INDEX; row < BOARD_SIZE; row++) {\r\n        for (int column = BOARD_START_INDEX; column < BOARD_SIZE; column++) {\r\n            System.out.print(board[row][column] + \" \");\r\n        }\r\n        System.out.println();\r\n    }\r\n}\r\n```","```\r\n | 1 | 2 | 3 | 4 | 5 | 6 | 7 | \r\nA | 1 | 0 | 0 | 1 | 0 | 0 | 1 |\r\nB | 1 | 0 | 0 | 1 | 0 | 0 | 0 |\r\nC | 0 | 0 | 0 | 1 | 1 | 0 | 1 |\r\nD | 0 | 0 | 1 | 0 | 1 | 1 | 0 |\r\nE | 0 | 1 | 1 | 0 | 0 | 1 | 1 |\r\nF | 0 | 1 | 0 | 0 | 0 | 0 | 1 |\r\n```","```\r\n | 1 | 2 | 3 | 4 | 5 | 6 | 7 | \r\nB | 1 | 0 | 0 | 1 | 0 | 0 | 0 |\r\nD | 0 | 0 | 1 | 0 | 1 | 1 | 0 |\r\nF | 0 | 1 | 0 | 0 | 0 | 0 | 1 |\r\n```","```\r\nprivate static int BOARD_SIZE = 9;\r\nprivate static int SUBSECTION_SIZE = 3;\r\nprivate static int NO_VALUE = 0;\r\nprivate static int CONSTRAINTS = 4;\r\nprivate static int MIN_VALUE = 1;\r\nprivate static int MAX_VALUE = 9;\r\nprivate static int COVER_START_INDEX = 1;\r\n```","```\r\nprivate int getIndex(int row, int column, int num) {\r\n    return (row - 1) * BOARD_SIZE * BOARD_SIZE \r\n      + (column - 1) * BOARD_SIZE + (num - 1);\r\n}\r\n```","```\r\nprivate boolean[][] createExactCoverBoard() {\r\n    boolean[][] coverBoard = new boolean\r\n      [BOARD_SIZE * BOARD_SIZE * MAX_VALUE]\r\n      [BOARD_SIZE * BOARD_SIZE * CONSTRAINTS];\r\n\r\n    int hBase = 0;\r\n    hBase = checkCellConstraint(coverBoard, hBase);\r\n    hBase = checkRowConstraint(coverBoard, hBase);\r\n    hBase = checkColumnConstraint(coverBoard, hBase);\r\n    checkSubsectionConstraint(coverBoard, hBase);\r\n\r\n    return coverBoard;\r\n}\r\n\r\nprivate int checkSubsectionConstraint(boolean[][] coverBoard, int hBase) {\r\n    for (int row = COVER_START_INDEX; row <= BOARD_SIZE; row += SUBSECTION_SIZE) {\r\n        for (int column = COVER_START_INDEX; column <= BOARD_SIZE; column += SUBSECTION_SIZE) {\r\n            for (int n = COVER_START_INDEX; n <= BOARD_SIZE; n++, hBase++) {\r\n                for (int rowDelta = 0; rowDelta < SUBSECTION_SIZE; rowDelta++) {\r\n                    for (int columnDelta = 0; columnDelta < SUBSECTION_SIZE; columnDelta++) {\r\n                        int index = getIndex(row + rowDelta, column + columnDelta, n);\r\n                        coverBoard[index][hBase] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return hBase;\r\n}\r\n\r\nprivate int checkColumnConstraint(boolean[][] coverBoard, int hBase) {\r\n    for (int column = COVER_START_INDEX; column <= BOARD_SIZE; c++) {\r\n        for (int n = COVER_START_INDEX; n <= BOARD_SIZE; n++, hBase++) {\r\n            for (int row = COVER_START_INDEX; row <= BOARD_SIZE; row++) {\r\n                int index = getIndex(row, column, n);\r\n                coverBoard[index][hBase] = true;\r\n            }\r\n        }\r\n    }\r\n    return hBase;\r\n}\r\n\r\nprivate int checkRowConstraint(boolean[][] coverBoard, int hBase) {\r\n    for (int row = COVER_START_INDEX; row <= BOARD_SIZE; r++) {\r\n        for (int n = COVER_START_INDEX; n <= BOARD_SIZE; n++, hBase++) {\r\n            for (int column = COVER_START_INDEX; column <= BOARD_SIZE; column++) {\r\n                int index = getIndex(row, column, n);\r\n                coverBoard[index][hBase] = true;\r\n            }\r\n        }\r\n    }\r\n    return hBase;\r\n}\r\n\r\nprivate int checkCellConstraint(boolean[][] coverBoard, int hBase) {\r\n    for (int row = COVER_START_INDEX; row <= BOARD_SIZE; row++) {\r\n        for (int column = COVER_START_INDEX; column <= BOARD_SIZE; column++, hBase++) {\r\n            for (int n = COVER_START_INDEX; n <= BOARD_SIZE; n++) {\r\n                int index = getIndex(row, column, n);\r\n                coverBoard[index][hBase] = true;\r\n            }\r\n        }\r\n    }\r\n    return hBase;\r\n}\r\n```","```\r\nprivate boolean[][] initializeExactCoverBoard(int[][] board) {\r\n    boolean[][] coverBoard = createExactCoverBoard();\r\n    for (int row = COVER_START_INDEX; row <= BOARD_SIZE; row++) {\r\n        for (int column = COVER_START_INDEX; column <= BOARD_SIZE; column++) {\r\n            int n = board[row - 1][column - 1];\r\n            if (n != NO_VALUE) {\r\n                for (int num = MIN_VALUE; num <= MAX_VALUE; num++) {\r\n                    if (num != n) {\r\n                        Arrays.fill(coverBoard[getIndex(row, column, num)], false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return coverBoard;\r\n}\r\n```","```\r\nnode.prev.next = node.next\r\nnode.next.prev = node.prev\r\n```","```\r\nnode.prev = node\r\nnode.next = node\r\n```","```\r\nclass DancingNode {\r\n    DancingNode L, R, U, D;\r\n    ColumnNode C;\r\n\r\n    DancingNode hookDown(DancingNode node) {\r\n        assert (this.C == node.C);\r\n        node.D = this.D;\r\n        node.D.U = node;\r\n        node.U = this;\r\n        this.D = node;\r\n        return node;\r\n    }\r\n\r\n    DancingNode hookRight(DancingNode node) {\r\n        node.R = this.R;\r\n        node.R.L = node;\r\n        node.L = this;\r\n        this.R = node;\r\n        return node;\r\n    }\r\n\r\n    void unlinkLR() {\r\n        this.L.R = this.R;\r\n        this.R.L = this.L;\r\n    }\r\n\r\n    void relinkLR() {\r\n        this.L.R = this.R.L = this;\r\n    }\r\n\r\n    void unlinkUD() {\r\n        this.U.D = this.D;\r\n        this.D.U = this.U;\r\n    }\r\n\r\n    void relinkUD() {\r\n        this.U.D = this.D.U = this;\r\n    }\r\n\r\n    DancingNode() {\r\n        L = R = U = D = this;\r\n    }\r\n\r\n    DancingNode(ColumnNode c) {\r\n        this();\r\n        C = c;\r\n    }\r\n}\r\n```","```\r\nclass ColumnNode extends DancingNode {\r\n    int size;\r\n    String name;\r\n\r\n    ColumnNode(String n) {\r\n        super();\r\n        size = 0;\r\n        name = n;\r\n        C = this;\r\n    }\r\n\r\n    void cover() {\r\n        unlinkLR();\r\n        for (DancingNode i = this.D; i != this; i = i.D) {\r\n            for (DancingNode j = i.R; j != i; j = j.R) {\r\n                j.unlinkUD();\r\n                j.C.size--;\r\n            }\r\n        }\r\n    }\r\n\r\n    void uncover() {\r\n        for (DancingNode i = this.U; i != this; i = i.U) {\r\n            for (DancingNode j = i.L; j != i; j = j.L) {\r\n                j.C.size++;\r\n                j.relinkUD();\r\n            }\r\n        }\r\n        relinkLR();\r\n    }\r\n}\r\n```","```\r\nprivate ColumnNode makeDLXBoard(boolean[][] grid) {\r\n    int COLS = grid[0].length;\r\n\r\n    ColumnNode headerNode = new ColumnNode(\"header\");\r\n    List<ColumnNode> columnNodes = new ArrayList<>();\r\n\r\n    for (int i = 0; i < COLS; i++) {\r\n        ColumnNode n = new ColumnNode(Integer.toString(i));\r\n        columnNodes.add(n);\r\n        headerNode = (ColumnNode) headerNode.hookRight(n);\r\n    }\r\n    headerNode = headerNode.R.C;\r\n\r\n    for (boolean[] aGrid : grid) {\r\n        DancingNode prev = null;\r\n        for (int j = 0; j < COLS; j++) {\r\n            if (aGrid[j]) {\r\n                ColumnNode col = columnNodes.get(j);\r\n                DancingNode newNode = new DancingNode(col);\r\n                if (prev == null) prev = newNode;\r\n                col.U.hookDown(newNode);\r\n                prev = prev.hookRight(newNode);\r\n                col.size++;\r\n            }\r\n        }\r\n    }\r\n\r\n    headerNode.size = COLS;\r\n\r\n    return headerNode;\r\n}\r\n```","```\r\nprivate ColumnNode selectColumnNodeHeuristic() {\r\n    int min = Integer.MAX_VALUE;\r\n    ColumnNode ret = null;\r\n    for (\r\n      ColumnNode c = (ColumnNode) header.R; \r\n      c != header; \r\n      c = (ColumnNode) c.R) {\r\n        if (c.size < min) {\r\n            min = c.size;\r\n            ret = c;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n```","```\r\nprivate void search(int k) {\r\n    if (header.R == header) {\r\n        handleSolution(answer);\r\n    } else {\r\n        ColumnNode c = selectColumnNodeHeuristic();\r\n        c.cover();\r\n\r\n        for (DancingNode r = c.D; r != c; r = r.D) {\r\n            answer.add(r);\r\n\r\n            for (DancingNode j = r.R; j != r; j = j.R) {\r\n                j.C.cover();\r\n            }\r\n\r\n            search(k + 1);\r\n\r\n            r = answer.remove(answer.size() - 1);\r\n            c = r.C;\r\n\r\n            for (DancingNode j = r.L; j != r; j = j.L) {\r\n                j.C.uncover();\r\n            }\r\n        }\r\n        c.uncover();\r\n    }\r\n}\r\n```"]