["```\r\nLock lock = ...; \r\nlock.lock();\r\ntry {\r\n    // access to the shared resource\r\n} finally {\r\n    lock.unlock();\r\n}\r\n```","```\r\npublic class SharedObject {\r\n    //...\r\n    ReentrantLock lock = new ReentrantLock();\r\n    int counter = 0;\r\n\r\n    public void perform() {\r\n        lock.lock();\r\n        try {\r\n            // Critical section here\r\n            count++;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    //...\r\n}\r\n```","```\r\npublic void performTryLock(){\r\n    //...\r\n    boolean isLockAcquired = lock.tryLock(1, TimeUnit.SECONDS);\r\n\r\n    if(isLockAcquired) {\r\n        try {\r\n            //Critical section here\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    //...\r\n} \r\n```","```\r\npublic class SynchronizedHashMapWithReadWriteLock {\r\n\r\n    Map<String,String> syncHashMap = new HashMap<>();\r\n    ReadWriteLock lock = new ReentrantReadWriteLock();\r\n    // ...\r\n    Lock writeLock = lock.writeLock();\r\n\r\n    public void put(String key, String value) {\r\n        try {\r\n            writeLock.lock();\r\n            syncHashMap.put(key, value);\r\n        } finally {\r\n            writeLock.unlock();\r\n        }\r\n    }\r\n    ...\r\n    public String remove(String key){\r\n        try {\r\n            writeLock.lock();\r\n            return syncHashMap.remove(key);\r\n        } finally {\r\n            writeLock.unlock();\r\n        }\r\n    }\r\n    //...\r\n}\r\n```","```\r\nLock readLock = lock.readLock();\r\n//...\r\npublic String get(String key){\r\n    try {\r\n        readLock.lock();\r\n        return syncHashMap.get(key);\r\n    } finally {\r\n        readLock.unlock();\r\n    }\r\n}\r\n\r\npublic boolean containsKey(String key) {\r\n    try {\r\n        readLock.lock();\r\n        return syncHashMap.containsKey(key);\r\n    } finally {\r\n        readLock.unlock();\r\n    }\r\n}\r\n```","```\r\npublic class StampedLockDemo {\r\n    Map<String,String> map = new HashMap<>();\r\n    private StampedLock lock = new StampedLock();\r\n\r\n    public void put(String key, String value){\r\n        long stamp = lock.writeLock();\r\n        try {\r\n            map.put(key, value);\r\n        } finally {\r\n            lock.unlockWrite(stamp);\r\n        }\r\n    }\r\n\r\n    public String get(String key) throws InterruptedException {\r\n        long stamp = lock.readLock();\r\n        try {\r\n            return map.get(key);\r\n        } finally {\r\n            lock.unlockRead(stamp);\r\n        }\r\n    }\r\n}\r\n```","```\r\npublic String readWithOptimisticLock(String key) {\r\n    long stamp = lock.tryOptimisticRead();\r\n    String value = map.get(key);\r\n\r\n    if(!lock.validate(stamp)) {\r\n        stamp = lock.readLock();\r\n        try {\r\n            return map.get(key);\r\n        } finally {\r\n            lock.unlock(stamp);               \r\n        }\r\n    }\r\n    return value;\r\n}\r\n```","```\r\npublic class ReentrantLockWithCondition {\r\n\r\n    Stack<String> stack = new Stack<>();\r\n    int CAPACITY = 5;\r\n\r\n    ReentrantLock lock = new ReentrantLock();\r\n    Condition stackEmptyCondition = lock.newCondition();\r\n    Condition stackFullCondition = lock.newCondition();\r\n\r\n    public void pushToStack(String item){\r\n        try {\r\n            lock.lock();\r\n            while(stack.size() == CAPACITY) {\r\n                stackFullCondition.await();\r\n            }\r\n            stack.push(item);\r\n            stackEmptyCondition.signalAll();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public String popFromStack() {\r\n        try {\r\n            lock.lock();\r\n            while(stack.size() == 0) {\r\n                stackEmptyCondition.await();\r\n            }\r\n            return stack.pop();\r\n        } finally {\r\n            stackFullCondition.signalAll();\r\n            lock.unlock();\r\n        }\r\n    }\r\n}\r\n```"]