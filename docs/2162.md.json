["```\r\n@Data\r\npublic class City {\r\n\r\n    private int x;\r\n    private int y;\r\n\r\n    public City() {\r\n        this.x = (int) (Math.random() * 500);\r\n        this.y = (int) (Math.random() * 500);\r\n    }\r\n\r\n    public double distanceToCity(City city) {\r\n        int x = Math.abs(getX() - city.getX());\r\n        int y = Math.abs(getY() - city.getY());\r\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n    }\r\n\r\n}\r\n```","```\r\npublic void generateInitialTravel() {\r\n    if (travel.isEmpty()) {\r\n        new Travel(10);\r\n    }\r\n    Collections.shuffle(travel);\r\n}\r\n```","```\r\npublic void swapCities() {\r\n    int a = generateRandomIndex();\r\n    int b = generateRandomIndex();\r\n    previousTravel = new ArrayList<>(travel);\r\n    City x = travel.get(a);\r\n    City y = travel.get(b);\r\n    travel.set(a, y);\r\n    travel.set(b, x);\r\n}\r\n```","```\r\npublic void revertSwap() {\r\n    travel = previousTravel;\r\n}\r\n```","```\r\npublic int getDistance() {\r\n    int distance = 0;\r\n    for (int index = 0; index < travel.size(); index++) {\r\n        City starting = getCity(index);\r\n        City destination;\r\n        if (index + 1 < travel.size()) {\r\n            destination = getCity(index + 1);\r\n        } else {\r\n            destination = getCity(0);\r\n        }\r\n            distance += starting.distanceToCity(destination);\r\n    }\r\n    return distance;\r\n}\r\n```","```\r\npublic double simulateAnnealing(double startingTemperature,\r\n  int numberOfIterations, double coolingRate) {\r\n    double t = startingTemperature;\r\n    travel.generateInitialTravel();\r\n    double bestDistance = travel.getDistance();\r\n\r\n    Travel currentSolution = travel;\r\n    // ...\r\n}\r\n```","```\r\nfor (int i = 0; i < numberOfIterations; i++) {\r\n    if (t > 0.1) {\r\n        //...\r\n    } else {\r\n        continue;\r\n    }\r\n}\r\n```","```\r\ncurrentSolution.swapCities();\r\ndouble currentDistance = currentSolution.getDistance();\r\nif (currentDistance < bestDistance) {\r\n    bestDistance = currentDistance;\r\n} else if (Math.exp((bestDistance - currentDistance) / t) < Math.random()) {\r\n    currentSolution.revertSwap();\r\n}\r\n```","```\r\nt *= coolingRate;\r\n```"]