["```\r\n 1        2      3        4        5        6         7         8        9       10\r\n ()       ()     ()       ()       ()       ()        ()        ()       ()       ()\r\n         /         \\     /  \\     /  \\     /  \\      /  \\      /        /        /  \\\r\n        ()         ()   ()  ()   ()  ()   ()  ()    ()  ()    ()       ()       ()  ()\r\n                                /          \\       /  \\      /  \\     /        /  \\\r\n                               ()          ()     ()  ()    ()  ()   ()       ()  ()\r\n                                                                             /\r\n                                                                            ()\r\n```","```\r\n 2\r\n       / \\\r\n      /   \\\r\n     3     6\r\n    / \\\r\n   5   7\r\n```","```\r\n 2\r\n       / \\\r\n      /   \\\r\n     3     6\r\n    / \\   /\r\n   5   7 4\r\n```","```\r\n 2\r\n       / \\\r\n      /   \\\r\n     3     4\r\n    / \\   /\r\n   5   7 6\r\n```","```\r\n 2\r\n       / \\\r\n      /   \\\r\n     3     4\r\n    / \\   / \\\r\n   5   7 6   1\r\n```","```\r\n 2\r\n       / \\\r\n      /   \\\r\n     3     1\r\n    / \\   / \\\r\n   5   7 6   4\r\n```","```\r\n 1\r\n       / \\\r\n      /   \\\r\n     3     2\r\n    / \\   / \\\r\n   5   7 6   4\r\n```","```\r\n 0\r\n       / \\\r\n      /   \\\r\n     1     2\r\n    / \\   /\r\n   3   4 5\r\n```","```\r\nclass BinaryTree<E> {\r\n\r\n    List<E> elements = new ArrayList<>();\r\n\r\n    void add(E e) {\r\n        elements.add(e);\r\n    }\r\n\r\n    boolean isEmpty() {\r\n        return elements.isEmpty();\r\n    }\r\n\r\n    E elementAt(int index) {\r\n        return elements.get(index);\r\n    }\r\n\r\n    int parentIndex(int index) {\r\n        return (index - 1) / 2;\r\n    }\r\n\r\n    int leftChildIndex(int index) {\r\n        return 2 * index + 1;\r\n    }\r\n\r\n    int rightChildIndex(int index) {\r\n        return 2 * index + 2;\r\n    }\r\n\r\n}\r\n```","```\r\nclass Heap<E extends Comparable<E>> {\r\n\r\n    // ...\r\n\r\n    void add(E e) {\r\n        elements.add(e);\r\n        int elementIndex = elements.size() - 1;\r\n        while (!isRoot(elementIndex) && !isCorrectChild(elementIndex)) {\r\n            int parentIndex = parentIndex(elementIndex);\r\n            swap(elementIndex, parentIndex);\r\n            elementIndex = parentIndex;\r\n        }\r\n    }\r\n\r\n    boolean isRoot(int index) {\r\n        return index == 0;\r\n    }\r\n\r\n    boolean isCorrectChild(int index) {\r\n        return isCorrect(parentIndex(index), index);\r\n    }\r\n\r\n    boolean isCorrect(int parentIndex, int childIndex) {\r\n        if (!isValidIndex(parentIndex) || !isValidIndex(childIndex)) {\r\n            return true;\r\n        }\r\n\r\n        return elementAt(parentIndex).compareTo(elementAt(childIndex)) < 0;\r\n    }\r\n\r\n    boolean isValidIndex(int index) {\r\n        return index < elements.size();\r\n    }\r\n\r\n    void swap(int index1, int index2) {\r\n        E element1 = elementAt(index1);\r\n        E element2 = elementAt(index2);\r\n        elements.set(index1, element2);\r\n        elements.set(index2, element1);\r\n    }\r\n\r\n    // ...\r\n\r\n}\r\n```","```\r\n 1\r\n       / \\\r\n      /   \\\r\n     3     2\r\n    / \\   / \\\r\n   5   7 6   4\r\n```","```\r\n 4\r\n       / \\\r\n      /   \\\r\n     3     2\r\n    / \\   /\r\n   5   7 6\r\n```","```\r\n 2\r\n       / \\\r\n      /   \\\r\n     3     4\r\n    / \\   /\r\n   5   7 6\r\n```","```\r\nclass Heap<E extends Comparable<E>> {\r\n\r\n    // ...\r\n\r\n    E pop() {\r\n        if (isEmpty()) {\r\n            throw new IllegalStateException(\"You cannot pop from an empty heap\");\r\n        }\r\n\r\n        E result = elementAt(0);\r\n\r\n        int lasElementIndex = elements.size() - 1;\r\n        swap(0, lasElementIndex);\r\n        elements.remove(lasElementIndex);\r\n\r\n        int elementIndex = 0;\r\n        while (!isLeaf(elementIndex) && !isCorrectParent(elementIndex)) {\r\n            int smallerChildIndex = smallerChildIndex(elementIndex);\r\n            swap(elementIndex, smallerChildIndex);\r\n            elementIndex = smallerChildIndex;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    boolean isLeaf(int index) {\r\n        return !isValidIndex(leftChildIndex(index));\r\n    }\r\n\r\n    boolean isCorrectParent(int index) {\r\n        return isCorrect(index, leftChildIndex(index)) && isCorrect(index, rightChildIndex(index));\r\n    }\r\n\r\n    int smallerChildIndex(int index) {\r\n        int leftChildIndex = leftChildIndex(index);\r\n        int rightChildIndex = rightChildIndex(index);\r\n\r\n        if (!isValidIndex(rightChildIndex)) {\r\n            return leftChildIndex;\r\n        }\r\n\r\n        if (elementAt(leftChildIndex).compareTo(elementAt(rightChildIndex)) < 0) {\r\n            return leftChildIndex;\r\n        }\r\n\r\n        return rightChildIndex;\r\n    }\r\n\r\n    // ...\r\n\r\n}\r\n```","```\r\nclass Heap<E extends Comparable<E>> {\r\n\r\n    // ...\r\n\r\n    static <E extends Comparable<E>> List<E> sort(Iterable<E> elements) {\r\n        Heap<E> heap = of(elements);\r\n\r\n        List<E> result = new ArrayList<>();\r\n\r\n        while (!heap.isEmpty()) {\r\n            result.add(heap.pop());\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    static <E extends Comparable<E>> Heap<E> of(Iterable<E> elements) {\r\n        Heap<E> result = new Heap<>();\r\n        for (E element : elements) {\r\n            result.add(element);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // ...\r\n\r\n}\r\n```","```\r\n@Test\r\nvoid givenNotEmptyIterable_whenSortCalled_thenItShouldReturnElementsInSortedList() {\r\n    // given\r\n    List<Integer> elements = Arrays.asList(3, 5, 1, 4, 2);\r\n\r\n    // when\r\n    List<Integer> sortedElements = Heap.sort(elements);\r\n\r\n    // then\r\n    assertThat(sortedElements).isEqualTo(Arrays.asList(1, 2, 3, 4, 5));\r\n}\r\n```"]