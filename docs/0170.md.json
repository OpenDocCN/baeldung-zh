["```\r\npublic class ConcurrentHashMapUnitTest {\r\n\r\n    private Map<Integer, Integer> frequencyMap;\r\n\r\n    @BeforeEach\r\n    public void setup() {\r\n        frequencyMap = new ConcurrentHashMap<>();\r\n        frequencyMap.put(0, 0);\r\n        frequencyMap.put(1, 0);\r\n        frequencyMap.put(2, 0);\r\n    }\r\n\r\n    @AfterEach\r\n    public void teardown() {\r\n        frequencyMap.clear();\r\n    }\r\n\r\n    private static void sleep(int timeout) {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(timeout);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenOneThreadIsWriting_whenAnotherThreadReads_thenGetCorrectValue() throws Exception {\r\n    ExecutorService threadExecutor = Executors.newFixedThreadPool(3);\r\n\r\n    Runnable writeAfter1Sec = () -> frequencyMap.computeIfPresent(1, (k, v) -> {\r\n        sleep(1);\r\n        return frequencyMap.get(k) + 1;\r\n    });\r\n\r\n    Callable<Integer> readNow = () -> frequencyMap.get(1);\r\n    Callable<Integer> readAfter1001Ms = () -> {\r\n        TimeUnit.MILLISECONDS.sleep(1001);\r\n        return frequencyMap.get(1);\r\n    };\r\n\r\n    threadExecutor.submit(writeAfter1Sec);\r\n    List<Future<Integer>> results = threadExecutor.invokeAll(asList(readNow, readAfter1001Ms));\r\n\r\n    assertEquals(0, results.get(0).get());\r\n    assertEquals(1, results.get(1).get());\r\n\r\n    if (threadExecutor.awaitTermination(2, TimeUnit.SECONDS)) {\r\n        threadExecutor.shutdown();\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenOneThreadIsWriting_whenAnotherThreadWritesAtSameKey_thenWaitAndGetCorrectValue() throws Exception {\r\n    ExecutorService threadExecutor = Executors.newFixedThreadPool(2);\r\n\r\n    Callable<Integer> writeAfter5Sec = () -> frequencyMap.computeIfPresent(1, (k, v) -> {\r\n        sleep(5);\r\n        return frequencyMap.get(k) + 1;\r\n    });\r\n\r\n    Callable<Integer> writeAfter1Sec = () -> frequencyMap.computeIfPresent(1, (k, v) -> {\r\n        sleep(1);\r\n        return frequencyMap.get(k) + 1;\r\n    });\r\n\r\n    List<Future<Integer>> results = threadExecutor.invokeAll(asList(writeAfter5Sec, writeAfter1Sec));\r\n\r\n    assertEquals(1, results.get(0).get());\r\n    assertEquals(2, results.get(1).get());\r\n\r\n    if (threadExecutor.awaitTermination(2, TimeUnit.SECONDS)) {\r\n        threadExecutor.shutdown();\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenOneThreadIsWriting_whenAnotherThreadWritesAtDifferentKey_thenNotWaitAndGetCorrectValue() throws Exception {\r\n    ExecutorService threadExecutor = Executors.newFixedThreadPool(2);\r\n\r\n    Callable<Integer> writeAfter5Sec = () -> frequencyMap.computeIfPresent(1, (k, v) -> {\r\n        sleep(5);\r\n        return frequencyMap.get(k) + 1;\r\n    });\r\n\r\n    AtomicLong time = new AtomicLong(System.currentTimeMillis());\r\n    Callable<Integer> writeAfter1Sec = () -> frequencyMap.computeIfPresent(2, (k, v) -> {\r\n        sleep(1);\r\n        time.set((System.currentTimeMillis() - time.get()) / 1000);\r\n        return frequencyMap.get(k) + 1;\r\n    });\r\n\r\n    threadExecutor.invokeAll(asList(writeAfter5Sec, writeAfter1Sec));\r\n\r\n    assertEquals(1, time.get());\r\n\r\n    if (threadExecutor.awaitTermination(2, TimeUnit.SECONDS)) {\r\n        threadExecutor.shutdown();\r\n    }\r\n}\r\n```"]