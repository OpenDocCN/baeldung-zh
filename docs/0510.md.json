["```\r\nPattern:   NA\r\nText:      HAVANABANANA\r\nMatch1:    ----NA------\r\nMatch2:    --------NA--\r\nMatch3:    ----------NA\r\n```","```\r\npublic class Node {\r\n    private String text;\r\n    private List<Node> children;\r\n    private int position;\r\n\r\n    public Node(String word, int position) {\r\n        this.text = word;\r\n        this.position = position;\r\n        this.children = new ArrayList<>();\r\n    }\r\n\r\n    // getters, setters, toString()\r\n}\r\n```","```\r\npublic class SuffixTree {\r\n    private static final String WORD_TERMINATION = \"$\";\r\n    private static final int POSITION_UNDEFINED = -1;\r\n    private Node root;\r\n    private String fullText;\r\n\r\n    public SuffixTree(String text) {\r\n        root = new Node(\"\", POSITION_UNDEFINED);\r\n        fullText = text;\r\n    }\r\n}\r\n```","```\r\nprivate void addChildNode(Node parentNode, String text, int index) {\r\n    parentNode.getChildren().add(new Node(text, index));\r\n}\r\n```","```\r\nprivate String getLongestCommonPrefix(String str1, String str2) {\r\n    int compareLength = Math.min(str1.length(), str2.length());\r\n    for (int i = 0; i < compareLength; i++) {\r\n        if (str1.charAt(i) != str2.charAt(i)) {\r\n            return str1.substring(0, i);\r\n        }\r\n    }\r\n    return str1.substring(0, compareLength);\r\n}\r\n```","```\r\nprivate void splitNodeToParentAndChild(Node parentNode, String parentNewText, String childNewText) {\r\n    Node childNode = new Node(childNewText, parentNode.getPosition());\r\n\r\n    if (parentNode.getChildren().size() > 0) {\r\n        while (parentNode.getChildren().size() > 0) {\r\n            childNode.getChildren()\r\n              .add(parentNode.getChildren().remove(0));\r\n        }\r\n    }\r\n\r\n    parentNode.getChildren().add(childNode);\r\n    parentNode.setText(parentNewText);\r\n    parentNode.setPosition(POSITION_UNDEFINED);\r\n}\r\n```","```\r\nList<Node> getAllNodesInTraversePath(String pattern, Node startNode, boolean isAllowPartialMatch) {\r\n    // ...\r\n}\r\n```","```\r\nif (pattern.charAt(0) == nodeText.charAt(0)) {\r\n    // logic to handle remaining characters       \r\n} \r\n```","```\r\nif (isAllowPartialMatch && pattern.length() <= nodeText.length()) {\r\n    nodes.add(currentNode);\r\n    return nodes;\r\n} \r\n```","```\r\nint compareLength = Math.min(nodeText.length(), pattern.length());\r\nfor (int j = 1; j < compareLength; j++) {\r\n    if (pattern.charAt(j) != nodeText.charAt(j)) {\r\n        if (isAllowPartialMatch) {\r\n            nodes.add(currentNode);\r\n        }\r\n        return nodes;\r\n    }\r\n} \r\n```","```\r\nnodes.add(currentNode);\r\n```","```\r\nif (pattern.length() > compareLength) {\r\n    List nodes2 = getAllNodesInTraversePath(pattern.substring(compareLength), currentNode, \r\n      isAllowPartialMatch);\r\n    if (nodes2.size() > 0) {\r\n        nodes.addAll(nodes2);\r\n    } else if (!isAllowPartialMatch) {\r\n        nodes.add(null);\r\n    }\r\n}\r\nreturn nodes;\r\n```","```\r\nprivate List<Node> getAllNodesInTraversePath(String pattern, Node startNode, boolean isAllowPartialMatch) {\r\n    List<Node> nodes = new ArrayList<>();\r\n    for (int i = 0; i < startNode.getChildren().size(); i++) {\r\n        Node currentNode = startNode.getChildren().get(i);\r\n        String nodeText = currentNode.getText();\r\n        if (pattern.charAt(0) == nodeText.charAt(0)) {\r\n            if (isAllowPartialMatch && pattern.length() <= nodeText.length()) {\r\n                nodes.add(currentNode);\r\n                return nodes;\r\n            }\r\n\r\n            int compareLength = Math.min(nodeText.length(), pattern.length());\r\n            for (int j = 1; j < compareLength; j++) {\r\n                if (pattern.charAt(j) != nodeText.charAt(j)) {\r\n                    if (isAllowPartialMatch) {\r\n                        nodes.add(currentNode);\r\n                    }\r\n                    return nodes;\r\n                }\r\n            }\r\n\r\n            nodes.add(currentNode);\r\n            if (pattern.length() > compareLength) {\r\n                List<Node> nodes2 = getAllNodesInTraversePath(pattern.substring(compareLength), \r\n                  currentNode, isAllowPartialMatch);\r\n                if (nodes2.size() > 0) {\r\n                    nodes.addAll(nodes2);\r\n                } else if (!isAllowPartialMatch) {\r\n                    nodes.add(null);\r\n                }\r\n            }\r\n            return nodes;\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n```","```\r\nprivate void addSuffix(String suffix, int position) {\r\n    // ...\r\n}\r\n```","```\r\nList<Node> nodes = getAllNodesInTraversePath(pattern, root, true);\r\nif (nodes.size() == 0) {\r\n    addChildNode(root, suffix, position);\r\n}\r\n```","```\r\nNode lastNode = nodes.remove(nodes.size() - 1);\r\nString newText = suffix;\r\nif (nodes.size() > 0) {\r\n    String existingSuffixUptoLastNode = nodes.stream()\r\n        .map(a -> a.getText())\r\n        .reduce(\"\", String::concat);\r\n    newText = newText.substring(existingSuffixUptoLastNode.length());\r\n}\r\n```","```\r\nprivate void extendNode(Node node, String newText, int position) {\r\n    String currentText = node.getText();\r\n    String commonPrefix = getLongestCommonPrefix(currentText, newText);\r\n\r\n    if (commonPrefix != currentText) {\r\n        String parentText = currentText.substring(0, commonPrefix.length());\r\n        String childText = currentText.substring(commonPrefix.length());\r\n        splitNodeToParentAndChild(node, parentText, childText);\r\n    }\r\n\r\n    String remainingText = newText.substring(commonPrefix.length());\r\n    addChildNode(node, remainingText, position);\r\n}\r\n```","```\r\nprivate void addSuffix(String suffix, int position) {\r\n    List<Node> nodes = getAllNodesInTraversePath(suffix, root, true);\r\n    if (nodes.size() == 0) {\r\n        addChildNode(root, suffix, position);\r\n    } else {\r\n        Node lastNode = nodes.remove(nodes.size() - 1);\r\n        String newText = suffix;\r\n        if (nodes.size() > 0) {\r\n            String existingSuffixUptoLastNode = nodes.stream()\r\n                .map(a -> a.getText())\r\n                .reduce(\"\", String::concat);\r\n            newText = newText.substring(existingSuffixUptoLastNode.length());\r\n        }\r\n        extendNode(lastNode, newText, position);\r\n    }\r\n}\r\n```","```\r\npublic void SuffixTree(String text) {\r\n    root = new Node(\"\", POSITION_UNDEFINED);\r\n    for (int i = 0; i < text.length(); i++) {\r\n        addSuffix(text.substring(i) + WORD_TERMINATION, i);\r\n    }\r\n    fullText = text;\r\n}\r\n```","```\r\npublic List<String> searchText(String pattern) {\r\n    // ...\r\n}\r\n```","```\r\nList<Node> nodes = getAllNodesInTraversePath(pattern, root, false);\r\n```","```\r\nprivate List<Integer> getPositions(Node node) {\r\n    List<Integer> positions = new ArrayList<>();\r\n    if (node.getText().endsWith(WORD_TERMINATION)) {\r\n        positions.add(node.getPosition());\r\n    }\r\n    for (int i = 0; i < node.getChildren().size(); i++) {\r\n        positions.addAll(getPositions(node.getChildren().get(i)));\r\n    }\r\n    return positions;\r\n}\r\n```","```\r\nprivate String markPatternInText(Integer startPosition, String pattern) {\r\n    String matchingTextLHS = fullText.substring(0, startPosition);\r\n    String matchingText = fullText.substring(startPosition, startPosition + pattern.length());\r\n    String matchingTextRHS = fullText.substring(startPosition + pattern.length());\r\n    return matchingTextLHS + \"[\" + matchingText + \"]\" + matchingTextRHS;\r\n}\r\n```","```\r\npublic List<String> searchText(String pattern) {\r\n    List<String> result = new ArrayList<>();\r\n    List<Node> nodes = getAllNodesInTraversePath(pattern, root, false);\r\n\r\n    if (nodes.size() > 0) {\r\n        Node lastNode = nodes.get(nodes.size() - 1);\r\n        if (lastNode != null) {\r\n            List<Integer> positions = getPositions(lastNode);\r\n            positions = positions.stream()\r\n              .sorted()\r\n              .collect(Collectors.toList());\r\n            positions.forEach(m -> result.add((markPatternInText(m, pattern))));\r\n        }\r\n    }\r\n    return result;\r\n}\r\n```","```\r\nSuffixTree suffixTree = new SuffixTree(\"havanabanana\"); \r\n```","```\r\nList<String> matches = suffixTree.searchText(\"a\");\r\nmatches.stream().forEach(m -> LOGGER.debug(m));\r\n```","```\r\nh[a]vanabanana\r\nhav[a]nabanana\r\nhavan[a]banana\r\nhavanab[a]nana\r\nhavanaban[a]na\r\nhavanabanan[a]\r\n```","```\r\nList<String> matches = suffixTree.searchText(\"nab\");\r\nmatches.stream().forEach(m -> LOGGER.debug(m)); \r\n```","```\r\nhava[nab]anana\r\n```","```\r\nList<String> matches = suffixTree.searchText(\"nag\");\r\nmatches.stream().forEach(m -> LOGGER.debug(m));\r\n```"]