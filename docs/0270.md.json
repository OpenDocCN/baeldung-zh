["```\r\n<dependency>\r\n    <groupId>com.google.guava</groupId>\r\n    <artifactId>guava</artifactId>\r\n    <version>31.0.1-jre</version>\r\n</dependency>\r\n```","```\r\npublic abstract class ConcurrentAccessExperiment {\r\n\r\n    public final Map<String,String> doWork(Map<String,String> map, int threads, int slots) {\r\n        CompletableFuture<?>[] requests = new CompletableFuture<?>[threads * slots];\r\n\r\n        for (int i = 0; i < threads; i++) {\r\n            requests[slots * i + 0] = CompletableFuture.supplyAsync(putSupplier(map, i));\r\n            requests[slots * i + 1] = CompletableFuture.supplyAsync(getSupplier(map, i));\r\n            requests[slots * i + 2] = CompletableFuture.supplyAsync(getSupplier(map, i));\r\n            requests[slots * i + 3] = CompletableFuture.supplyAsync(getSupplier(map, i));\r\n        }\r\n        CompletableFuture.allOf(requests).join();\r\n\r\n        return map;\r\n    }\r\n\r\n    protected abstract Supplier<?> putSupplier(Map<String,String> map, int key);\r\n    protected abstract Supplier<?> getSupplier(Map<String,String> map, int key);\r\n}\r\n```","```\r\npublic class SingleLock extends ConcurrentAccessExperiment {\r\n    ReentrantLock lock;\r\n\r\n    public SingleLock() {\r\n        lock = new ReentrantLock();\r\n    }\r\n\r\n    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\r\n        return (()-> {\r\n            lock.lock();\r\n            try {\r\n                return map.put(\"key\" + key, \"value\" + key);\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        });\r\n    }\r\n\r\n    protected Supplier<?> getSupplier(Map<String,String> map, int key) {\r\n        return (()-> {\r\n            lock.lock();\r\n            try {\r\n                return map.get(\"key\" + key);\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        });\r\n    }\r\n}\r\n```","```\r\npublic class StripedLock extends ConcurrentAccessExperiment {\r\n    Striped lock;\r\n\r\n    public StripedLock(int buckets) {\r\n        lock = Striped.lock(buckets);\r\n    }\r\n\r\n    protected Supplier<?> putSupplier(Map<String,String> map, int key) {\r\n        return (()-> {\r\n            int bucket = key % stripedLock.size();\r\n            Lock lock = stripedLock.get(bucket);\r\n            lock.lock();\r\n            try {\r\n                return map.put(\"key\" + key, \"value\" + key);\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        });\r\n    }\r\n\r\n    protected Supplier<?> getSupplier(Map<String,String> map, int key) {\r\n        return (()-> {\r\n            int bucket = key % stripedLock.size();\r\n            Lock lock = stripedLock.get(bucket);\r\n            lock.lock(); \r\n            try {\r\n                return map.get(\"key\" + key);\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        });\r\n    }\r\n}\r\n```","```\r\nBenchmark                                                Mode  Cnt  Score   Error   Units\r\nConcurrentAccessBenchmark.singleLockConcurrentHashMap   thrpt   10  0,059 ± 0,006  ops/ms\r\nConcurrentAccessBenchmark.singleLockHashMap             thrpt   10  0,061 ± 0,005  ops/ms\r\nConcurrentAccessBenchmark.stripedLockConcurrentHashMap  thrpt   10  0,065 ± 0,009  ops/ms\r\nConcurrentAccessBenchmark.stripedLockHashMap            thrpt   10  0,068 ± 0,008  ops/ms \r\n```"]