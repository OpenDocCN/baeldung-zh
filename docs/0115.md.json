["```\r\nstatic <T,K> Collector<T,?,Map<K,List<T>>> \r\n  groupingBy(Function<? super T,? extends K> classifier)\r\n```","```\r\nstatic <T,K,A,D> Collector<T,?,Map<K,D>>\r\n  groupingBy(Function<? super T,? extends K> classifier, \r\n    Collector<? super T,A,D> downstream)\r\n```","```\r\nstatic <T,K,D,A,M extends Map<K,D>> Collector<T,?,M>\r\n  groupingBy(Function<? super T,? extends K> classifier, \r\n    Supplier<M> mapFactory, Collector<? super T,A,D> downstream)\r\n```","```\r\nclass BlogPost {\r\n    String title;\r\n    String author;\r\n    BlogPostType type;\r\n    int likes;\r\n} \r\n```","```\r\nenum BlogPostType {\r\n    NEWS,\r\n    REVIEW,\r\n    GUIDE\r\n} \r\n```","```\r\nList<BlogPost> posts = Arrays.asList( ... );\r\n```","```\r\nclass Tuple {\r\n    BlogPostType type;\r\n    String author;\r\n} \r\n```","```\r\nMap<BlogPostType, List<BlogPost>> postsPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType)); \r\n```","```\r\nMap<Pair<BlogPostType, String>, List<BlogPost>> postsPerTypeAndAuthor = posts.stream()\r\n  .collect(groupingBy(post -> new ImmutablePair<>(post.getType(), post.getAuthor())));\r\n```","```\r\nMap<Tuple, List<BlogPost>> postsPerTypeAndAuthor = posts.stream()\r\n  .collect(groupingBy(post -> new Tuple(post.getType(), post.getAuthor()))); \r\n```","```\r\npublic class BlogPost {\r\n    private String title;\r\n    private String author;\r\n    private BlogPostType type;\r\n    private int likes;\r\n    record AuthPostTypesLikes(String author, BlogPostType type, int likes) {};\r\n\r\n    // constructor, getters/setters\r\n} \r\n```","```\r\nMap<BlogPost.AuthPostTypesLikes, List<BlogPost>> postsPerTypeAndAuthor = posts.stream()\r\n  .collect(groupingBy(post -> new BlogPost.AuthPostTypesLikes(post.getAuthor(), post.getType(), post.getLikes()))); \r\n```","```\r\nMap<BlogPostType, Set<BlogPost>> postsPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType, toSet())); \r\n```","```\r\nMap<String, Map<BlogPostType, List>> map = posts.stream()\r\n  .collect(groupingBy(BlogPost::getAuthor, groupingBy(BlogPost::getType)));\r\n```","```\r\nMap<BlogPostType, Double> averageLikesPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType, averagingInt(BlogPost::getLikes))); \r\n```","```\r\nMap<BlogPostType, Integer> likesPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType, summingInt(BlogPost::getLikes))); \r\n```","```\r\nMap<BlogPostType, Optional<BlogPost>> maxLikesPerPostType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType,\r\n  maxBy(comparingInt(BlogPost::getLikes)))); \r\n```","```\r\nMap<BlogPostType, IntSummaryStatistics> likeStatisticsPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType, \r\n  summarizingInt(BlogPost::getLikes))); \r\n```","```\r\npublic class BlogPost {\r\n    // ...\r\n    record PostCountTitlesLikesStats(long postCount, String titles, IntSummaryStatistics likesStats){};\r\n     // ...\r\n}\r\n```","```\r\nMap<String, BlogPost.PostCountTitlesLikesStats> postsPerAuthor = posts.stream()\r\n  .collect(groupingBy(BlogPost::getAuthor, collectingAndThen(toList(), list -> {\r\n    long count = list.stream()\r\n      .map(BlogPost::getTitle)\r\n      .collect(counting());\r\n    String titles = list.stream()\r\n      .map(BlogPost::getTitle)\r\n      .collect(joining(\" : \"));\r\n    IntSummaryStatistics summary = list.stream()\r\n      .collect(summarizingInt(BlogPost::getLikes));\r\n    return new BlogPost.PostCountTitlesLikesStats(count, titles, summary);\r\n  }))); \r\n```","```\r\nBlogPost.PostCountTitlesLikesStats result = postsPerAuthor.get(\"Author 1\");\r\nassertThat(result.postCount()).isEqualTo(3L);\r\nassertThat(result.titles()).isEqualTo(\"News item 1 : Programming guide : Tech review 2\");\r\nassertThat(result.likesStats().getMax()).isEqualTo(20);\r\nassertThat(result.likesStats().getMin()).isEqualTo(15);\r\nassertThat(result.likesStats().getAverage()).isEqualTo(16.666d, offset(0.001d)); \r\n```","```\r\npublic class BlogPost {\r\n    // ...\r\n    record TitlesBoundedSumOfLikes(String titles, int boundedSumOfLikes) {};\r\n    // ...\r\n} \r\n```","```\r\nint maxValLikes = 17;\r\nMap<String, BlogPost.TitlesBoundedSumOfLikes> postsPerAuthor = posts.stream()\r\n  .collect(toMap(BlogPost::getAuthor, post -> {\r\n    int likes = (post.getLikes() > maxValLikes) ? maxValLikes : post.getLikes();\r\n    return new BlogPost.TitlesBoundedSumOfLikes(post.getTitle(), likes);\r\n  }, (u1, u2) -> {\r\n    int likes = (u2.boundedSumOfLikes() > maxValLikes) ? maxValLikes : u2.boundedSumOfLikes();\r\n    return new BlogPost.TitlesBoundedSumOfLikes(u1.titles().toUpperCase() + \" : \" + u2.titles().toUpperCase(), u1.boundedSumOfLikes() + likes);\r\n  })); \r\n```","```\r\nMap<BlogPostType, String> postsPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType, \r\n  mapping(BlogPost::getTitle, joining(\", \", \"Post titles: [\", \"]\")))); \r\n```","```\r\nEnumMap<BlogPostType, List<BlogPost>> postsPerType = posts.stream()\r\n  .collect(groupingBy(BlogPost::getType, \r\n  () -> new EnumMap<>(BlogPostType.class), toList())); \r\n```","```\r\nConcurrentMap<BlogPostType, List<BlogPost>> postsPerType = posts.parallelStream()\r\n  .collect(groupingByConcurrent(BlogPost::getType)); \r\n```"]