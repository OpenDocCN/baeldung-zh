["```\r\npublic class Block {\r\n    private String hash;\r\n    private String previousHash;\r\n    private String data;\r\n    private long timeStamp;\r\n    private int nonce;\r\n\r\n    public Block(String data, String previousHash, long timeStamp) {\r\n        this.data = data;\r\n        this.previousHash = previousHash;\r\n        this.timeStamp = timeStamp;\r\n        this.hash = calculateBlockHash();\r\n    }\r\n    // standard getters and setters\r\n}\r\n```","```\r\npublic String calculateBlockHash() {\r\n    String dataToHash = previousHash \r\n      + Long.toString(timeStamp) \r\n      + Integer.toString(nonce) \r\n      + data;\r\n    MessageDigest digest = null;\r\n    byte[] bytes = null;\r\n    try {\r\n        digest = MessageDigest.getInstance(\"SHA-256\");\r\n        bytes = digest.digest(dataToHash.getBytes(UTF_8));\r\n    } catch (NoSuchAlgorithmException | UnsupportedEncodingException ex) {\r\n        logger.log(Level.SEVERE, ex.getMessage());\r\n    }\r\n    StringBuffer buffer = new StringBuffer();\r\n    for (byte b : bytes) {\r\n        buffer.append(String.format(\"%02x\", b));\r\n    }\r\n    return buffer.toString();\r\n}\r\n```","```\r\npublic String mineBlock(int prefix) {\r\n    String prefixString = new String(new char[prefix]).replace('\\0', '0');\r\n    while (!hash.substring(0, prefix).equals(prefixString)) {\r\n        nonce++;\r\n        hash = calculateBlockHash();\r\n    }\r\n    return hash;\r\n}\r\n```","```\r\nList<Block> blockchain = new ArrayList<>();\r\nint prefix = 4;\r\nString prefixString = new String(new char[prefix]).replace('\\0', '0');\r\n```","```\r\n@Test\r\npublic void givenBlockchain_whenNewBlockAdded_thenSuccess() {\r\n    Block newBlock = new Block(\r\n      \"The is a New Block.\", \r\n      blockchain.get(blockchain.size() - 1).getHash(),\r\n      new Date().getTime());\r\n    newBlock.mineBlock(prefix);\r\n    assertTrue(newBlock.getHash().substring(0, prefix).equals(prefixString));\r\n    blockchain.add(newBlock);\r\n}\r\n```","```\r\n@Test\r\npublic void givenBlockchain_whenValidated_thenSuccess() {\r\n    boolean flag = true;\r\n    for (int i = 0; i < blockchain.size(); i++) {\r\n        String previousHash = i==0 ? \"0\" : blockchain.get(i - 1).getHash();\r\n        flag = blockchain.get(i).getHash().equals(blockchain.get(i).calculateBlockHash())\r\n          && previousHash.equals(blockchain.get(i).getPreviousHash())\r\n          && blockchain.get(i).getHash().substring(0, prefix).equals(prefixString);\r\n            if (!flag) break;\r\n    }\r\n    assertTrue(flag);\r\n}\r\n```"]