["```\r\nStream<String> streamEmpty = Stream.empty();\r\n```","```\r\npublic Stream<String> streamOf(List<String> list) {\r\n    return list == null || list.isEmpty() ? Stream.empty() : list.stream();\r\n}\r\n```","```\r\nCollection<String> collection = Arrays.asList(\"a\", \"b\", \"c\");\r\nStream<String> streamOfCollection = collection.stream();\r\n```","```\r\nStream<String> streamOfArray = Stream.of(\"a\", \"b\", \"c\");\r\n```","```\r\nString[] arr = new String[]{\"a\", \"b\", \"c\"};\r\nStream<String> streamOfArrayFull = Arrays.stream(arr);\r\nStream<String> streamOfArrayPart = Arrays.stream(arr, 1, 3);\r\n```","```\r\nStream<String> streamBuilder =\r\n  Stream.<String>builder().add(\"a\").add(\"b\").add(\"c\").build();\r\n```","```\r\nStream<String> streamGenerated =\r\n  Stream.generate(() -> \"element\").limit(10);\r\n```","```\r\nStream<Integer> streamIterated = Stream.iterate(40, n -> n + 2).limit(20);\r\n```","```\r\nIntStream intStream = IntStream.range(1, 3);\r\nLongStream longStream = LongStream.rangeClosed(1, 3);\r\n```","```\r\nRandom random = new Random();\r\nDoubleStream doubleStream = random.doubles(3);\r\n```","```\r\nIntStream streamOfChars = \"abc\".chars();\r\n```","```\r\nStream<String> streamOfString =\r\n  Pattern.compile(\", \").splitAsStream(\"a, b, c\");\r\n```","```\r\nPath path = Paths.get(\"C:\\\\file.txt\");\r\nStream<String> streamOfStrings = Files.lines(path);\r\nStream<String> streamWithCharset = \r\n  Files.lines(path, Charset.forName(\"UTF-8\"));\r\n```","```\r\nStream<String> stream = \r\n  Stream.of(\"a\", \"b\", \"c\").filter(element -> element.contains(\"b\"));\r\nOptional<String> anyElement = stream.findAny();\r\n```","```\r\nOptional<String> firstElement = stream.findFirst();\r\n```","```\r\nList<String> elements =\r\n  Stream.of(\"a\", \"b\", \"c\").filter(element -> element.contains(\"b\"))\r\n    .collect(Collectors.toList());\r\nOptional<String> anyElement = elements.stream().findAny();\r\nOptional<String> firstElement = elements.stream().findFirst();\r\n```","```\r\nStream<String> onceModifiedStream =\r\n  Stream.of(\"abcd\", \"bbcd\", \"cbcd\").skip(1);\r\n```","```\r\nStream<String> twiceModifiedStream =\r\n  stream.skip(1).map(element -> element.substring(0, 3));\r\n```","```\r\nList<String> list = Arrays.asList(\"abc1\", \"abc2\", \"abc3\");\r\nlong size = list.stream().skip(1)\r\n  .map(element -> element.substring(0, 3)).sorted().count();\r\n```","```\r\nprivate long counter;\r\n\r\nprivate void wasCalled() {\r\n    counter++;\r\n}\r\n```","```\r\nList<String> list = Arrays.asList(“abc1”, “abc2”, “abc3”);\r\ncounter = 0;\r\nStream<String> stream = list.stream().filter(element -> {\r\n    wasCalled();\r\n    return element.contains(\"2\");\r\n});\r\n```","```\r\nOptional<String> stream = list.stream().filter(element -> {\r\n    log.info(\"filter() was called\");\r\n    return element.contains(\"2\");\r\n}).map(element -> {\r\n    log.info(\"map() was called\");\r\n    return element.toUpperCase();\r\n}).findFirst();\r\n```","```\r\nlong size = list.stream().map(element -> {\r\n    wasCalled();\r\n    return element.substring(0, 3);\r\n}).skip(2).count();\r\n```","```\r\nlong size = list.stream().skip(2).map(element -> {\r\n    wasCalled();\r\n    return element.substring(0, 3);\r\n}).count();\r\n```","```\r\nOptionalInt reduced =\r\n  IntStream.range(1, 4).reduce((a, b) -> a + b);\r\n```","```\r\nint reducedTwoParams =\r\n  IntStream.range(1, 4).reduce(10, (a, b) -> a + b);\r\n```","```\r\nint reducedParams = Stream.of(1, 2, 3)\r\n  .reduce(10, (a, b) -> a + b, (a, b) -> {\r\n     log.info(\"combiner was called\");\r\n     return a + b;\r\n  });\r\n```","```\r\nint reducedParallel = Arrays.asList(1, 2, 3).parallelStream()\r\n    .reduce(10, (a, b) -> a + b, (a, b) -> {\r\n       log.info(\"combiner was called\");\r\n       return a + b;\r\n    });\r\n```","```\r\nList<Product> productList = Arrays.asList(new Product(23, \"potatoes\"),\r\n  new Product(14, \"orange\"), new Product(13, \"lemon\"),\r\n  new Product(23, \"bread\"), new Product(13, \"sugar\"));\r\n```","```\r\nList<String> collectorCollection = \r\n  productList.stream().map(Product::getName).collect(Collectors.toList());\r\n```","```\r\nString listToString = productList.stream().map(Product::getName)\r\n  .collect(Collectors.joining(\", \", \"[\", \"]\"));\r\n```","```\r\ndouble averagePrice = productList.stream()\r\n  .collect(Collectors.averagingInt(Product::getPrice));\r\n```","```\r\nint summingPrice = productList.stream()\r\n  .collect(Collectors.summingInt(Product::getPrice));\r\n```","```\r\nIntSummaryStatistics statistics = productList.stream()\r\n  .collect(Collectors.summarizingInt(Product::getPrice));\r\n```","```\r\nMap<Integer, List<Product>> collectorMapOfLists = productList.stream()\r\n  .collect(Collectors.groupingBy(Product::getPrice));\r\n```","```\r\nMap<Boolean, List<Product>> mapPartioned = productList.stream()\r\n  .collect(Collectors.partitioningBy(element -> element.getPrice() > 15));\r\n```","```\r\nSet<Product> unmodifiableSet = productList.stream()\r\n  .collect(Collectors.collectingAndThen(Collectors.toSet(),\r\n  Collections::unmodifiableSet));\r\n```","```\r\nCollector<Product, ?, LinkedList<Product>> toLinkedList =\r\n  Collector.of(LinkedList::new, LinkedList::add, \r\n    (first, second) -> { \r\n       first.addAll(second); \r\n       return first; \r\n    });\r\n\r\nLinkedList<Product> linkedListOfPersons =\r\n  productList.stream().collect(toLinkedList);\r\n```","```\r\nStream<Product> streamOfCollection = productList.parallelStream();\r\nboolean isParallel = streamOfCollection.isParallel();\r\nboolean bigPrice = streamOfCollection\r\n  .map(product -> product.getPrice() * 12)\r\n  .anyMatch(price -> price > 200);\r\n```","```\r\nIntStream intStreamParallel = IntStream.range(1, 150).parallel();\r\nboolean isParallel = intStreamParallel.isParallel();\r\n```","```\r\nIntStream intStreamSequential = intStreamParallel.sequential();\r\nboolean isParallel = intStreamSequential.isParallel();\r\n```"]