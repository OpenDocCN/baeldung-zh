["```\r\nInitialize an empty edge set T. \r\nSort all graph edges by the ascending order of their weight values. \r\nforeach edge in the sorted edge list\r\n    Check whether it will create a cycle with the edges inside T.\r\n    If the edge doesn't introduce any cycles, add it into T. \r\n    If T has (V-1) edges, exit the loop. \r\nreturn T\r\n```","```\r\npublic class DisjointSetInfo {\r\n    private Integer parentNode;\r\n    DisjointSetInfo(Integer parent) {\r\n        setParentNode(parent);\r\n    }\r\n\r\n    //standard setters and getters\r\n}\r\n```","```\r\nvoid initDisjointSets(int totalNodes) {\r\n    nodes = new ArrayList<>(totalNodes);\r\n    for (int i = 0; i < totalNodes; i++) {\r\n        nodes.add(new DisjointSetInfo(i));\r\n    }\r\n} \r\n```","```\r\nInteger find(Integer node) {\r\n    Integer parent = nodes.get(node).getParentNode();\r\n    if (parent.equals(node)) {\r\n        return node;\r\n    } else {\r\n        return find(parent);\r\n    }\r\n}\r\n```","```\r\nInteger pathCompressionFind(Integer node) {\r\n    DisjointSetInfo setInfo = nodes.get(node);\r\n    Integer parent = setInfo.getParentNode();\r\n    if (parent.equals(node)) {\r\n        return node;\r\n    } else {\r\n        Integer parentNode = find(parent);\r\n        setInfo.setParentNode(parentNode);\r\n        return parentNode;\r\n    }\r\n}\r\n```","```\r\nvoid union(Integer rootU, Integer rootV) {\r\n    DisjointSetInfo setInfoU = nodes.get(rootU);\r\n    setInfoU.setParentNode(rootV);\r\n}\r\n```","```\r\npublic class DisjointSetInfo {\r\n    private Integer parentNode;\r\n    private int rank;\r\n    DisjointSetInfo(Integer parent) {\r\n        setParentNode(parent);\r\n        setRank(0);\r\n    }\r\n\r\n    //standard setters and getters\r\n}\r\n```","```\r\nvoid unionByRank(int rootU, int rootV) {\r\n    DisjointSetInfo setInfoU = nodes.get(rootU);\r\n    DisjointSetInfo setInfoV = nodes.get(rootV);\r\n    int rankU = setInfoU.getRank();\r\n    int rankV = setInfoV.getRank();\r\n    if (rankU < rankV) {\r\n        setInfoU.setParentNode(rootV);\r\n    } else {\r\n        setInfoV.setParentNode(rootU);\r\n        if (rankU == rankV) {\r\n            setInfoU.setRank(rankU + 1);\r\n        }\r\n    }\r\n}\r\n```","```\r\nboolean detectCycle(Integer u, Integer v) {\r\n    Integer rootU = pathCompressionFind(u);\r\n    Integer rootV = pathCompressionFind(v);\r\n    if (rootU.equals(rootV)) {\r\n        return true;\r\n    }\r\n    unionByRank(rootU, rootV);\r\n    return false;\r\n} \r\n```","```\r\n<dependency>\r\n    <groupId>com.google.guava</groupId>\r\n    <artifactId>guava</artifactId>\r\n    <version>31.0.1-jre</version>\r\n</dependency>\r\n```","```\r\nValueGraph<Integer, Double> spanningTree(ValueGraph<Integer, Double> graph, boolean minSpanningTree) {\r\n    Set<EndpointPair> edges = graph.edges();\r\n    List<EndpointPair> edgeList = new ArrayList<>(edges);\r\n\r\n    if (minSpanningTree) {\r\n        edgeList.sort(Comparator.comparing(e -> graph.edgeValue(e).get()));\r\n    } else {\r\n        edgeList.sort(Collections.reverseOrder(Comparator.comparing(e -> graph.edgeValue(e).get())));\r\n    }\r\n\r\n    int totalNodes = graph.nodes().size();\r\n    CycleDetector cycleDetector = new CycleDetector(totalNodes);\r\n    int edgeCount = 0;\r\n\r\n    MutableValueGraph<Integer, Double> spanningTree = ValueGraphBuilder.undirected().build();\r\n    for (EndpointPair edge : edgeList) {\r\n        if (cycleDetector.detectCycle(edge.nodeU(), edge.nodeV())) {\r\n            continue;\r\n        }\r\n        spanningTree.putEdgeValue(edge.nodeU(), edge.nodeV(), graph.edgeValue(edge).get());\r\n        edgeCount++;\r\n        if (edgeCount == totalNodes - 1) {\r\n            break;\r\n        }\r\n    }\r\n    return spanningTree;\r\n}\r\n```"]