# Java 面试问题中的内存管理(+答案)

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-memory-management-interview-questions>

[This article is part of a series:](javascript:void(0);)[• Java Collections Interview Questions](/web/20220812054459/https://www.baeldung.com/java-collections-interview-questions)
[• Java Type System Interview Questions](/web/20220812054459/https://www.baeldung.com/java-type-system-interview-questions)
[• Java Concurrency Interview Questions (+ Answers)](/web/20220812054459/https://www.baeldung.com/java-concurrency-interview-questions)
[• Java Class Structure and Initialization Interview Questions](/web/20220812054459/https://www.baeldung.com/java-classes-initialization-questions)
[• Java 8 Interview Questions(+ Answers)](/web/20220812054459/https://www.baeldung.com/java-8-interview-questions)
• Memory Management in Java Interview Questions (+Answers) (current article)[• Java Generics Interview Questions (+Answers)](/web/20220812054459/https://www.baeldung.com/java-generics-interview-questions)
[• Java Flow Control Interview Questions (+ Answers)](/web/20220812054459/https://www.baeldung.com/java-flow-control-interview-questions)
[• Java Exceptions Interview Questions (+ Answers)](/web/20220812054459/https://www.baeldung.com/java-exceptions-interview-questions)
[• Java Annotations Interview Questions (+ Answers)](/web/20220812054459/https://www.baeldung.com/java-annotations-interview-questions)
[• Top Spring Framework Interview Questions](/web/20220812054459/https://www.baeldung.com/spring-interview-questions)

## 1.介绍

在本文中，我们将探讨一些在 Java 开发人员面试中经常出现的内存管理问题。内存管理是一个没有多少开发人员熟悉的领域。

事实上，开发人员通常不必直接处理这个概念——因为 JVM 会处理本质细节。除非出现了严重的问题，否则即使是经验丰富的开发人员也不一定掌握关于内存管理的准确信息。

另一方面，这些概念实际上在面试中相当普遍——所以让我们直入主题吧。

## 2.问题

### **Q1。“内存是用 Java 管理的”这句话是什么意思？**

内存是应用程序有效运行所需的关键资源，就像任何资源一样，它是稀缺的。因此，它在应用程序或应用程序的不同部分之间的分配和取消分配需要非常小心和考虑。

然而，在 Java 中，开发人员不需要显式地分配和释放内存 JVM，更具体地说是垃圾收集器，有责任处理内存分配，这样开发人员就不必这么做了。

这与 C 语言中发生的情况相反，在 C 语言中，程序员可以直接访问内存，并在代码中引用内存单元，这为内存泄漏创造了很大的空间。

### **Q2。什么是垃圾收集，它的优势是什么？**

垃圾收集是查看堆内存、确定哪些对象正在使用，哪些没有使用，并删除未使用的对象的过程。

一个正在使用的对象，或者一个被引用的对象，意味着你的程序的某个部分仍然保持着一个指向那个对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。因此未被引用的对象所使用的内存可以被回收。

垃圾收集的最大优点是，它消除了我们手动分配/释放内存的负担，这样我们就可以专注于解决手头的问题。

### **Q3。垃圾收集有什么缺点吗？**

是的。每当垃圾收集器运行时，它都会对应用程序的性能产生影响。这是因为应用程序中的所有其他线程都必须停止，以允许垃圾收集器线程有效地完成其工作。

根据应用程序的要求，这可能是一个客户无法接受的实际问题。但是，通过巧妙的优化和垃圾收集器调优以及使用不同的 GC 算法，可以大大减少甚至消除这个问题。

### **Q4。术语“停止世界”的含义是什么？**

当垃圾收集器线程运行时，其他线程会停止，这意味着应用程序会暂时停止。这类似于房屋清洁或熏蒸，在此过程完成之前，居住者不得进入。

根据应用程序的需要，“停止世界”垃圾收集可能会导致不可接受的冻结。这就是为什么进行垃圾收集器调优和 JVM 优化很重要，这样遇到的冻结至少是可以接受的。

### **Q5。什么是栈和堆？这些记忆结构中分别储存了什么，它们是如何相互联系的？**

堆栈是内存的一部分，它包含有关嵌套方法调用的信息，一直到程序中的当前位置。它还包含所有局部变量和对当前执行的方法中定义的堆上对象的引用。

这种结构允许运行时在知道调用地址的情况下从方法返回，并且在退出方法后清除所有局部变量。每个线程都有自己的堆栈。

堆是用于分配对象的大量内存。当你用关键字`new`创建一个对象时，它在堆上被分配。但是，对这个对象的引用存在于堆栈中。

### **Q6。什么是分代垃圾收集，是什么使它成为一种流行的垃圾收集方法？**

分代式垃圾收集可以粗略地定义为垃圾收集器使用的策略，其中堆被分成许多称为代的部分，每个代将根据对象在堆上的“年龄”来保存对象。

每当垃圾收集器运行时，该过程的第一步称为标记。这是垃圾收集器识别哪些内存正在使用，哪些没有使用的地方。如果必须扫描系统中的所有对象，这可能是一个非常耗时的过程。

随着越来越多的对象被分配，对象列表不断增长，导致垃圾收集时间越来越长。然而，对应用程序的经验分析表明，大多数对象都是短命的。

使用分代垃圾收集，对象根据它们的“年龄”(即它们已经存活了多少个垃圾收集周期)进行分组。通过这种方式，大部分工作分散在不同的次要和主要收集周期中。

今天，几乎所有的垃圾收集器都是分代的。这种策略非常受欢迎，因为随着时间的推移，它已被证明是最佳解决方案。

### **Q7。详细描述分代垃圾收集的工作原理**

为了正确理解分代式垃圾收集是如何工作的，首先**记住 Java 堆是如何构造的**以促进分代式垃圾收集是很重要的。

堆被分成更小的空间或层代。这些空间是年轻的一代、年老的或终身的一代和永久的一代。

年轻一代拥有大多数新创建的对象。对大多数应用程序的实证研究表明，大多数对象的寿命很短，因此很快就有资格被收集。因此，新的对象在这里开始它们的旅程，并在达到一定的“年龄”后才被“提升”到老一代空间。

分代垃圾收集**中的术语**“年龄”**是指对象存活**的收集周期数。

年轻一代空间被进一步分成三个空间:伊甸园空间和两个幸存者空间，例如幸存者 1 (s1)和幸存者 2 (s2)。

**老一代主持** **在内存中生活的时间超过某个“年龄”**的对象。在年轻一代的垃圾收集中幸存下来的对象被提升到这个空间。一般比年轻一代大。因为它的体积更大，所以垃圾收集比年轻一代更昂贵，发生的频率也更低。

**永久生成** **或更常见的称呼`PermGen,`包含 JVM** 所需的元数据，以描述应用程序中使用的类和方法。它还包含用于存储被拘留字符串的字符串池。它由 JVM 在运行时根据应用程序使用的类来填充。此外，平台库类和方法可能存储在这里。

首先，**任何新对象被分配到伊甸园空间**。两个幸存者空间都是空的。当 Eden 空间填满时，会触发一个小的垃圾收集。被引用的对象被移动到第一个幸存空间。未引用的对象将被删除。

在下一次小 GC 中，同样的事情发生在伊甸园空间。未被引用的对象被删除，而被引用的对象被移动到残存空间。然而，在这种情况下，他们被移动到第二幸存者空间(S2)。

此外，来自第一幸存者空间(S1)中的最后一个次要 GC 的对象的年龄递增，并被移动到 S2。一旦所有幸存的对象都被转移到 S2，S1 和伊甸园空间都被清除。在这一点上，S2 包含了不同年代的物品。

在下一次较小的 GC 中，重复相同的过程。然而，这一次幸存者空间切换。被引用的对象被从伊甸园和 S2 转移到 S1。幸存的物体是老化的。伊登和 S2 被清除了。

在每个小的垃圾收集周期之后，检查每个对象的年龄。那些达到某个任意年龄的人，例如 8 岁，从年轻的一代晋升到年老的或终身的一代。对于所有后续的小 GC 周期，对象将继续提升到旧的层代空间。

这几乎耗尽了年轻一代的垃圾收集过程。最终，将在老一代上执行主要的垃圾收集，清理和压缩该空间。对于每个主要 GC，都有几个次要 GC。

### **Q8。一个对象什么时候有资格进行垃圾回收？描述 Gc 如何收集一个合格的对象？**

如果一个对象无法从任何活动线程或任何静态引用访问，则该对象有资格进行垃圾收集或 GC。

一个对象有资格进行垃圾收集的最直接的情况是它的所有引用都为空。没有任何活动外部引用的循环依赖也适合 GC。因此，如果对象 A 引用对象 B，对象 B 引用对象 A，并且它们没有任何其他活引用，那么对象 A 和 B 都有资格进行垃圾收集。

另一个明显的例子是当父对象被设置为 null 时。当一个厨房对象在内部引用了一个冰箱对象和一个水槽对象，并且厨房对象被设置为空时，冰箱和水槽都可以和它们的父对象厨房一起进行垃圾收集。

### **Q9。如何从 Java 代码中触发垃圾收集？**

**你作为 Java 程序员，不能在 Java 里强制垃圾回收**；只有当 JVM 认为它需要基于 Java 堆大小的垃圾收集时，它才会被触发。

在从内存中移除一个对象之前，垃圾收集线程调用该对象的 finalize()方法，并提供一个机会来执行任何所需的清理。您也可以调用对象代码的这个方法，但是，不能保证当您调用这个方法时会发生垃圾回收。

此外，还有像 System.gc()和 Runtime.gc()这样的方法，用于向 JVM 发送垃圾收集请求，但不能保证垃圾收集会发生。

### **Q10。当没有足够的堆空间来容纳新对象的存储时会发生什么？**

如果堆中没有用于创建新对象的内存空间，Java 虚拟机就会抛出`OutOfMemoryError`或者更确切地说是 **`java.lang.OutOfMemoryError`堆空间。**

### **Q11。有可能复活一个符合垃圾收集条件的对象吗？**

当一个对象有资格进行垃圾收集时，GC 必须对它运行`finalize`方法。`finalize`方法保证只运行一次，因此 GC 将对象标记为终结，并让它休息到下一个周期。

在`finalize`方法中，你可以从技术上“复活”一个对象，例如，通过将它分配给一个`static`字段。该对象将再次变为活动的，并且不符合垃圾收集的条件，因此 GC 将不会在下一个周期收集它。

但是，该对象将被标记为 finalized，因此当它再次符合条件时，将不会调用 finalize 方法。本质上，你可以在该物品的一生中只使用一次这个“复活”戏法。请注意，只有当您真正知道自己在做什么时，才应该使用这种丑陋的方法——然而，理解这种技巧可以让您对 GC 的工作原理有所了解。

### **Q12。描述强引用、弱引用、软引用和幻像引用及其在垃圾收集中的作用。**

就像在 Java 中管理内存一样，在关键应用中，工程师可能需要执行尽可能多的优化，以最小化延迟并最大化吞吐量。正如在 JVM 中不可能明确控制何时触发垃圾收集一样，**对于我们已经创建的对象来说，影响它如何发生是可能的。**

Java 为我们提供了引用对象来控制我们创建的对象和垃圾收集器之间的关系。

默认情况下，我们在 Java 程序中创建的每个对象都被一个变量强引用:

[PRE0]

在上面的代码片段中，`new`关键字创建了一个新的`StringBuilder`对象，并将其存储在堆中。然后变量`sb`存储一个**到这个对象的强引用**。对于垃圾收集器来说，这意味着特定的`StringBuilder`对象根本不符合收集条件，因为`sb`持有对它的强引用。只有当我们像这样取消`sb`时，故事才会改变:

[PRE1]

在调用上面的行之后，对象就可以被收集了。

我们可以改变对象和垃圾收集器之间的这种关系，方法是将它显式地包装在位于`java.lang.ref`包内的另一个引用对象中。

可以为上述对象创建一个**软引用**，如下所示:

[PRE2]

在上面的代码片段中，我们创建了对`StringBuilder`对象的两个引用。第一行创建一个**强引用** `sb`，第二行创建一个**软引用** `sbRef`。第三行应该使对象符合收集条件，但是垃圾收集器会因为`sbRef`而推迟收集。

只有当内存变得紧张，JVM 处于抛出`OutOfMemory`错误的边缘时，故事才会改变。换句话说，只有软引用的对象被收集作为恢复内存的最后手段。

使用`WeakReference`类可以以类似的方式创建一个**弱引用**。当`sb`被设置为 null 并且`StringBuilder`对象只有一个弱引用时，JVM 的垃圾收集器将绝对不会妥协，并在下一个周期立即收集该对象。

一个**幻象引用**类似于一个弱引用，一个只有幻象引用的对象将被收集而无需等待。但是，一旦虚像引用的对象被收集，它们就会被排队。我们可以轮询引用队列，以确切知道对象是何时被收集的。

### **Q13。假设我们有一个循环引用(两个相互引用的对象)。这样的一对对象有资格进行垃圾收集吗？为什么？**

是的，一对具有循环引用的对象可以进行垃圾收集。这是因为 Java 的垃圾收集器处理循环引用的方式。它认为对象是活的，不是当它们有对它们的任何引用时，而是当它们通过从某个垃圾收集根(活线程的局部变量或静态字段)开始导航对象图而可到达时。如果一对具有循环引用的对象不能从任何根到达，它被认为符合垃圾收集的条件。

### **Q14。字符串在内存中是如何表示的？**

Java 中的`String`实例是一个具有两个字段的对象:一个`char[] value`字段和一个`int hash`字段。`value`字段是一个表示字符串本身的字符数组，`hash`字段包含一个字符串的`hashCode`，该字符串用零初始化，在第一次`hashCode()`调用期间计算并缓存至今。奇怪的是，如果一个字符串的`hashCode`有一个零值，那么每次调用`hashCode()`时都必须重新计算。

重要的是，`String`实例是不可变的:您不能获取或修改底层的`char[]`数组。字符串的另一个特性是静态常量字符串被加载并缓存在字符串池中。如果您的源代码中有多个相同的`String`对象，它们在运行时都由一个实例来表示。

### **Q15。什么是 Stringbuilder，它的用例是什么？向 Stringbuilder 追加一个字符串和用+运算符连接两个字符串有什么区别？Stringbuilder 和 Stringbuffer 有什么不同？**

`StringBuilder`允许通过添加、删除和插入字符和字符串来操作字符序列。这是一个可变的数据结构，与不可变的`String`类相反。

当连接两个`String`实例时，会创建一个新对象，并复制字符串。如果我们需要在一个循环中创建或修改一个字符串，这会带来巨大的垃圾收集器开销。`StringBuilder`允许更有效地处理字符串操作。

`StringBuffer`与`StringBuilder`的不同之处在于它是线程安全的。如果你需要在单线程中操作一个字符串，使用`StringBuilder`代替。

## **3。结论**

在本文中，我们讨论了 Java 工程师面试中经常出现的一些最常见的问题。关于内存管理的问题大多是问高级 Java 开发人员候选人的，因为面试官希望您已经构建了很多次被内存问题困扰的重要应用程序。

这不应该被视为一个详尽的问题清单，而是一个进一步研究的发射台。我们 Baeldung 祝您在即将到来的面试中取得成功。

Next **»**[Java Generics Interview Questions (+Answers)](/web/20220812054459/https://www.baeldung.com/java-generics-interview-questions)**«** Previous[Java 8 Interview Questions(+ Answers)](/web/20220812054459/https://www.baeldung.com/java-8-interview-questions)