["```\r\n<dependency>\r\n    <groupId>io.lettuce</groupId>\r\n    <artifactId>lettuce-core</artifactId>\r\n    <version>5.0.1.RELEASE</version>\r\n</dependency> \r\n```","```\r\nRedisClient redisClient = RedisClient\r\n  .create(\"redis://[[email protected]](/web/20221126235007/https://www.baeldung.com/cdn-cgi/l/email-protection):6379/\");\r\nStatefulRedisConnection<String, String> connection\r\n = redisClient.connect();\r\n```","```\r\nredis :// [[[email protected]](/web/20221126235007/https://www.baeldung.com/cdn-cgi/l/email-protection)] host [: port] [/ database]\r\n  [? [timeout=timeout[d|h|m|s|ms|us|ns]]\r\n  [&_database=database_]] \r\n```","```\r\nRedisURI.Builder\r\n  .redis(\"localhost\", 6379).auth(\"password\")\r\n  .database(1).build(); \r\n```","```\r\nnew RedisURI(\"localhost\", 6379, 60, TimeUnit.SECONDS); \r\n```","```\r\nRedisCommands<String, String> syncCommands = connection.sync(); \r\n```","```\r\nsyncCommands.set(\"key\", \"Hello, Redis!\");\r\n\r\nString value = syncommands.get(“key”); \r\n```","```\r\nsyncCommands.hset(\"recordName\", \"FirstName\", \"John\");\r\nsyncCommands.hset(\"recordName\", \"LastName\", \"Smith\");\r\nMap<String, String> record = syncCommands.hgetall(\"recordName\"); \r\n```","```\r\nRedisAsyncCommands<String, String> asyncCommands = connection.async(); \r\n```","```\r\nRedisFuture<String> result = asyncCommands.get(\"key\"); \r\n```","```\r\nRedisStringReactiveCommands<String, String> reactiveCommands = connection.reactive(); \r\n```","```\r\nasyncCommands.lpush(\"tasks\", \"firstTask\");\r\nasyncCommands.lpush(\"tasks\", \"secondTask\");\r\nRedisFuture<String> redisFuture = asyncCommands.rpop(\"tasks\");\r\n\r\nString nextTask = redisFuture.get(); \r\n```","```\r\nasyncCommands.del(\"tasks\");\r\nasyncCommands.lpush(\"tasks\", \"firstTask\");\r\nasyncCommands.lpush(\"tasks\", \"secondTask\");\r\nredisFuture = asyncCommands.lpop(\"tasks\");\r\n\r\nString nextTask = redisFuture.get(); \r\n```","```\r\nasyncCommands.sadd(\"pets\", \"dog\");\r\nasyncCommands.sadd(\"pets\", \"cat\");\r\nasyncCommands.sadd(\"pets\", \"cat\");\r\n\r\nRedisFuture<Set<String>> pets = asyncCommands.smembers(\"nicknames\");\r\nRedisFuture<Boolean> exists = asyncCommands.sismember(\"pets\", \"dog\"); \r\n```","```\r\nasyncCommands.hset(\"recordName\", \"FirstName\", \"John\");\r\nasyncCommands.hset(\"recordName\", \"LastName\", \"Smith\");\r\n\r\nRedisFuture<String> lastName \r\n  = syncCommands.hget(\"recordName\", \"LastName\");\r\nRedisFuture<Map<String, String>> record \r\n  = syncCommands.hgetall(\"recordName\"); \r\n```","```\r\nasyncCommands.zadd(\"sortedset\", 1, \"one\");\r\nasyncCommands.zadd(\"sortedset\", 4, \"zero\");\r\nasyncCommands.zadd(\"sortedset\", 2, \"two\");\r\n\r\nRedisFuture<List<String>> valuesForward = asyncCommands.zrange(key, 0, 3);\r\nRedisFuture<List<String>> valuesReverse = asyncCommands.zrevrange(key, 0, 3); \r\n```","```\r\nasyncCommands.multi();\r\n\r\nRedisFuture<String> result1 = asyncCommands.set(\"key1\", \"value1\");\r\nRedisFuture<String> result2 = asyncCommands.set(\"key2\", \"value2\");\r\nRedisFuture<String> result3 = asyncCommands.set(\"key3\", \"value3\");\r\n\r\nRedisFuture<TransactionResult> execResult = asyncCommands.exec();\r\n\r\nTransactionResult transactionResult = execResult.get();\r\n\r\nString firstResult = transactionResult.get(0);\r\nString secondResult = transactionResult.get(0);\r\nString thirdResult = transactionResult.get(0); \r\n```","```\r\ncommands.setAutoFlushCommands(false);\r\n\r\nList<RedisFuture<?>> futures = new ArrayList<>();\r\nfor (int i = 0; i < iterations; i++) {\r\n    futures.add(commands.set(\"key-\" + i, \"value-\" + i);\r\n}\r\ncommands.flushCommands();\r\n\r\nboolean result = LettuceFutures.awaitAll(5, TimeUnit.SECONDS,\r\n  futures.toArray(new RedisFuture[0])); \r\n```","```\r\npublic class Listener implements RedisPubSubListener<String, String> {\r\n\r\n    @Override\r\n    public void message(String channel, String message) {\r\n        log.debug(\"Got {} on channel {}\",  message, channel);\r\n        message = new String(s2);\r\n    }\r\n} \r\n```","```\r\nStatefulRedisPubSubConnection<String, String> connection\r\n = client.connectPubSub();\r\nconnection.addListener(new Listener())\r\n\r\nRedisPubSubAsyncCommands<String, String> async\r\n = connection.async();\r\nasync.subscribe(\"channel\"); \r\n```","```\r\nStatefulRedisPubSubConnection<String, String> connection \r\n  = client.connectPubSub();\r\n\r\nRedisPubSubAsyncCommands<String, String> async \r\n  = connection.async();\r\nasync.publish(\"channel\", \"Hello, Redis!\"); \r\n```","```\r\nStatefulRedisPubSubConnection<String, String> connection = client\r\n  .connectPubSub();\r\n\r\nRedisPubSubAsyncCommands<String, String> reactive = connection\r\n  .reactive();\r\n\r\nreactive.observeChannels().subscribe(message -> {\r\n    log.debug(\"Got {} on channel {}\",  message, channel);\r\n    message = new String(s2);\r\n});\r\nreactive.subscribe(\"channel\").subscribe(); \r\n```","```\r\nRedisClient redisClient = RedisClient.create();\r\n\r\nStatefulRedisMasterSlaveConnection<String, String> connection\r\n = MasterSlave.connect(redisClient, \r\n   new Utf8StringCodec(), RedisURI.create(\"redis://localhost\"));\r\n\r\nconnection.setReadFrom(ReadFrom.SLAVE); \r\n```","```\r\nRedisURI redisUri = RedisURI.Builder\r\n  .sentinel(\"sentinelhost1\", \"clustername\")\r\n  .withSentinel(\"sentinelhost2\").build();\r\nRedisClient client = new RedisClient(redisUri);\r\n\r\nRedisConnection<String, String> connection = client.connect(); \r\n```","```\r\nRedisURI redisUri = RedisURI.Builder.redis(\"localhost\")\r\n  .withPassword(\"authentication\").build();\r\nRedisClusterClient clusterClient = RedisClusterClient\r\n  .create(rediUri);\r\nStatefulRedisClusterConnection<String, String> connection\r\n = clusterClient.connect();\r\nRedisAdvancedClusterCommands<String, String> syncCommands = connection\r\n  .sync(); \r\n```"]