["```\r\npublic class Node {\r\n    int key;\r\n    int height;\r\n    Node left;\r\n    Node right;\r\n    ...\r\n}\r\n```","```\r\npublic class AVLTree {\r\n\r\n    private Node root;\r\n\r\n    void updateHeight(Node n) {\r\n        n.height = 1 + Math.max(height(n.left), height(n.right));\r\n    }\r\n\r\n    int height(Node n) {\r\n        return n == null ? -1 : n.height;\r\n    }\r\n\r\n    int getBalance(Node n) {\r\n        return (n == null) ? 0 : height(n.right) - height(n.left);\r\n    }\r\n\r\n    ...\r\n}\r\n```","```\r\nNode rotateRight(Node y) {\r\n    Node x = y.left;\r\n    Node z = x.right;\r\n    x.right = y;\r\n    y.left = z;\r\n    updateHeight(y);\r\n    updateHeight(x);\r\n    return x;\r\n}\r\n```","```\r\nNode rotateLeft(Node y) {\r\n    Node x = y.right;\r\n    Node z = x.left;\r\n    x.left = y;\r\n    y.right = z;\r\n    updateHeight(y);\r\n    updateHeight(x);\r\n    return x;\r\n}\r\n```","```\r\nNode rebalance(Node z) {\r\n    updateHeight(z);\r\n    int balance = getBalance(z);\r\n    if (balance > 1) {\r\n        if (height(z.right.right) > height(z.right.left)) {\r\n            z = rotateLeft(z);\r\n        } else {\r\n            z.right = rotateRight(z.right);\r\n            z = rotateLeft(z);\r\n        }\r\n    } else if (balance < -1) {\r\n        if (height(z.left.left) > height(z.left.right))\r\n            z = rotateRight(z);\r\n        else {\r\n            z.left = rotateLeft(z.left);\r\n            z = rotateRight(z);\r\n        }\r\n    }\r\n    return z;\r\n}\r\n```","```\r\nNode insert(Node node, int key) {\r\n    if (node == null) {\r\n        return new Node(key);\r\n    } else if (node.key > key) {\r\n        node.left = insert(node.left, key);\r\n    } else if (node.key < key) {\r\n        node.right = insert(node.right, key);\r\n    } else {\r\n        throw new RuntimeException(\"duplicate Key!\");\r\n    }\r\n    return rebalance(node);\r\n}\r\n```","```\r\nNode delete(Node node, int key) {\r\n    if (node == null) {\r\n        return node;\r\n    } else if (node.key > key) {\r\n        node.left = delete(node.left, key);\r\n    } else if (node.key < key) {\r\n        node.right = delete(node.right, key);\r\n    } else {\r\n        if (node.left == null || node.right == null) {\r\n            node = (node.left == null) ? node.right : node.left;\r\n        } else {\r\n            Node mostLeftChild = mostLeftChild(node.right);\r\n            node.key = mostLeftChild.key;\r\n            node.right = delete(node.right, node.key);\r\n        }\r\n    }\r\n    if (node != null) {\r\n        node = rebalance(node);\r\n    }\r\n    return node;\r\n}\r\n```","```\r\nNode find(int key) {\r\n    Node current = root;\r\n    while (current != null) {\r\n        if (current.key == key) {\r\n            break;\r\n        }\r\n        current = current.key < key ? current.right : current.left;\r\n    }\r\n    return current;\r\n}\r\n```"]