["```\r\npublic List<Coordinate> solve(Maze maze) {\r\n}\r\n```","```\r\nprivate static int[][] DIRECTIONS \r\n  = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } }; \r\n```","```\r\nprivate Coordinate getNextCoordinate(\r\n  int row, int col, int i, int j) {\r\n    return new Coordinate(row + i, col + j);\r\n}\r\n```","```\r\npublic List<Coordinate> solve(Maze maze) {\r\n    List<Coordinate> path = new ArrayList<>();\r\n    if (\r\n      explore(\r\n        maze, \r\n        maze.getEntry().getX(),\r\n        maze.getEntry().getY(),\r\n        path\r\n      )\r\n      ) {\r\n        return path;\r\n    }\r\n    return Collections.emptyList();\r\n}\r\n```","```\r\nprivate boolean explore(\r\n  Maze maze, int row, int col, List<Coordinate> path) {\r\n    if (\r\n      !maze.isValidLocation(row, col) \r\n      || maze.isWall(row, col) \r\n      || maze.isExplored(row, col)\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    path.add(new Coordinate(row, col));\r\n    maze.setVisited(row, col, true);\r\n\r\n    if (maze.isExit(row, col)) {\r\n        return true;\r\n    }\r\n\r\n    for (int[] direction : DIRECTIONS) {\r\n        Coordinate coordinate = getNextCoordinate(\r\n          row, col, direction[0], direction[1]);\r\n        if (\r\n          explore(\r\n            maze, \r\n            coordinate.getX(), \r\n            coordinate.getY(), \r\n            path\r\n          )\r\n        ) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    path.remove(path.size() - 1);\r\n    return false;\r\n}\r\n```","```\r\nprivate List<Coordinate> backtrackPath(\r\n  Coordinate cur) {\r\n    List<Coordinate> path = new ArrayList<>();\r\n    Coordinate iter = cur;\r\n\r\n    while (iter != null) {\r\n        path.add(iter);\r\n        iter = iter.parent;\r\n    }\r\n\r\n    return path;\r\n}\r\n```","```\r\npublic List<Coordinate> solve(Maze maze) {\r\n    LinkedList<Coordinate> nextToVisit \r\n      = new LinkedList<>();\r\n    Coordinate start = maze.getEntry();\r\n    nextToVisit.add(start);\r\n\r\n    while (!nextToVisit.isEmpty()) {\r\n        Coordinate cur = nextToVisit.remove();\r\n\r\n        if (!maze.isValidLocation(cur.getX(), cur.getY()) \r\n          || maze.isExplored(cur.getX(), cur.getY())\r\n        ) {\r\n            continue;\r\n        }\r\n\r\n        if (maze.isWall(cur.getX(), cur.getY())) {\r\n            maze.setVisited(cur.getX(), cur.getY(), true);\r\n            continue;\r\n        }\r\n\r\n        if (maze.isExit(cur.getX(), cur.getY())) {\r\n            return backtrackPath(cur);\r\n        }\r\n\r\n        for (int[] direction : DIRECTIONS) {\r\n            Coordinate coordinate \r\n              = new Coordinate(\r\n                cur.getX() + direction[0], \r\n                cur.getY() + direction[1], \r\n                cur\r\n              );\r\n            nextToVisit.add(coordinate);\r\n            maze.setVisited(cur.getX(), cur.getY(), true);\r\n        }\r\n    }\r\n    return Collections.emptyList();\r\n}\r\n```"]