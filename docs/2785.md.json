["```\r\nclass LoginQueueUsingSemaphore {\r\n\r\n    private Semaphore semaphore;\r\n\r\n    public LoginQueueUsingSemaphore(int slotLimit) {\r\n        semaphore = new Semaphore(slotLimit);\r\n    }\r\n\r\n    boolean tryLogin() {\r\n        return semaphore.tryAcquire();\r\n    }\r\n\r\n    void logout() {\r\n        semaphore.release();\r\n    }\r\n\r\n    int availableSlots() {\r\n        return semaphore.availablePermits();\r\n    }\r\n\r\n}\r\n```","```\r\n@Test\r\npublic void givenLoginQueue_whenReachLimit_thenBlocked() {\r\n    int slots = 10;\r\n    ExecutorService executorService = Executors.newFixedThreadPool(slots);\r\n    LoginQueueUsingSemaphore loginQueue = new LoginQueueUsingSemaphore(slots);\r\n    IntStream.range(0, slots)\r\n      .forEach(user -> executorService.execute(loginQueue::tryLogin));\r\n    executorService.shutdown();\r\n\r\n    assertEquals(0, loginQueue.availableSlots());\r\n    assertFalse(loginQueue.tryLogin());\r\n}\r\n```","```\r\n@Test\r\npublic void givenLoginQueue_whenLogout_thenSlotsAvailable() {\r\n    int slots = 10;\r\n    ExecutorService executorService = Executors.newFixedThreadPool(slots);\r\n    LoginQueueUsingSemaphore loginQueue = new LoginQueueUsingSemaphore(slots);\r\n    IntStream.range(0, slots)\r\n      .forEach(user -> executorService.execute(loginQueue::tryLogin));\r\n    executorService.shutdown();\r\n    assertEquals(0, loginQueue.availableSlots());\r\n    loginQueue.logout();\r\n\r\n    assertTrue(loginQueue.availableSlots() > 0);\r\n    assertTrue(loginQueue.tryLogin());\r\n}\r\n```","```\r\nclass DelayQueueUsingTimedSemaphore {\r\n\r\n    private TimedSemaphore semaphore;\r\n\r\n    DelayQueueUsingTimedSemaphore(long period, int slotLimit) {\r\n        semaphore = new TimedSemaphore(period, TimeUnit.SECONDS, slotLimit);\r\n    }\r\n\r\n    boolean tryAdd() {\r\n        return semaphore.tryAcquire();\r\n    }\r\n\r\n    int availableSlots() {\r\n        return semaphore.getAvailablePermits();\r\n    }\r\n\r\n}\r\n```","```\r\npublic void givenDelayQueue_whenReachLimit_thenBlocked() {\r\n    int slots = 50;\r\n    ExecutorService executorService = Executors.newFixedThreadPool(slots);\r\n    DelayQueueUsingTimedSemaphore delayQueue \r\n      = new DelayQueueUsingTimedSemaphore(1, slots);\r\n\r\n    IntStream.range(0, slots)\r\n      .forEach(user -> executorService.execute(delayQueue::tryAdd));\r\n    executorService.shutdown();\r\n\r\n    assertEquals(0, delayQueue.availableSlots());\r\n    assertFalse(delayQueue.tryAdd());\r\n}\r\n```","```\r\n@Test\r\npublic void givenDelayQueue_whenTimePass_thenSlotsAvailable() throws InterruptedException {\r\n    int slots = 50;\r\n    ExecutorService executorService = Executors.newFixedThreadPool(slots);\r\n    DelayQueueUsingTimedSemaphore delayQueue = new DelayQueueUsingTimedSemaphore(1, slots);\r\n    IntStream.range(0, slots)\r\n      .forEach(user -> executorService.execute(delayQueue::tryAdd));\r\n    executorService.shutdown();\r\n\r\n    assertEquals(0, delayQueue.availableSlots());\r\n    Thread.sleep(1000);\r\n    assertTrue(delayQueue.availableSlots() > 0);\r\n    assertTrue(delayQueue.tryAdd());\r\n}\r\n```","```\r\nclass CounterUsingMutex {\r\n\r\n    private Semaphore mutex;\r\n    private int count;\r\n\r\n    CounterUsingMutex() {\r\n        mutex = new Semaphore(1);\r\n        count = 0;\r\n    }\r\n\r\n    void increase() throws InterruptedException {\r\n        mutex.acquire();\r\n        this.count = this.count + 1;\r\n        Thread.sleep(1000);\r\n        mutex.release();\r\n\r\n    }\r\n\r\n    int getCount() {\r\n        return this.count;\r\n    }\r\n\r\n    boolean hasQueuedThreads() {\r\n        return mutex.hasQueuedThreads();\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void whenMutexAndMultipleThreads_thenBlocked()\r\n throws InterruptedException {\r\n    int count = 5;\r\n    ExecutorService executorService\r\n     = Executors.newFixedThreadPool(count);\r\n    CounterUsingMutex counter = new CounterUsingMutex();\r\n    IntStream.range(0, count)\r\n      .forEach(user -> executorService.execute(() -> {\r\n          try {\r\n              counter.increase();\r\n          } catch (InterruptedException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }));\r\n    executorService.shutdown();\r\n\r\n    assertTrue(counter.hasQueuedThreads());\r\n}\r\n```","```\r\n@Test\r\npublic void givenMutexAndMultipleThreads_ThenDelay_thenCorrectCount()\r\n throws InterruptedException {\r\n    int count = 5;\r\n    ExecutorService executorService\r\n     = Executors.newFixedThreadPool(count);\r\n    CounterUsingMutex counter = new CounterUsingMutex();\r\n    IntStream.range(0, count)\r\n      .forEach(user -> executorService.execute(() -> {\r\n          try {\r\n              counter.increase();\r\n          } catch (InterruptedException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }));\r\n    executorService.shutdown();\r\n\r\n    assertTrue(counter.hasQueuedThreads());\r\n    Thread.sleep(5000);\r\n    assertFalse(counter.hasQueuedThreads());\r\n    assertEquals(count, counter.getCount());\r\n}\r\n```"]