["```\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-context-support</artifactId>\r\n    <version>5.2.2.RELEASE</version>\r\n</dependency> \r\n```","```\r\npublic class GenericDao<E> {\r\n\r\n    private Class<E> entityClass;\r\n\r\n    public GenericDao(Class<E> entityClass) {\r\n        this.entityClass = entityClass;\r\n    }\r\n\r\n    public List<E> findAll() {\r\n        // ...\r\n    }\r\n\r\n    public Optional<E> persist(E toPersist) {\r\n        // ...\r\n    }\r\n} \r\n```","```\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})\r\n@Documented\r\npublic @interface DataAccess {\r\n    Class<?> entity();\r\n}\r\n```","```\r\n@DataAccess(entity=Person.class)\r\nprivate GenericDao<Person> personDao;\r\n```","```\r\n@Component\r\npublic class DataAccessAnnotationProcessor implements BeanPostProcessor {\r\n\r\n    private ConfigurableListableBeanFactory configurableBeanFactory;\r\n\r\n    @Autowired\r\n    public DataAccessAnnotationProcessor(ConfigurableListableBeanFactory beanFactory) {\r\n        this.configurableBeanFactory = beanFactory;\r\n    }\r\n\r\n    @Override\r\n    public Object postProcessBeforeInitialization(Object bean, String beanName) \r\n      throws BeansException {\r\n        this.scanDataAccessAnnotation(bean, beanName);\r\n        return bean;\r\n    }\r\n\r\n    @Override\r\n    public Object postProcessAfterInitialization(Object bean, String beanName) \r\n      throws BeansException {\r\n        return bean;\r\n    }\r\n\r\n    protected void scanDataAccessAnnotation(Object bean, String beanName) {\r\n        this.configureFieldInjection(bean);\r\n    }\r\n\r\n    private void configureFieldInjection(Object bean) {\r\n        Class<?> managedBeanClass = bean.getClass();\r\n        FieldCallback fieldCallback = \r\n          new DataAccessFieldCallback(configurableBeanFactory, bean);\r\n        ReflectionUtils.doWithFields(managedBeanClass, fieldCallback);\r\n    }\r\n} \r\n```","```\r\npublic class DataAccessFieldCallback implements FieldCallback {\r\n    private static Logger logger = LoggerFactory.getLogger(DataAccessFieldCallback.class);\r\n\r\n    private static int AUTOWIRE_MODE = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;\r\n\r\n    private static String ERROR_ENTITY_VALUE_NOT_SAME = \"@DataAccess(entity) \"\r\n            + \"value should have same type with injected generic type.\";\r\n    private static String WARN_NON_GENERIC_VALUE = \"@DataAccess annotation assigned \"\r\n            + \"to raw (non-generic) declaration. This will make your code less type-safe.\";\r\n    private static String ERROR_CREATE_INSTANCE = \"Cannot create instance of \"\r\n            + \"type '{}' or instance creation is failed because: {}\";\r\n\r\n    private ConfigurableListableBeanFactory configurableBeanFactory;\r\n    private Object bean;\r\n\r\n    public DataAccessFieldCallback(ConfigurableListableBeanFactory bf, Object bean) {\r\n        configurableBeanFactory = bf;\r\n        this.bean = bean;\r\n    }\r\n\r\n    @Override\r\n    public void doWith(Field field) \r\n    throws IllegalArgumentException, IllegalAccessException {\r\n        if (!field.isAnnotationPresent(DataAccess.class)) {\r\n            return;\r\n        }\r\n        ReflectionUtils.makeAccessible(field);\r\n        Type fieldGenericType = field.getGenericType();\r\n        // In this example, get actual \"GenericDAO' type.\r\n        Class<?> generic = field.getType(); \r\n        Class<?> classValue = field.getDeclaredAnnotation(DataAccess.class).entity();\r\n\r\n        if (genericTypeIsValid(classValue, fieldGenericType)) {\r\n            String beanName = classValue.getSimpleName() + generic.getSimpleName();\r\n            Object beanInstance = getBeanInstance(beanName, generic, classValue);\r\n            field.set(bean, beanInstance);\r\n        } else {\r\n            throw new IllegalArgumentException(ERROR_ENTITY_VALUE_NOT_SAME);\r\n        }\r\n    }\r\n\r\n    public boolean genericTypeIsValid(Class<?> clazz, Type field) {\r\n        if (field instanceof ParameterizedType) {\r\n            ParameterizedType parameterizedType = (ParameterizedType) field;\r\n            Type type = parameterizedType.getActualTypeArguments()[0];\r\n\r\n            return type.equals(clazz);\r\n        } else {\r\n            logger.warn(WARN_NON_GENERIC_VALUE);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    public Object getBeanInstance(\r\n      String beanName, Class<?> genericClass, Class<?> paramClass) {\r\n        Object daoInstance = null;\r\n        if (!configurableBeanFactory.containsBean(beanName)) {\r\n            logger.info(\"Creating new DataAccess bean named '{}'.\", beanName);\r\n\r\n            Object toRegister = null;\r\n            try {\r\n                Constructor<?> ctr = genericClass.getConstructor(Class.class);\r\n                toRegister = ctr.newInstance(paramClass);\r\n            } catch (Exception e) {\r\n                logger.error(ERROR_CREATE_INSTANCE, genericClass.getTypeName(), e);\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n            daoInstance = configurableBeanFactory.initializeBean(toRegister, beanName);\r\n            configurableBeanFactory.autowireBeanProperties(daoInstance, AUTOWIRE_MODE, true);\r\n            configurableBeanFactory.registerSingleton(beanName, daoInstance);\r\n            logger.info(\"Bean named '{}' created successfully.\", beanName);\r\n        } else {\r\n            daoInstance = configurableBeanFactory.getBean(beanName);\r\n            logger.info(\r\n              \"Bean named '{}' already exists used as current bean reference.\", beanName);\r\n        }\r\n        return daoInstance;\r\n    }\r\n} \r\n```","```\r\ngenericDaoInstance = configurableBeanFactory.initializeBean(beanToRegister, beanName);\r\nconfigurableBeanFactory.autowireBeanProperties(genericDaoInstance, autowireMode, true);\r\nconfigurableBeanFactory.registerSingleton(beanName, genericDaoInstance); \r\n```","```\r\n@Configuration\r\n@ComponentScan(\"com.baeldung.springcustomannotation\")\r\npublic class CustomAnnotationConfiguration {} \r\n```","```\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n@ContextConfiguration(classes={CustomAnnotationConfiguration.class})\r\npublic class DataAccessAnnotationTest {\r\n\r\n    @DataAccess(entity=Person.class) \r\n    private GenericDao<Person> personGenericDao;\r\n    @DataAccess(entity=Account.class) \r\n    private GenericDao<Account> accountGenericDao;\r\n    @DataAccess(entity=Person.class) \r\n    private GenericDao<Person> anotherPersonGenericDao;\r\n\r\n    ...\r\n}\r\n```","```\r\n@Test\r\npublic void whenGenericDaoInjected_thenItIsSingleton() {\r\n    assertThat(personGenericDao, not(sameInstance(accountGenericDao)));\r\n    assertThat(personGenericDao, not(equalTo(accountGenericDao)));\r\n    assertThat(personGenericDao, sameInstance(anotherPersonGenericDao));\r\n}\r\n```","```\r\n@Test\r\npublic void whenFindAll_thenMessagesIsCorrect() {\r\n    personGenericDao.findAll();\r\n    assertThat(personGenericDao.getMessage(), \r\n      is(\"Would create findAll query from Person\"));\r\n\r\n    accountGenericDao.findAll();\r\n    assertThat(accountGenericDao.getMessage(), \r\n      is(\"Would create findAll query from Account\"));\r\n}\r\n\r\n@Test\r\npublic void whenPersist_thenMessagesIsCorrect() {\r\n    personGenericDao.persist(new Person());\r\n    assertThat(personGenericDao.getMessage(), \r\n      is(\"Would create persist query from Person\"));\r\n\r\n    accountGenericDao.persist(new Account());\r\n    assertThat(accountGenericDao.getMessage(), \r\n      is(\"Would create persist query from Account\"));\r\n} \r\n```"]