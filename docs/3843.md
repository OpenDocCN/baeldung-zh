# 用 Lombok 在 Spring 中注入构造函数

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-injection-lombok>

## **1。简介**

Lombok 是一个克服样板代码的非常有用的库。如果你还不熟悉，我强烈推荐你看一下之前的教程——[Lombok 项目简介](/web/20220807182517/https://www.baeldung.com/intro-to-project-lombok)。

在本文中，我们将展示它与 Spring 的`Constructor-Based Dependency Injection`结合使用时的可用性。

## **2。基于构造函数的依赖注入**

在 Spring 中使用 c `onstructor-based Dependency Injection`连接依赖关系的好方法。这种方法迫使我们将组件的依赖关系显式传递给构造函数。

与`Field-Based Dependency Injection`相反，它还提供了许多优势:

*   不需要创建特定于测试的配置组件——依赖项被显式地注入到构造函数中
*   一致的设计——所有必需的依赖性都被强调，并由构造者的定义来照顾
*   简单的单元测试——减少了 Spring 框架的开销
*   收回使用`final` 关键词的自由

然而，由于需要编写一个构造函数，它使用导致一个明显更大的代码库。考虑两个例子`GreetingService` 和`FarewellService:`

```
@Component
public class GreetingService {

    @Autowired
    private Translator translator;

    public String produce() {
        return translator.translate("hello");
    }
}
```

```
@Component
public class FarewellService {

    private final Translator translator;

    public FarewellService(Translator translator) {
        this.translator = translator;
    }

    public String produce() {
        return translator.translate("bye");
    }
}
```

基本上，这两个组件做同样的事情——它们用特定于任务的单词调用可配置的`Translator`。

然而，第二种变化更加混乱，因为构造函数的样板文件并没有真正给代码带来任何价值。

**在最新的 Spring 版本中，它的构造函数不需要用`@Autowired`注释。**

## **3。用 Lombok 注入构造函数**

使用`Lombok`，可以为所有类的字段(使用`@AllArgsConstructor`)或所有`final` 类的字段(使用`@RequiredArgsConstructor`)生成一个构造函数。此外，如果您仍然需要一个空的构造函数，您可以追加一个额外的`@NoArgsConstructor` 注释。

让我们创建第三个组件，类似于前两个组件:

```
@Component
@RequiredArgsConstructor
public class ThankingService {

    private final Translator translator;

    public String produce() {
        return translator.translate("thank you");
    }
}
```

上面的注释将导致`Lombok`为我们生成一个构造函数:

```
@Component
public class ThankingService {

    private final Translator translator;

    public String thank() {
        return translator.translate("thank you");
    }

    /* Generated by Lombok */
    public ThankingService(Translator translator) {
        this.translator = translator;
    }
}
```

### **4。多个构造函数**

只要组件中只有一个构造函数，构造函数就不必被注释，Spring 可以明确地选择它作为实例化新对象的正确构造函数。一旦有了更多，您还需要注释 IoC 容器要使用的那个。

考虑`ApologizeService` 的例子:

```
@Component
@RequiredArgsConstructor
public class ApologizeService {

    private final Translator translator;
    private final String message;

    @Autowired
    public ApologizeService(Translator translator) {
        this(translator, "sorry");
    }

    public String produce() {
        return translator.translate(message);
    }
}
```

上面的组件可选地配置有`message`字段，该字段在组件创建后不能改变(因此缺少`setter`)。因此，它要求我们提供两个构造函数——一个具有完整的配置，另一个具有隐含的默认的`message`值。

除非其中一个构造函数用`@Autowired`、`@Inject`或`@Resource`进行了注释，否则 Spring 将抛出一个错误:

```
Failed to instantiate [...]: No default constructor found;
```

如果我们想要注释`Lombok-`生成的构造函数，我们必须传递带有`@AllArgsConstructor`的`onConstructor`参数的注释:

```
@Component
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class ApologizeService {
    // ...
}
```

`onConstructor`参数接受要放在生成的构造函数上的一组注释(或者这个特定示例中的单个注释)。引入双下划线习语是因为向后兼容的问题。根据文件:

> 奇怪语法的原因是为了让这个特性在 javac 7 编译器中工作；`@__`类型是对实际上不存在的注释类型`__`(双下划线)的注释引用；这使得 javac 7 由于一个错误而延迟中止编译过程，因为注释处理器稍后可能会创建`__`类型。

## **5。总结**

在本教程中，我们展示了在增加样板代码方面，没有必要偏向基于字段的 DI 而不是基于构造函数的 DI。

多亏了 Lombok，可以在不影响运行时性能的情况下自动生成通用代码，将冗长晦涩的代码简化为使用单行注释。

教程中使用的代码可以从 GitHub 上的[处获得。](https://web.archive.org/web/20220807182517/https://github.com/eugenp/tutorials/tree/master/spring-core-4)