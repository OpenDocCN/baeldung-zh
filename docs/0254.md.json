["```\r\n@RestController\r\n@RequestMapping(\"/random\")\r\npublic class RandomController {\r\n\r\n    @GetMapping\r\n    Integer getRandom() {\r\n        return new Random().nextInt(50));\r\n    }\r\n} \r\n```","```\r\npublic class Concurrency {\r\n\r\n    public static final int MAX_CONCURRENT = 5;\r\n    static final AtomicInteger CONCURRENT_REQUESTS = new HashMap<>();\r\n\r\n    public static int protect(IntSupplier supplier) {\r\n        try {\r\n            if (CONCURRENT_REQUESTS.incrementAndGet() > MAX_CONCURRENT) {\r\n                throw new UnsupportedOperationException(\"max concurrent requests reached\");\r\n            }\r\n\r\n            TimeUnit.SECONDS.sleep(2);\r\n            return supplier.getAsInt();\r\n        } finally {\r\n            CONCURRENT_REQUESTS.decrementAndGet();\r\n        }\r\n    }\r\n}\r\n```","```\r\n@GetMapping\r\nInteger getRandom() {\r\n    return Concurrency.protect(() -> new Random().nextInt(50));\r\n}\r\n```","```\r\nFlux.range(1, n)\r\n  .flatMap(i -> {\r\n    // GET request\r\n  });\r\n```","```\r\npublic interface RandomConsumer {\r\n\r\n    static <T> Mono<T> get(WebClient client) {\r\n        return client.get()\r\n          .retrieve()\r\n          .bodyToMono(new ParameterizedTypeReference<T>() {});\r\n    }\r\n} \r\n```","```\r\npublic class ZipWithInterval {\r\n\r\n    public static Flux<Integer> fetch(\r\n      WebClient client, int requests, int delay) {\r\n        return Flux.range(1, requests)\r\n          .zipWith(Flux.interval(Duration.ofMillis(delay)))\r\n          .flatMap(i -> RandomConsumer.get(client));\r\n    }\r\n} \r\n```","```\r\npublic class DelayElements {\r\n\r\n    public static Flux<Integer> fetch(\r\n      WebClient client, int requests, int delay) {\r\n        return Flux.range(1, requests)\r\n          .delayElements(Duration.ofMillis(delay))\r\n          .flatMap(i -> RandomConsumer.get(client));\r\n    }\r\n} \r\n```","```\r\n@Test\r\nvoid givenSmallDelay_whenDelayElements_thenExceptionThrown() {\r\n    int delay = 100;\r\n\r\n    int requests = 10;\r\n    assertThrows(InternalServerError.class, () -> {\r\n      DelayElements.fetch(client, requests, delay)\r\n        .blockLast();\r\n    });\r\n}\r\n```","```\r\npublic class LimitConcurrency {\r\n\r\n    public static Flux<Integer> fetch(\r\n      WebClient client, int requests, int concurrency) {\r\n        return Flux.range(1, requests)\r\n          .flatMap(i -> RandomConsumer.get(client), concurrency);\r\n    }\r\n} \r\n```","```\r\n@Test\r\nvoid givenLimitInsideServerRange_whenLimitedConcurrency_thenNoExceptionThrown() {\r\n    int limit = Concurrency.MAX_CONCURRENT;\r\n\r\n    int requests = 10;\r\n    assertDoesNotThrow(() -> {\r\n      LimitConcurrency.fetch(client, TOTAL_REQUESTS, limit)\r\n        .blockLast();\r\n    });\r\n}\r\n```","```\r\n<dependency>\r\n    <groupId>io.github.resilience4j</groupId>\r\n    <artifactId>resilience4j-reactor</artifactId>\r\n    <version>1.7.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.github.resilience4j</groupId>\r\n    <artifactId>resilience4j-ratelimiter</artifactId>\r\n    <version>1.7.1</version>\r\n</dependency>\r\n```","```\r\npublic class Resilience4jRateLimit {\r\n\r\n    public static Flux<Integer> fetch(\r\n      WebClient client, int requests, int concurrency, int interval) {\r\n        RateLimiter limiter = RateLimiter.of(\"my-rate-limiter\", RateLimiterConfig.custom()\r\n          .limitRefreshPeriod(Duration.ofMillis(interval))\r\n          .limitForPeriod(concurrency)\r\n          .timeoutDuration(Duration.ofMillis(interval * concurrency))\r\n          .build());\r\n\r\n        // ...\r\n    }\r\n}\r\n```","```\r\nreturn Flux.range(1, requests)\r\n  .flatMap(i -> RandomConsumer.get(client)\r\n    .transformDeferred(RateLimiterOperator.of(limiter))\r\n  );\r\n```","```\r\n<dependency>\r\n    <groupId>com.google.guava</groupId>\r\n    <artifactId>guava</artifactId>\r\n    <version>31.1-jre</version>\r\n</dependency>\r\n```","```\r\npublic class GuavaRateLimit {\r\n\r\n    public static Flux<Integer> fetch(\r\n      WebClient client, int requests, int requestsPerSecond) {\r\n        RateLimiter limiter = RateLimiter.create(requestsPerSecond);\r\n\r\n        return Flux.range(1, requests)\r\n          .flatMap(i -> {\r\n            limiter.acquire();\r\n\r\n            return RandomConsumer.get(client);\r\n          });\r\n    }\r\n} \r\n```"]