# 识别和验证信用卡号的算法

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-validate-cc-number>

## 1.介绍

在本文中，我们将学习如何使用 [regex](https://web.archive.org/web/20221016150338/https://en.wikipedia.org/wiki/Regular_expression#Syntax) 从信用卡号中识别信用卡类型。

然后，我们将学习 [Luhn 算法](https://web.archive.org/web/20221016150338/https://en.wikipedia.org/wiki/Luhn_algorithm)以及我们如何使用它来检查信用卡号码是否有效。

## 2.一个卡号的前导数字告诉我们什么？

主要帐号(PAN)是信用卡号码的另一个名称。

**PAN 通常为 16 位数字长**，尽管位数可能因发卡机构而异。

目前，**发行人识别号(IIN)是 PAN** 的前六位数字。它由一个前导数字和五个数字组成。

重要的是要强调这是目前的情况，因为它可能会在未来发生变化。早在 2015 年就开始了将 IIN 提高到前八位的工作。

让我们看看如何通过查看 IIN 来确定信用卡的类型。

### 2.1.前导数字告诉我们什么？

**主要行业标识符是卡号的第一个数字。**

顾名思义，我们可以通过看卡号的第一位来判断该卡所属的行业:

*   1，2–航空公司(以及其他公司)
*   3–旅游和娱乐
*   4，5–银行业
*   6–零售和银行业务
*   7–燃料行业
*   8–医疗保健和电信
*   9–国家当局
*   0–其他，为将来保留

现在，让我们看看如何使用 IIN 识别发卡方。

### 2.2.我们如何从 IIN 中确定卡的类型？

自 1989 年以来，就有了一个国际标准来定义如何分配 pan。不公开研究所的官方登记册。

幸运的是，**大多数领先的发卡机构都有广为人知的 IIN 范围，因此我们可以使用 regex 将 IIN 与发卡机构**匹配起来。

在我们查看正则表达式之前，让我们记住**IIN 范围列表是不断变化的**。

如果我们正在编写一个应用程序来做这件事，我们将需要考虑我们计划如何使它保持最新。

或者，我们可以选择导入几个可用的开源库中的一个，这些库包含更多的卡类型，并且比我们自己能够管理的更彻底地测试。例如，使用[Stripe API](/web/20221016150338/https://www.baeldung.com/java-stripe-api)将意味着卡处理由我们管理。

### 2.3.使用正则表达式识别发卡方

让我们试着识别一张 Visa 卡。

Visa 卡号以 4 开头，所以识别 Visa 卡的简单正则表达式应该是`^4[0-9]{0,}$`。

注意，在我们的例子中，我们没有检查数字的长度。到目前为止，我们假设卡号是有效的，所以长度不是我们在这里验证的东西。

可以应用类似的模式来识别其他发卡方。例如，美国运通卡以 34 或 37 开头，因此我们可以使用`^3[47][0-9]{0,}$`来检测它们。

一些发卡机构的 IIN 范围更广。

我们发现万事达卡通常以 51-55 开始，然而，在过去十年中，他们推出了 BIN 范围为 222100-272099 的卡。

这给了我们一个正则表达式`^(5[1-5]|222[1-9]|22[3-9]|2[3-6]|27[01]|2720)[0-9]{0,}$`。

我们可以使用类似的模式来识别来自已知 iin 范围的任何发卡商的卡。

## 3.一个卡号的中间数字告诉我们什么？

完整的 PAN 由 3 部分组成:发行标识号(IIN)、个人账户标识号和校验和位。

在 IIN 和最后一位数字之间，我们有个人账户识别号。

发行者定义了这些中间数字的含义，因此它们在不同的发行者中有不同的含义。

它们表示与卡号相关的账户类型等信息。

## 4.卡号的最后一位数字告诉我们什么？

**校验和位是卡号的最后一位。**

有益的是，校验和数字允许我们使用 [Luhn 算法](https://web.archive.org/web/20221016150338/https://en.wikipedia.org/wiki/Luhn_algorithm)快速识别无效的卡号。

Hans Peter Luhn 在 20 世纪 50 年代后期开发了 Luhn 算法。

它被用来生成我们今天使用的每一个现代信用卡号码，确保每一个信用卡号码共享一个特定的属性。

**Luhn 算法使用卡号中的每一位数字**，这意味着我们可以使用它轻松确定给定的卡号何时无效——即使只有一位数字输入错误。

这样做意味着我们可以限制不必要的卡处理功能的数量。如果我们请求的每笔交易都要付费，这一点尤其重要！

让我们看看如何在 Java 应用程序中使用 Luhn 算法。

### 4.1.我们如何使用 Luhn 算法来验证卡号？

让我们浏览一下使用 Luhn 算法验证给定卡号的步骤。

我们需要完整的信用卡号码，包括 IIN。

从最右边的数字开始，我们将所有的数字加在一起，每隔一个数字执行一个特殊的步骤。

因为我们从右边开始，我们需要通过卡号向后循环，识别每第二个数字:

```java
for (int i = cardNumber.length() - 1; i >= 0; i--) {
    int digit = Integer.parseInt(cardNumber.substring(i, i + 1));

    if ((cardNumber.length() - i) % 2 == 0) {
        digit = doubleAndSumDigits(digit);
    }

    sum += digit;
}
```

对于每第二个数字，我们必须将其翻倍，然后将剩余的数字相加。

让我们看看这个 4 位数字(而不是通常的 16 位数字)的简短示例是如何工作的——让我们检查数字 8642 是否是有效的卡号。

从最右边的数字开始，我们将每隔一个数字加倍:

*   所以对于 2(右数第一位)，没有变化。
*   接下来，我们将第二个数字 4 加倍，得到 8。
*   在那之后，第三个数字，6，没有变化。
*   最后，我们将第四个数字 8 加倍，得到 16。

**如果将数字翻倍得到一个两位数，那么我们需要额外做一步回到一位数**——我们将把这些数字加在一起得到一个一位数，所以对于 16，这将是 1+6=7。

**这一步与减去 9** 相同，所以我们可以在代码中实现为:

```java
private static int doubleAndSumDigits(int digit) {
    int ret = digit * 2;

    if (ret > 9) {
        ret = digit - 9;
    }

    return ret;
} 
```

最后，为了完成我们的示例，让我们将每个数字相加:2 + 8 + 6 + 7 = 23。

**如果 Luhn 算法的结果能被 10 整除，那么卡号可能有效。**

我们将把这个作为我们检查的结果退回:

```java
return sum % 10 == 0;
```

在我们的例子中，23 不能被 10 整除，所以 8642 不是有效的卡号。

在我们的例子中，最后一个数字 2 是校验和数字。

对于真实的卡号，校验和位数是使用 Luhn 算法计算的。

例如，如果我们将校验和位数更改为 9 以得到 8649，则 Luhn 算法的结果是 30，可被 10 整除，因此 8649 将通过上面的 Luhn 检查。

### 4.2.Luhn 算法有什么局限性吗？

当然，我们的检查并不意味着 8649 一定是有效的卡号。虽然它通过了我们的检查，但它可能不是由相关发卡机构作为实际的卡发行的。

我们唯一能确定卡号是否真实的方法是询问发卡机构。

Luhn 算法仍然为我们提供了一种有用的方法来确认给定的卡号何时肯定是无效的。

然而，**在一些边缘情况下，我们的 Luhn 检查无法检测到卡号**中的输入错误。

幸运的是，这些边缘情况非常罕见，我们不太可能在现实生活中遇到。

最后，**Luhn 算法不考虑卡号的长度**。

事实上，我们知道即使 8649 通过了我们的 Luhn 检查，但它太短了，不可能是真正的信用卡号。

我们可以对卡号的长度进行额外的检查，但必须记住，每个发卡机构的卡号长度可能不同。

## 5.结论

在本文中，我们研究了卡号的每一部分可以告诉我们关于信用卡账户的什么信息。

首先，我们学习了如何通过匹配前导数字上的正则表达式模式来识别发卡方。接下来，我们看到我们需要特定于发行者的信息来理解卡号的中间部分告诉我们关于账户的什么信息。最后，我们研究了 Luhn 算法是如何工作的，并实现了一些代码来验证给定的卡号。

与往常一样，GitHub 上的示例项目[可用。](https://web.archive.org/web/20221016150338/https://github.com/eugenp/tutorials/tree/master/algorithms-modules/algorithms-miscellaneous-7)