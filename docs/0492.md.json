["```\r\n{ { 0, 6 }, { 1, 5, 10, 100 }, { 2, 4, 200, 650 } }\r\n```","```\r\n{ 0, 1, 2, 4, 5, 6, 10, 100, 200, 650 }\r\n```","```\r\npublic class HeapNode {\r\n\r\n    int element;\r\n    int arrayIndex;\r\n    int nextElementIndex = 1;\r\n\r\n    public HeapNode(int element, int arrayIndex) {\r\n        this.element = element;\r\n        this.arrayIndex = arrayIndex;\r\n    }\r\n}\r\n```","```\r\npublic class MinHeap {\r\n\r\n    HeapNode[] heapNodes;\r\n\r\n    public MinHeap(HeapNode heapNodes[]) {\r\n        this.heapNodes = heapNodes;\r\n        heapifyFromLastLeafsParent();\r\n    }\r\n\r\n    int getParentNodeIndex(int index) {\r\n        return (index - 1) / 2;\r\n    }\r\n\r\n    int getLeftNodeIndex(int index) {\r\n        return (2 * index + 1);\r\n    }\r\n\r\n    int getRightNodeIndex(int index) {\r\n        return (2 * index + 2);\r\n    }\r\n\r\n    HeapNode getRootNode() {\r\n        return heapNodes[0];\r\n    }\r\n\r\n    // additional implementation methods\r\n}\r\n```","```\r\nvoid heapify(int index) {\r\n    int leftNodeIndex = getLeftNodeIndex(index);\r\n    int rightNodeIndex = getRightNodeIndex(index);\r\n    int smallestElementIndex = index;\r\n    if (leftNodeIndex < heapNodes.length \r\n      && heapNodes[leftNodeIndex].element < heapNodes[index].element) {\r\n        smallestElementIndex = leftNodeIndex;\r\n    }\r\n    if (rightNodeIndex < heapNodes.length\r\n      && heapNodes[rightNodeIndex].element < heapNodes[smallestElementIndex].element) {\r\n        smallestElementIndex = rightNodeIndex;\r\n    }\r\n    if (smallestElementIndex != index) {\r\n        swap(index, smallestElementIndex);\r\n        heapify(smallestElementIndex);\r\n    }\r\n}\r\n```","```\r\nvoid heapifyFromLastLeafsParent() {\r\n    int lastLeafsParentIndex = getParentNodeIndex(heapNodes.length);\r\n    while (lastLeafsParentIndex >= 0) {\r\n        heapify(lastLeafsParentIndex);\r\n        lastLeafsParentIndex--;\r\n    }\r\n}\r\n```","```\r\nint[] merge(int[][] array) {\r\n    // transform input arrays\r\n    // run the minheap algorithm\r\n    // return the resulting array\r\n}\r\n```","```\r\nHeapNode[] heapNodes = new HeapNode[array.length];\r\nint resultingArraySize = 0;\r\n\r\nfor (int i = 0; i < array.length; i++) {\r\n    HeapNode node = new HeapNode(array[i][0], i);\r\n    heapNodes[i] = node;\r\n    resultingArraySize += array[i].length;\r\n}\r\n```","```\r\nMinHeap minHeap = new MinHeap(heapNodes);\r\nint[] resultingArray = new int[resultingArraySize];\r\n\r\nfor (int i = 0; i < resultingArraySize; i++) {\r\n    HeapNode root = minHeap.getRootNode();\r\n    resultingArray[i] = root.element;\r\n\r\n    if (root.nextElementIndex < array[root.arrayIndex].length) {\r\n        root.element = array[root.arrayIndex][root.nextElementIndex++];\r\n    } else {\r\n        root.element = Integer.MAX_VALUE;\r\n    }\r\n    minHeap.heapify(0);\r\n}\r\n```","```\r\nint[][] inputArray = { { 0, 6 }, { 1, 5, 10, 100 }, { 2, 4, 200, 650 } };\r\nint[] expectedArray = { 0, 1, 2, 4, 5, 6, 10, 100, 200, 650 };\r\n\r\nint[] resultArray = MinHeap.merge(inputArray);\r\n\r\nassertThat(resultArray.length, is(equalTo(10)));\r\nassertThat(resultArray, is(equalTo(expectedArray)));\r\n```"]