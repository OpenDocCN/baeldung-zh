# 杰克逊 vs Gson

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jackson-vs-gson>

## **1。简介**

在本文中，我们将比较用于将 JSON 数据序列化和反序列化为 Java 对象的 [Gson](https://web.archive.org/web/20221117184333/https://code.google.com/p/google-gson) 和[Jackson](https://web.archive.org/web/20221117184333/https://github.com/FasterXML/jackson)API，反之亦然。

Gson 和 Jackson 是为 Java 提供 JSON 数据绑定支持的完整库。每个都是积极开发的开源项目，提供对复杂数据类型的处理和对 Java 泛型的支持。

在大多数情况下，两个库都可以反序列化为一个实体，而无需修改实体类，这在开发人员无法访问实体源代码的情况下非常重要。

## **2。Gson Maven 依赖性**

[PRE0]

你可以在这里获得最新版本的 Gson [。](https://web.archive.org/web/20221117184333/https://search.maven.org/classic/#search|gav|1|g%3A%22com.google.code.gson%22%20AND%20a%3A%22gson%22)

## **3。Gson 序列化**

序列化将 Java 对象转换为 JSON 输出。考虑以下实体:

[PRE1]

### **3.1。简单序列化**

让我们从一个 Java 到 JSON 序列化的例子开始:

[PRE2]

这将导致:

[PRE3]

默认情况下:

*   所有属性都被序列化，因为它们没有`null`值
*   `dateOfBirth`字段用默认的 Gson 日期模式翻译
*   输出没有格式化，JSON 属性名对应于 Java 实体

### **3.2。自定义序列化**

使用自定义序列化程序允许我们修改标准行为。我们可以用 HTML 引入一个输出格式化程序，处理`null`值，从输出中排除属性，或者添加一个新的输出。

`ActorGsonSerializer` 修改`ActorGson`元素的 JSON 代码的生成:

[PRE4]

为了排除`director` 属性，`@Expose`注释用于我们想要考虑的属性:

[PRE5]

现在我们可以使用`GsonBuilder`类继续创建 Gson 对象:

[PRE6]

结果如下:

[PRE7]

请注意:

*   输出被格式化
*   一些属性名称被更改并包含 HTML
*   包含`null`值，省略`director` 字段
*   `Date`现在是`dd-MM-yyyy`格式
*   一个新的属性出现了—`N° Film`
*   从影记录是一个格式化的属性，不是默认的 JSON 列表

## **4。Gson 反序列化**

### **4.1。简单的反序列化**

反序列化将 JSON 输入转换成 Java 对象。为了说明输出，我们在两个实体类中都实现了`toString()`方法:

[PRE8]

然后，我们利用序列化的 JSON 并通过标准的 Gson 反序列化来运行它:

[PRE9]

输出是我们的实体，其中填充了来自 JSON 输入的数据:

[PRE10]

与简单序列化程序的情况一样:

*   JSON 输入名必须与 Java 实体名一致，否则它们将被设置为 null。
*   `dateOfBirth`字段用默认的 Gson 日期模式翻译，忽略了时区。

### **4.2。自定义反序列化**

使用定制的反序列化器允许我们修改标准的反序列化行为。在这种情况下，我们希望日期反映出`dateOfBirth`的正确时区。我们在`ActorGson`实体上使用一个定制的`ActorGsonDeserializer`来实现这一点:

[PRE11]

我们使用了一个`SimpleDateFormat`解析器来解析输入的日期，考虑到了时区。

注意，我们可以决定只为日期编写一个定制的反序列化器，但是`ActorGsonDeserializer`提供了反序列化过程的更详细的视图。

还要注意，Gson 方法不需要修改`ActorGson` 实体，这是理想的，因为我们可能不总是能够访问输入实体。我们在这里使用定制的反序列化器:

[PRE12]

输出类似于简单的反序列化器结果，只是日期使用了正确的时区:

[PRE13]

## **5。杰克逊 Maven 依赖**

[PRE14]

你可以在这里得到杰克逊的最新版本。

## **6。杰克逊连载**

### **6.1。简单序列化**

在这里，我们将使用 Jackson 获得与 Gson 相同的序列化内容，使用以下实体。请注意，实体的 getter/setter 必须是公共的:

[PRE15]

输出如下所示:

[PRE16]

一些有趣的注意事项:

*   是我们的 Jackson 串行器/解串器
*   输出 JSON 未格式化
*   默认情况下，Java 日期被转换为`long` 值

### 6.2。自定义序列化

我们可以通过为我们的实体扩展 StdSerializer 来创建一个用于生成`ActorJackson`元素的 Jackson serializer。再次注意，实体 getter/setter 必须是公共的:

[PRE17]

我们创建一个电影实体来允许忽略`director`字段:

[PRE18]

现在我们可以继续进行自定义`ObjectMapper` 创建和设置:

[PRE19]

输出是格式化的 JSON，它处理`null`值、格式化日期、排除`director`字段并显示`N°`的新输出:

[PRE20]

## 7 .**。杰克逊反序列化**

### 7.1。简单的反序列化

为了说明输出，我们在两个 Jackson 实体类中实现了`toString()`方法:

[PRE21]

然后我们利用序列化的 JSON 并通过 Jackson 反序列化运行它:

[PRE22]

输出是我们的实体，其中填充了来自 JSON 输入的数据:

[PRE23]

与简单序列化程序的情况一样:

*   JSON 输入名必须与 Java 实体名一致，否则它们被设置为`null,`
*   `dateOfBirth`字段用默认的杰克逊日期模式翻译，忽略了时区。

### 7.2。自定义反序列化

使用定制的反序列化器允许我们修改标准的反序列化行为。

在这种情况下，我们希望日期能够反映出`dateOfBirth,` 的正确时区，因此我们为 Jackson `ObjectMapper`添加了一个 DateFormatter:

[PRE24]

输出反映了正确的时区和日期:

[PRE25]

这种解决方案简单明了。

或者，我们可以为`ActorJackson` 类创建一个定制的反序列化器，用我们的`ObjectMapper`注册这个模块，并使用`ActorJackson` 实体上的`@JsonDeserialize`注释反序列化日期。

这种方法的缺点是需要修改实体，这对于我们无法访问输入实体类的情况可能不太理想。

## **8。结论**

Gson 和 Jackson 都是序列化/反序列化 JSON 数据的好选择，使用简单，并且有很好的文档记录。

Gson 的优势:

*   简单情况下`toJson` / `fromJson`的简单性
*   对于反序列化，不需要访问 Java 实体

杰克逊的优点:

*   内置于所有 JAX-RS (Jersey、Apache CXF、RESTEasy、Restlet)和 Spring 框架中
*   广泛的注释支持

你可以在 GitHub 上找到 [Gson](https://web.archive.org/web/20221117184333/https://github.com/eugenp/tutorials/tree/master/json-modules/gson) 和 [Jackson](https://web.archive.org/web/20221117184333/https://github.com/eugenp/tutorials/tree/master/jackson-modules/jackson-core) 的代码。