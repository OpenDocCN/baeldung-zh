# 通过 Spring Security OAuth 使用 JWT

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-security-oauth-jwt>

## **1。概述**

在本教程中，我们将讨论如何让我们的 Spring Security OAuth2 实现利用 JSON Web 令牌。

我们还将继续构建 OAuth 系列中的[Spring REST API+OAuth 2+Angular](/web/20221126233349/https://www.baeldung.com/rest-api-spring-oauth2-angular)文章。

## 延伸阅读:

## [在 OAuth 安全应用程序中注销](/web/20221126233349/https://www.baeldung.com/logout-spring-security-oauth)

A practical deep-dive into how to implement logout in a Spring Security OAuth2 application with JWT.[Read more](/web/20221126233349/https://www.baeldung.com/logout-spring-security-oauth) →

## [OAuth2 用刷新令牌记住我(使用 Spring Security OAuth 传统堆栈)](/web/20221126233349/https://www.baeldung.com/spring-security-oauth2-remember-me)

Learn how to implement remember-me functionality with an Angular frontend, for an application secured with Spring Security OAuth.[Read more](/web/20221126233349/https://www.baeldung.com/spring-security-oauth2-remember-me) →

## [用于 Spring REST API 的 OAuth2 处理 Angular 中的刷新令牌](/web/20221126233349/https://www.baeldung.com/spring-security-oauth2-refresh-token-angular)

Have a look at how to refresh a token using the Spring Security 5 OAuth stack and leveraging a Zuul proxy.[Read more](/web/20221126233349/https://www.baeldung.com/spring-security-oauth2-refresh-token-angular) →

## 2.OAuth2 授权服务器

以前，Spring Security OAuth 堆栈提供了将授权服务器设置为 Spring 应用程序的可能性。然后我们必须将其配置为使用`JwtTokenStore` ，这样我们就可以使用 JWT 令牌。

然而，OAuth 栈已经被 Spring 弃用，现在我们将使用 Keycloak 作为我们的授权服务器。

**所以这一次，我们将把我们的授权服务器设置为[一个 Spring Boot 应用](/web/20221126233349/https://www.baeldung.com/keycloak-embedded-in-a-spring-boot-application)** 中的嵌入式 Keycloak 服务器。默认情况下，它颁发 JWT 令牌，因此在这方面不需要任何其他配置。

## 3.资源服务器

现在让我们看看如何配置我们的资源服务器来使用 JWT。

我们将在一个`application.yml`文件中这样做:

[PRE0]

jwt 包含了令牌内 的所有信息，因此资源服务器需要 验证令牌的签名 以确保数据没有被修改。**`jwk-set-uri`属性** **包含服务器可用于此目的的公钥****。**

 **`issuer-uri`属性指向基础授权服务器 URI，作为一种附加的安全措施，它也可以用来验证`iss`声明。

此外，如果没有设置`jwk-set-uri`属性，资源服务器将尝试使用`issuer-uri`从[授权服务器元数据端点](https://web.archive.org/web/20221126233349/https://tools.ietf.org/html/rfc8414#section-3)中确定这个键的位置。

值得注意的是，添加属性`issuer-uri`要求**在启动资源服务器应用程序**之前，我们应该运行授权服务器。

现在让我们看看如何使用 Java 配置来配置 JWT 支持:

[PRE1]

这里我们覆盖了默认的 Http 安全配置；我们需要明确指定**我们希望它作为一个资源服务器，并且我们将分别使用方法`oauth2ResourceServer()`和`jwt()`、**来使用 JWT 格式的访问令牌。

上面的 JWT 配置是默认的 Spring Boot 实例提供给我们的。我们很快就会看到，这也可以定制。

## 4.令牌中的自定义声明

现在让我们建立一些基础设施，以便能够在授权服务器返回的访问令牌中添加一些**自定义声明。框架提供的标准声明都很好，但是大多数时候我们需要令牌中的一些额外信息，以便在客户端使用。**

让我们以自定义声明`organization`为例，它将包含给定用户的组织名称。

### 4.1.授权服务器配置

为此，我们需要在我们的领域定义文件中添加一些配置，`baeldung-realm.json`:

*   给我们的用户`[[email protected]](/web/20221126233349/https://www.baeldung.com/cdn-cgi/l/email-protection)`添加一个属性`organization`:

    [PRE2]

*   在`jwtClient`配置:

    [PRE3]

    中添加一个名为*的`protocolMapper`组织*

对于独立的 Keycloak 设置，也可以使用管理控制台来完成。

重要的是要记住**上面的 JSON 配置是特定于 Keycloak 的，对于其他 OAuth 服务器**可能会有所不同。

随着这个新配置的启动和运行，我们将在`[[email protected]](/web/20221126233349/https://www.baeldung.com/cdn-cgi/l/email-protection)`的令牌有效负载中获得一个额外的属性`organization = baeldung`:

[PRE4]

### 4.2.在 Angular 客户端中使用访问令牌

接下来，我们希望在我们的 Angular 客户端应用程序中使用令牌信息。为此，我们将使用 [angular2-jwt](https://web.archive.org/web/20221126233349/https://github.com/auth0/angular2-jwt) 库。

我们将在`AppService`中使用`organization`声明，并添加一个函数`getOrganization`:

[PRE5]

这个函数利用来自`angular2-jwt`库中的`JwtHelperService`来解码访问令牌并获得我们的自定义声明。现在我们需要做的就是把它显示在我们的`AppComponent`中:

[PRE6]

## 5.访问资源服务器中的额外声明

但是我们如何在资源服务器端访问这些信息呢？

### 5.1.访问身份验证服务器声明

这真的很简单，我们只需要从`org.springframework.security.oauth2.jwt.Jwt`的的`**AuthenticationPrincipal,** `中提取它，就像我们对`UserInfoController`中的任何其他属性所做的那样:

[PRE7]

### 5.2.添加/删除/重命名声明的配置

现在，如果我们想在资源服务器端添加更多的声明，该怎么办呢？或者删除或重命名一些？

假设我们想要修改来自认证服务器的`organization`声明，以获得大写的值。但是，如果用户没有该声明，我们需要将其值设置为`unknown`。

为了实现这一点，我们必须**添加一个实现`Converter`接口并使用`MappedJwtClaimSetConverter` 转换声明**的类:

[PRE8]

然后，在我们的`SecurityConfig`类中，我们需要**添加我们自己的 *JwtDecoder* 实例**来覆盖 Spring Boot **提供的实例，并将我们的`OrganizationSubClaimAdapter`设置为它的声明转换器**:

[PRE9]

现在，当我们为用户`[[email protected]](/web/20221126233349/https://www.baeldung.com/cdn-cgi/l/email-protection)`点击我们的`/user/info` API 时，我们将得到作为`UNKNOWN`的`organization`。

请注意，覆盖由 Spring Boot 配置的默认`JwtDecoder` bean 应该非常小心，以确保仍然包含所有必要的配置。

## 6.从 Java 密钥库中加载密钥

在我们之前的配置中，我们使用授权服务器的默认公钥来验证令牌的完整性。

我们还可以使用存储在 Java Keystore 文件中的密钥对和证书来完成签名过程。

### 6.1.生成 JKS Java 密钥库文件

让我们首先使用命令行工具:生成密钥，更具体地说是一个`.jks`文件

[PRE10]

该命令将生成一个名为`mytest.jks`的文件，其中包含我们的密钥、公钥和私钥。

还要确保`keypass`和`storepass`相同。

### 6.2.导出公钥

接下来，我们需要从生成的 JKS 中导出我们的公钥。我们可以使用下面的命令来做到这一点:

[PRE11]

示例响应如下所示:

[PRE12]

### 6.3.Maven 配置

我们不希望 JKS 文件被 maven 过滤过程拾取，所以我们将确保在`pom.xml`中排除它:

[PRE13]

如果我们使用 Spring Boot，我们需要确保我们的 JKS 文件通过 Spring Boot Maven 插件`addResources`被添加到应用程序类路径中:

[PRE14]

### 6.4.授权服务器

现在，我们将配置 Keycloak 来使用来自`mytest.jks`的 Keypair，方法是将它添加到领域定义 JSON 文件的`KeyProvider`部分，如下所示:

[PRE15]

这里我们将`priority`设置为`101`，大于授权服务器的任何其他密钥对，并将`active`设置为`true`。这样做是为了确保我们的资源服务器将从我们之前指定的`jwk-set-uri`属性中挑选这个特殊的 Keypair。

同样，这个配置是特定于 Keycloak 的，对于其他 OAuth 服务器实现可能有所不同。

## 7.结论

在这篇简短的文章中，我们重点介绍了如何设置 Spring Security OAuth2 项目来使用 JSON Web 令牌。

这篇文章的完整实现可以在 GitHub 上找到[。](https://web.archive.org/web/20221126233349/https://github.com/Baeldung/spring-security-oauth/tree/master/oauth-jwt "The Full Registration/Authentication Example Project on Github ")**