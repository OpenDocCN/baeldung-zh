["```\r\nT[] elements = new T[size];\r\n```","```\r\npublic <T> T[] getArray(int size) {\r\n    T[] genericArray = new T[size]; // suppose this is allowed\r\n    return genericArray;\r\n}\r\n```","```\r\npublic Object[] getArray(int size) {\r\n    Object[] genericArray = new Object[size];\r\n    return genericArray;\r\n}\r\n```","```\r\nString[] myArray = getArray(5);\r\n```","```\r\nprivate E[] elements;\r\n```","```\r\npublic MyStack(Class<E> clazz, int capacity) {\r\n    elements = (E[]) Array.newInstance(clazz, capacity);\r\n}\r\n```","```\r\nprivate List<E> elements;\r\n```","```\r\nelements = new ArrayList<>(capacity);\r\n```","```\r\ntransient Object[] elementData;\r\n```","```\r\nList<String> items = new LinkedList();\r\nitems.add(\"first item\");\r\nitems.add(\"second item\"); \r\n```","```\r\nString[] itemsAsArray = items.toArray(new String[0]);\r\n```","```\r\npublic <T> T[] toArray(T[] a)\r\n```","```\r\na = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);\r\n```","```\r\nObject[] strings = Stream.of(\"A\", \"AAA\", \"B\", \"AAB\", \"C\")\r\n  .filter(string -> string.startsWith(\"A\"))\r\n  .toArray();\r\n\r\nassertThat(strings).containsExactly(\"A\", \"AAA\", \"AAB\"); \r\n```","```\r\nassertThat(strings).isNotInstanceOf(String[].class);\r\n```","```\r\nString[] strings = Stream.of(\"A\", \"AAA\", \"B\", \"AAB\", \"C\")\r\n  .filter(string -> string.startsWith(\"A\"))\r\n  .toArray(String[]::new);\r\n\r\nassertThat(strings).containsExactly(\"A\", \"AAA\", \"AAB\");\r\nassertThat(strings).isInstanceOf(String[].class);\r\n```","```\r\nOptional<String>[] strings = null;\r\n```","```\r\nStream<Optional<String>> stream = Stream.of(\"A\", \"AAA\", \"B\", \"AAB\", \"C\")\r\n  .filter(string -> string.startsWith(\"A\"))\r\n  .map(Optional::of);\r\n```","```\r\n// compiler error\r\nOptional<String>[] strings = new Optional<String>[1];\r\n```","```\r\nStream<Optional<String>> stream = Stream.of(\"A\", \"AAA\", \"B\", \"AAB\", \"C\")\r\n  .filter(string -> string.startsWith(\"A\"))\r\n  .map(Optional::of);\r\nOptional<String>[] strings = stream\r\n  .toArray(Optional[]::new);\r\n```","```\r\n@SuppressWarnings(\"unchecked\")\r\n```","```\r\n@SuppressWarnings(\"unchecked\")\r\nstatic <T, R extends T> IntFunction<R[]> genericArray(IntFunction<T[]> arrayCreator) {\r\n    return size -> (R[]) arrayCreator.apply(size);\r\n}\r\n```","```\r\nOptional<String>[] strings = Stream.of(\"A\", \"AAA\", \"B\", \"AAB\", \"C\")\r\n  .filter(string -> string.startsWith(\"A\"))\r\n  .map(Optional::of)\r\n  .toArray(genericArray(Optional[]::new));\r\n```","```\r\nArrayList<String>[] lists = Stream.of(singletonList(\"A\"))\r\n  .toArray(genericArray(List[]::new));\r\n```"]