# 设计用户友好的 Java 库

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/design-a-user-friendly-java-library>

## 1.概观

Java 是开源世界的支柱之一。几乎每个 Java 项目都使用其他开源项目，因为没有人想重新发明轮子。然而，很多时候我们需要一个功能库，但是我们不知道如何使用它。我们会遇到这样的事情:

*   这些“*服务”类是怎么回事？
*   我如何实例化它，它需要太多的依赖。什么是“`latch`”？
*   哦，我把它放在一起，但现在它开始扔`IllegalStateException`。我做错了什么？

问题是，并不是所有的图书馆设计者都考虑他们的用户。大多数人只考虑功能和特性，但很少有人考虑 API 在实践中如何使用，以及用户的代码看起来和测试起来如何。

这篇文章提供了一些建议，告诉我们如何为用户省去这些麻烦——不，不是通过写文档。当然，关于这个主题可以写一整本书(有几本已经写了)；这些是我自己在几个库上工作时学到的一些要点。

我将使用两个库来举例说明这些想法: [charles](https://web.archive.org/web/20220117213420/https://www.github.com/opencharles/charles) 和 [jcabi-github](https://web.archive.org/web/20220117213420/https://www.github.com/jcabi/jcabi-github)

## 2.边界

这应该是显而易见的，但很多时候并非如此。在开始写任何一行代码之前，我们需要对一些问题有一个明确的答案:需要哪些输入？我的用户将看到的第一个类是什么？我们需要用户的任何实现吗？产量是多少？一旦清楚地回答了这些问题，一切都变得容易了，因为图书馆已经有了一个衬里，一个形状。

### 2.1。输入

这可能是最重要的话题。我们必须确保清楚用户需要向图书馆提供什么，以使其完成工作。在某些情况下，这是一件非常微不足道的事情:它可能只是一个表示 API 的 auth 令牌的字符串，但也可能是一个接口的实现，或者是一个抽象类。

一个非常好的实践是通过构造函数获取所有的依赖关系，并保持这些依赖关系简短，只有几个参数。如果我们需要一个多于三个或四个参数的构造函数，那么代码显然应该被重构。如果方法被用来注入强制性的依赖，那么用户很可能会以概述中描述的第三个挫折而告终。

此外，我们应该总是提供一个以上的构造函数，给用户选择。让他们同时与`String`和`Integer`一起工作，或者不要把他们限制在一个`FileInputStream`，与一个`InputStream`一起工作，这样他们可以在单元测试时提交可能的`ByteArrayInputStream`等等。

例如，下面是我们可以使用 jcabi-github 实例化 Github API 入口点的几种方法:

```java
Github noauth = new RtGithub();
Github basicauth = new RtGithub("username", "password");
Github oauth = new RtGithub("token"); 
```

简单，没有拥挤，没有可疑的配置对象初始化。拥有这三个构造函数是有意义的，因为你可以在注销、登录或应用程序代表你进行身份验证时使用 Github 网站。当然，如果您没有经过身份验证，一些功能将无法工作，但是您从一开始就知道这一点。

作为第二个例子，下面是我们如何使用 charles，一个网络爬行库:

```java
WebDriver driver = new FirefoxDriver();
Repository repo = new InMemoryRepository();
String indexPage = "http://www.amihaiemil.com/index.html";
WebCrawl graph = new GraphCrawl(
  indexPage, driver, new IgnoredPatterns(), repo
);
graph.crawl(); 
```

我相信这也是不言自明的。然而，在写这篇文章的时候，我意识到在当前版本中有一个错误:所有的构造函数都要求用户提供一个`IgnoredPatterns`的实例。默认情况下，不应忽略任何模式，但用户不必指定这一点。我决定把它放在这里，所以你会看到一个反例。我假设您会尝试实例化一个 WebCrawl，并想知道“这个`IgnoredPatterns`是怎么回事？!"

变量 indexPage 是应该开始爬行的 URL，driver 是要使用的浏览器(不能默认为任何东西，因为我们不知道运行的机器上安装了哪个浏览器)。回购变量将在下一节解释。

所以，正如你在例子中看到的，尽量保持简单、直观和不言自明。以这样一种方式封装逻辑和依赖关系，使得用户在看你的构造函数时不会挠头。

如果您仍然有疑问，请尝试使用 [aws-sdk-java](https://web.archive.org/web/20220117213420/https://github.com/aws/aws-sdk-java) 向 AWS 发出 HTTP 请求:您将不得不处理一个所谓的 AmazonHttpClient，它在某处使用 ClientConfiguration，然后需要在两者之间的某处获取 ExecutionContext。最后，您可能会执行您的请求并得到响应，但是仍然不知道 ExecutionContext 是什么。

### 2.2。输出

这主要是为了与外界交流的图书馆。这里我们应该回答“输出将如何处理？”。再次，一个相当搞笑的问题，但是很容易走错一步。

再看看上面的代码。为什么我们必须提供存储库实现？为什么 WebCrawl.crawl()方法不直接返回网页元素列表？处理被抓取的网页显然不是图书馆的工作。它怎么知道我们想用它们做什么？大概是这样的:

```java
WebCrawl graph = new GraphCrawl(...);
List<WebPage> pages = graph.crawl(); 
```

没有比这更糟的了。比方说，如果被抓取的站点碰巧有 1000 个页面——库将它们全部加载到内存中，内存不足异常可能会突然发生。对此有两种解决方案:

*   继续返回页面，但是实现一些分页机制，其中用户必须提供起始和结束编号。或者
*   要求用户用一个叫做`export(List <webpage>)`的方法实现一个接口，每当达到最大页数时，算法就会调用这个接口

到目前为止，第二种选择是最好的；它使双方的事情变得更简单，并且更容易测试。想想看，如果我们采用第一种方法，需要在用户端实现多少逻辑。就像这样，指定了页面的存储库(将它们发送到数据库中，或者可能将它们写在磁盘上)，在调用方法 crawl()之后，不需要做任何其他事情。

顺便说一下，上面输入部分的代码是我们为了获取网站内容而必须编写的所有内容(正如 repo 实现所说，仍然在内存中，但这是我们的选择——我们提供了该实现，所以我们要承担风险)。

总结这一部分:我们永远不应该把我们的工作和客户的工作完全分开。我们应该经常思考我们创造的产出会发生什么。就像卡车司机应该帮助打开货物包装，而不是在到达目的地后简单地扔掉。

## 3.接口

总是使用接口。用户应该只通过严格的契约与我们的代码进行交互。

例如，在`jcabi-github`库中，RtGithub 类是用户实际看到的唯一一个类:

```java
Repo repo = new RtGithub("oauth_token").repos().get(
  new Coordinates.Simple("eugenp/tutorials"));
Issue issue = repo.issues()
  .create("Example issue", "Created with jcabi-github");
```

上面的代码片段在 [eugenp/tutorials repo](https://web.archive.org/web/20220117213420/https://github.com/eugenp/tutorials) 中创建了一个票据。使用了回购和发行的实例，但实际类型从未透露。我们不能这样做:

```java
Repo repo = new RtRepo(...)
```

从逻辑上讲，这是不可能的:我们不能在 Github repo 中直接创建问题，不是吗？首先，我们必须登录，然后搜索回购，只有这样我们才能创建一个问题。当然，上面的场景是可以允许的，但是用户的代码会被大量的样板代码污染:那个`RtRepo`可能必须通过它的构造函数获取某种授权对象，授权客户端并获得正确的回购等。

接口还提供了易扩展性和向后兼容性。一方面，作为开发人员，我们必须尊重已经发布的契约，另一方面，用户可以扩展我们提供的接口——他可以修饰它们或编写替代实现。

换句话说，尽可能地抽象和封装。通过使用接口，我们可以以一种优雅且不受限制的方式做到这一点——我们实施架构规则，同时给程序员自由来增强或改变我们公开的行为。

最后，请记住:我们的图书馆，我们的规则。我们应该确切地知道客户的代码将会是什么样子，以及他将如何对它进行单元测试。如果我们不知道这一点，那么没有人会知道，我们的库将只是创建难以理解和维护的代码。

## 4.第三方

请记住，好的库是轻量级的库。您的代码可能解决了一个问题并且是有效的，但是如果 jar 为我的构建增加了 10 MB，那么很明显您很久以前就丢失了项目的蓝图。如果你需要大量的依赖项，你可能试图覆盖太多的功能，应该将项目分成多个更小的项目。

尽可能透明，尽可能不要绑定到实际的实现。我想到的最好的例子是:使用 SLF4J，它只是一个用于日志记录的 API 不要直接使用 log4j，也许用户会喜欢使用其他日志程序。

文档库通过您的项目传递，并确保您不包含危险的依赖项，如`xalan`或`xml-apis`(为什么它们是危险的不是本文要详细阐述的)。

这里的底线是:保持你的构建轻巧、透明，并且永远知道你在做什么。它可以让你的用户比你想象的更加忙碌。

## 5.结论

这篇文章概述了一些简单的想法，可以帮助项目保持可用性。一个库，作为一个组件，应该在一个更大的环境中找到它的位置，应该在功能上是强大的，同时提供一个平滑和精心制作的界面。

这是一个简单的越线步骤，把设计搞得一团糟。贡献者总是知道如何使用它，但是第一次看到它的人可能不知道。生产力是最重要的，遵循这个原则，用户应该能够在几分钟内开始使用一个库。