# Spring REST API + OAuth2 + Angular(使用 Spring Security OAuth 遗留堆栈)

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/rest-api-spring-oauth2-angular-legacy>

## **1。概述**

在本教程中，我们将使用 OAuth 保护 REST API，并从一个简单的 Angular 客户端使用它。

我们将要构建的应用程序将由四个独立的模块组成:

*   授权服务器
*   资源服务器
*   UI Implicit–使用隐式流的前端应用程序
*   UI 密码–使用密码流的前端应用程序

**注**:本文使用的是 [Spring OAuth 遗留项目](https://web.archive.org/web/20220707143817/https://spring.io/projects/spring-security-oauth)。对于这篇文章使用新的 Spring Security 5 堆栈的版本，看看我们的文章[Spring REST API+oauth 2+Angular](/web/20220707143817/https://www.baeldung.com/rest-api-spring-oauth2-angular)。

好吧，让我们开始吧。

## **2。授权服务器**

首先，让我们开始将授权服务器设置为一个简单的 Spring Boot 应用程序。

### **2.1。Maven 配置**

我们将设置以下依赖关系集:

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>    
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>  
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.security.oauth</groupId>
    <artifactId>spring-security-oauth2</artifactId>
</dependency>
```

注意，我们使用 spring-jdbc 和 MySQL，因为我们将使用 jdbc 支持的令牌存储实现。

### **2.2。`@EnableAuthorizationServer`**

现在，让我们开始配置负责管理访问令牌的授权服务器:

```
@Configuration
@EnableAuthorizationServer
public class AuthServerOAuth2Config
  extends AuthorizationServerConfigurerAdapter {

    @Autowired
    @Qualifier("authenticationManagerBean")
    private AuthenticationManager authenticationManager;

    @Override
    public void configure(
      AuthorizationServerSecurityConfigurer oauthServer) 
      throws Exception {
        oauthServer
          .tokenKeyAccess("permitAll()")
          .checkTokenAccess("isAuthenticated()");
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) 
      throws Exception {
        clients.jdbc(dataSource())
          .withClient("sampleClientId")
          .authorizedGrantTypes("implicit")
          .scopes("read")
          .autoApprove(true)
          .and()
          .withClient("clientIdPassword")
          .secret("secret")
          .authorizedGrantTypes(
            "password","authorization_code", "refresh_token")
          .scopes("read");
    }

    @Override
    public void configure(
      AuthorizationServerEndpointsConfigurer endpoints) 
      throws Exception {

        endpoints
          .tokenStore(tokenStore())
          .authenticationManager(authenticationManager);
    }

    @Bean
    public TokenStore tokenStore() {
        return new JdbcTokenStore(dataSource());
    }
}
```

请注意:

*   为了持久化令牌，我们使用了一个`JdbcTokenStore`
*   我们为“`implicit`”授权类型注册了一个客户端
*   我们注册了另一个客户，并授权了“`password`”、“`authorization_code`”和“`refresh_token`”授权类型
*   为了使用"`password`"授权类型，我们需要连接并使用`AuthenticationManager` bean

### **2.3。数据源配置**

接下来，让我们配置我们的数据源供`JdbcTokenStore`使用:

```
@Value("classpath:schema.sql")
private Resource schemaScript;

@Bean
public DataSourceInitializer dataSourceInitializer(DataSource dataSource) {
    DataSourceInitializer initializer = new DataSourceInitializer();
    initializer.setDataSource(dataSource);
    initializer.setDatabasePopulator(databasePopulator());
    return initializer;
}

private DatabasePopulator databasePopulator() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScript(schemaScript);
    return populator;
}

@Bean
public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(env.getProperty("jdbc.driverClassName"));
    dataSource.setUrl(env.getProperty("jdbc.url"));
    dataSource.setUsername(env.getProperty("jdbc.user"));
    dataSource.setPassword(env.getProperty("jdbc.pass"));
    return dataSource;
}
```

注意，由于我们使用了`JdbcTokenStore`，我们需要初始化数据库模式，所以我们使用了`DataSourceInitializer`和下面的 SQL 模式:

```
drop table if exists oauth_client_details;
create table oauth_client_details (
  client_id VARCHAR(255) PRIMARY KEY,
  resource_ids VARCHAR(255),
  client_secret VARCHAR(255),
  scope VARCHAR(255),
  authorized_grant_types VARCHAR(255),
  web_server_redirect_uri VARCHAR(255),
  authorities VARCHAR(255),
  access_token_validity INTEGER,
  refresh_token_validity INTEGER,
  additional_information VARCHAR(4096),
  autoapprove VARCHAR(255)
);

drop table if exists oauth_client_token;
create table oauth_client_token (
  token_id VARCHAR(255),
  token LONG VARBINARY,
  authentication_id VARCHAR(255) PRIMARY KEY,
  user_name VARCHAR(255),
  client_id VARCHAR(255)
);

drop table if exists oauth_access_token;
create table oauth_access_token (
  token_id VARCHAR(255),
  token LONG VARBINARY,
  authentication_id VARCHAR(255) PRIMARY KEY,
  user_name VARCHAR(255),
  client_id VARCHAR(255),
  authentication LONG VARBINARY,
  refresh_token VARCHAR(255)
);

drop table if exists oauth_refresh_token;
create table oauth_refresh_token (
  token_id VARCHAR(255),
  token LONG VARBINARY,
  authentication LONG VARBINARY
);

drop table if exists oauth_code;
create table oauth_code (
  code VARCHAR(255), authentication LONG VARBINARY
);

drop table if exists oauth_approvals;
create table oauth_approvals (
	userId VARCHAR(255),
	clientId VARCHAR(255),
	scope VARCHAR(255),
	status VARCHAR(10),
	expiresAt TIMESTAMP,
	lastModifiedAt TIMESTAMP
);

drop table if exists ClientDetails;
create table ClientDetails (
  appId VARCHAR(255) PRIMARY KEY,
  resourceIds VARCHAR(255),
  appSecret VARCHAR(255),
  scope VARCHAR(255),
  grantTypes VARCHAR(255),
  redirectUrl VARCHAR(255),
  authorities VARCHAR(255),
  access_token_validity INTEGER,
  refresh_token_validity INTEGER,
  additionalInformation VARCHAR(4096),
  autoApproveScopes VARCHAR(255)
);
```

注意，我们不一定需要显式的`DatabasePopulator`bean—**我们可以简单地使用一个`schema.sql`——Spring Boot 默认使用的是**。

### **2.4。安全配置**

最后，让我们保护授权服务器。

当客户端应用程序需要获取访问令牌时，它将在一个简单的表单登录驱动的身份验证过程之后完成:

```
@Configuration
public class ServerSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) 
      throws Exception {
        auth.inMemoryAuthentication()
          .withUser("john").password("123").roles("USER");
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() 
      throws Exception {
        return super.authenticationManagerBean();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .antMatchers("/login").permitAll()
            .anyRequest().authenticated()
            .and()
            .formLogin().permitAll();
    }
}
```

这里需要注意的是**表单登录配置对于密码流**来说是不必要的——只是对于隐式流来说——所以你可以根据你使用的 OAuth2 流来跳过它。

## **3。资源服务器**

现在，我们来讨论资源服务器；这本质上是我们最终希望能够消费的 REST API。

### **3.1。Maven 配置**

我们的资源服务器配置与之前的授权服务器应用程序配置相同。

### **3.2。令牌存储配置**

接下来，我们将配置我们的`TokenStore`来访问授权服务器用来存储访问令牌的同一个数据库:

```
@Autowired
private Environment env;

@Bean
public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(env.getProperty("jdbc.driverClassName"));
    dataSource.setUrl(env.getProperty("jdbc.url"));
    dataSource.setUsername(env.getProperty("jdbc.user"));
    dataSource.setPassword(env.getProperty("jdbc.pass"));
    return dataSource;
}

@Bean
public TokenStore tokenStore() {
    return new JdbcTokenStore(dataSource());
}
```

注意，对于这个简单的实现，**我们共享 SQL 支持的令牌存储库**，即使授权和资源服务器是独立的应用程序。

当然，原因是资源服务器需要能够**检查授权服务器发布的访问令牌**的有效性。

### **3.3。远程令牌服务**

在我们的资源服务器中不使用`TokenStore`，我们可以使用`RemoteTokeServices`:

```
@Primary
@Bean
public RemoteTokenServices tokenService() {
    RemoteTokenServices tokenService = new RemoteTokenServices();
    tokenService.setCheckTokenEndpointUrl(
      "http://localhost:8080/spring-security-oauth-server/oauth/check_token");
    tokenService.setClientId("fooClientIdPassword");
    tokenService.setClientSecret("secret");
    return tokenService;
}
```

请注意:

*   这个`RemoteTokenService`将使用授权服务器上的`CheckTokenEndPoint`来验证 AccessToken 并从中获取`Authentication`对象。
*   可在 AuthorizationServerBaseURL+"`/oauth/check_token`找到
*   授权服务器可以使用任何令牌存储类型[ `JdbcTokenStore`、`JwtTokenStore`、…]–这不会影响`RemoteTokenService`或资源服务器。

### **3.4。样品控制器**

接下来，让我们实现一个简单的控制器，公开一个`Foo`资源:

```
@Controller
public class FooController {

    @PreAuthorize("#oauth2.hasScope('read')")
    @RequestMapping(method = RequestMethod.GET, value = "/foos/{id}")
    @ResponseBody
    public Foo findById(@PathVariable long id) {
        return 
          new Foo(Long.parseLong(randomNumeric(2)), randomAlphabetic(4));
    }
}
```

注意客户端如何需要`“read”`范围来访问这个资源。

我们还需要启用全局方法安全性并配置`MethodSecurityExpressionHandler`:

```
@Configuration
@EnableResourceServer
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class OAuth2ResourceServerConfig 
  extends GlobalMethodSecurityConfiguration {

    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        return new OAuth2MethodSecurityExpressionHandler();
    }
}
```

这是我们的基本资源:

```
public class Foo {
    private long id;
    private String name;
}
```

### **3.5。网络配置**

最后，让我们为 API 设置一个非常基本的 web 配置:

```
@Configuration
@EnableWebMvc
@ComponentScan({ "org.baeldung.web.controller" })
public class ResourceWebConfig implements WebMvcConfigurer {}
```

## **4。前端–设置**

我们现在来看一个简单的客户端前端角度实施方案。

首先，我们将使用 [Angular CLI](https://web.archive.org/web/20220707143817/https://cli.angular.io/) 来生成和管理我们的前端模块。

**首先，我们将安装[节点和 npm](https://web.archive.org/web/20220707143817/https://nodejs.org/en/download/)**——因为 Angular CLI 是一个 NPM 工具。

然后，我们需要使用 [`frontend-maven-plugin`](https://web.archive.org/web/20220707143817/https://github.com/eirslett/frontend-maven-plugin) 来使用 maven 构建我们的 Angular 项目:

```
<build>
    <plugins>
        <plugin>
            <groupId>com.github.eirslett</groupId>
            <artifactId>frontend-maven-plugin</artifactId>
            <version>1.3</version>
            <configuration>
                <nodeVersion>v6.10.2</nodeVersion>
                <npmVersion>3.10.10</npmVersion>
                <workingDirectory>src/main/resources</workingDirectory>
            </configuration>
            <executions>
                <execution>
                    <id>install node and npm</id>
                    <goals>
                        <goal>install-node-and-npm</goal>
                    </goals>
                </execution>
                <execution>
                    <id>npm install</id>
                    <goals>
                        <goal>npm</goal>
                    </goals>
                </execution>
                <execution>
                    <id>npm run build</id>
                    <goals>
                        <goal>npm</goal>
                    </goals>
                    <configuration>
                        <arguments>run build</arguments>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

最后，**使用 Angular CLI 生成新模块:**

```
ng new oauthApp
```

请注意，我们将有两个前端模块——一个用于密码流，另一个用于隐式流。

在以下部分，我们将讨论每个模块的角度应用程序逻辑。

## **5。使用角度**的密码流

我们将在这里使用 OAuth2 密码流，这就是为什么**这只是一个概念验证，而不是一个生产就绪的应用**。您会注意到客户端凭证暴露在前端——这是我们将在以后的文章中解决的问题。

我们的用例很简单:一旦用户提供了他们的凭证，前端客户端就使用它们从授权服务器获取访问令牌。

### **5.1。应用服务**

让我们从位于`app.service.ts`的`AppService`开始，它包含服务器交互的逻辑:

*   `obtainAccessToken()`:获取给定用户凭证的访问令牌
*   使用 ng2-cookies 库将我们的访问令牌保存在 cookie 中
*   `getResource()`:使用其 ID 从服务器获取 Foo 对象
*   `checkCredentials()`:检查用户是否登录
*   `logout()`:删除访问令牌 cookie 并注销用户

```
export class Foo {
  constructor(
    public id: number,
    public name: string) { }
} 

@Injectable()
export class AppService {
  constructor(
    private _router: Router, private _http: Http){}

  obtainAccessToken(loginData){
    let params = new URLSearchParams();
    params.append('username',loginData.username);
    params.append('password',loginData.password);    
    params.append('grant_type','password');
    params.append('client_id','fooClientIdPassword');
    let headers = 
      new Headers({'Content-type': 'application/x-www-form-urlencoded; charset=utf-8',
      'Authorization': 'Basic '+btoa("fooClientIdPassword:secret")});
    let options = new RequestOptions({ headers: headers });

    this._http.post('http://localhost:8081/spring-security-oauth-server/oauth/token', 
      params.toString(), options)
      .map(res => res.json())
      .subscribe(
        data => this.saveToken(data),
        err => alert('Invalid Credentials')); 
  }

  saveToken(token){
    var expireDate = new Date().getTime() + (1000 * token.expires_in);
    Cookie.set("access_token", token.access_token, expireDate);
    this._router.navigate(['/']);
  }

  getResource(resourceUrl) : Observable<Foo>{
    var headers = 
      new Headers({'Content-type': 'application/x-www-form-urlencoded; charset=utf-8',
      'Authorization': 'Bearer '+Cookie.get('access_token')});
    var options = new RequestOptions({ headers: headers });
    return this._http.get(resourceUrl, options)
                   .map((res:Response) => res.json())
                   .catch((error:any) => 
                     Observable.throw(error.json().error || 'Server error'));
  }

  checkCredentials(){
    if (!Cookie.check('access_token')){
        this._router.navigate(['/login']);
    }
  } 

  logout() {
    Cookie.delete('access_token');
    this._router.navigate(['/login']);
  }
}
```

请注意:

*   为了获得访问令牌，我们向“`/oauth/token`”端点发送一个`POST`
*   我们使用客户端凭据和基本身份验证来访问这个端点
*   然后，我们发送用户凭证以及客户机 id 和授权类型参数 URL 编码
*   在我们获得访问令牌–**之后，我们将它存储在一个 cookie 中**

cookie 存储在这里尤其重要，因为我们只是将 cookie 用于存储目的，而不是直接驱动认证过程。这有助于防范跨站点请求伪造(CSRF)类型的攻击和漏洞。

### 5.2。登录组件

接下来，让我们看看负责登录表单的`LoginComponent`:

```
@Component({
  selector: 'login-form',
  providers: [AppService],  
  template: `<h1>Login</h1>
    <input type="text" [(ngModel)]="loginData.username" />
    <input type="password"  [(ngModel)]="loginData.password"/>
    <button (click)="login()" type="submit">Login</button>`
})
export class LoginComponent {
    public loginData = {username: "", password: ""};

    constructor(private _service:AppService) {}

    login() {
        this._service.obtainAccessToken(this.loginData);
    }
```

### 5.3。家用组件

接下来，我们的`HomeComponent`负责显示和操作我们的主页:

```
@Component({
    selector: 'home-header',
    providers: [AppService],
  template: `<span>Welcome !!</span>
    <a (click)="logout()" href="#">Logout</a>
    <foo-details></foo-details>`
})

export class HomeComponent {
    constructor(
        private _service:AppService){}

    ngOnInit(){
        this._service.checkCredentials();
    }

    logout() {
        this._service.logout();
    }
}
```

### 5.4。Foo 组件

最后，我们的`FooComponent`显示我们的 Foo 细节:

```
@Component({
  selector: 'foo-details',
  providers: [AppService],  
  template: `<h1>Foo Details</h1>
    <label>ID</label> <span>{{foo.id}}</span>
    <label>Name</label> <span>{{foo.name}}</span>
    <button (click)="getFoo()" type="submit">New Foo</button>`
})

export class FooComponent {
    public foo = new Foo(1,'sample foo');
    private foosUrl = 'http://localhost:8082/spring-security-oauth-resource/foos/';  

    constructor(private _service:AppService) {}

    getFoo(){
        this._service.getResource(this.foosUrl+this.foo.id)
          .subscribe(
            data => this.foo = data,
            error =>  this.foo.name = 'Error');
    }
}
```

### **5.5。应用组件**

我们简单的`AppComponent`充当根组件:

```
@Component({
    selector: 'app-root',
    template: `<router-outlet></router-outlet>`
})

export class AppComponent {}
```

我们包装所有组件、服务和路线的地方:

```
@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    LoginComponent,
    FooComponent    
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    RouterModule.forRoot([
     { path: '', component: HomeComponent },
    { path: 'login', component: LoginComponent }])
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## **6。隐式流程**

接下来，我们将关注隐式流模块。

### **6.1。应用服务**

类似地，我们将从我们的服务开始，但是这一次我们将使用库 [angular-oauth2-oidc](https://web.archive.org/web/20220707143817/https://github.com/manfredsteyer/angular-oauth2-oidc) 而不是自己获取访问令牌:

```
@Injectable()
export class AppService {

  constructor(
    private _router: Router, private _http: Http, private oauthService: OAuthService){
        this.oauthService.loginUrl = 
          'http://localhost:8081/spring-security-oauth-server/oauth/authorize'; 
        this.oauthService.redirectUri = 'http://localhost:8086/';
        this.oauthService.clientId = "sampleClientId";
        this.oauthService.scope = "read write foo bar";    
        this.oauthService.setStorage(sessionStorage);
        this.oauthService.tryLogin({});      
    }

  obtainAccessToken(){
      this.oauthService.initImplicitFlow();
  }

  getResource(resourceUrl) : Observable<Foo>{
    var headers = 
      new Headers({'Content-type': 'application/x-www-form-urlencoded; charset=utf-8',
     'Authorization': 'Bearer '+this.oauthService.getAccessToken()});
    var options = new RequestOptions({ headers: headers });
    return this._http.get(resourceUrl, options)
      .map((res:Response) => res.json())
      .catch((error:any) => Observable.throw(error.json().error || 'Server error'));
  }

  isLoggedIn(){
    if (this.oauthService.getAccessToken() === null){
       return false;
    }
    return true;
  } 

  logout() {
      this.oauthService.logOut();
      location.reload();
  }
}
```

请注意，在获得访问令牌后，每当我们从资源服务器中使用受保护的资源时，我们是如何通过`Authorization`头使用它的。

### 6.2。家用组件

我们的`HomeComponent`处理我们简单的主页:

```
@Component({
    selector: 'home-header',
    providers: [AppService],
  template: `
    <button *ngIf="!isLoggedIn" (click)="login()" type="submit">Login</button>
    <div *ngIf="isLoggedIn">
        <span>Welcome !!</span>
        <a (click)="logout()" href="#">Logout</a>
        <br/>
        <foo-details></foo-details>
    </div>`
})

export class HomeComponent {
    public isLoggedIn = false;

    constructor(
        private _service:AppService){}

    ngOnInit(){
        this.isLoggedIn = this._service.isLoggedIn();
    }

    login() {
        this._service.obtainAccessToken();
    }

    logout() {
        this._service.logout();
    }
}
```

### 6.3。Foo 组件

我们的`FooComponent`和密码流模块中的完全一样。

### 6.4。应用模块

最后，我们的`AppModule`:

```
@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    FooComponent    
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    OAuthModule.forRoot(),    
    RouterModule.forRoot([
     { path: '', component: HomeComponent }])
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## **7。运行前端**

1.要运行我们的任何前端模块，我们需要首先构建应用程序:

```
mvn clean install
```

2.然后我们需要导航到我们的 Angular 应用程序目录:

```
cd src/main/resources
```

3.最后，我们将启动我们的应用:

```
npm start
```

默认情况下，服务器将在端口 4200 上启动，要更改任何模块的端口，请更改

```
"start": "ng serve"
```

以`package.json`中让它在 8086 端口上运行为例:

```
"start": "ng serve --port 8086"
```

## **8。结论**

在本文中，我们学习了如何使用 OAuth2 授权我们的应用程序。

本教程的完整实现可以在 GitHub 项目中找到。