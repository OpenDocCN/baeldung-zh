["```\r\nStream.of(\"cat\", \"dog\", \"elephant\", \"fox\", \"rabbit\", \"duck\")\r\n  .takeWhile(n -> n.length() % 2 != 0)\r\n  .forEach(System.out::println);\r\n```","```\r\ncat\r\ndog\r\n```","```\r\nList<String> list = asList(\"cat\", \"dog\", \"elephant\", \"fox\", \"rabbit\", \"duck\");\r\nfor (int i = 0; i < list.size(); i++) {\r\n    String item = list.get(i);\r\n    if (item.length() % 2 == 0) {\r\n        break;\r\n    }\r\n    System.out.println(item);\r\n} \r\n```","```\r\npublic static <T> Stream<T> takeWhile(Stream<T> stream, Predicate<T> predicate) {\r\n    CustomSpliterator<T> customSpliterator = new CustomSpliterator<>(stream.spliterator(), predicate);\r\n    return StreamSupport.stream(customSpliterator, false);\r\n}\r\n```","```\r\npublic class CustomSpliterator<T> extends Spliterators.AbstractSpliterator<T> {\r\n\r\n    private Spliterator<T> splitr;\r\n    private Predicate<T> predicate;\r\n    private boolean isMatched = true;\r\n\r\n    public CustomSpliterator(Spliterator<T> splitr, Predicate<T> predicate) {\r\n        super(splitr.estimateSize(), 0);\r\n        this.splitr = splitr;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    @Override\r\n    public synchronized boolean tryAdvance(Consumer<? super T> consumer) {\r\n        boolean hadNext = splitr.tryAdvance(elem -> {\r\n            if (predicate.test(elem) && isMatched) {\r\n                consumer.accept(elem);\r\n            } else {\r\n                isMatched = false;\r\n            }\r\n        });\r\n        return hadNext && isMatched;\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void whenCustomTakeWhileIsCalled_ThenCorrectItemsAreReturned() {\r\n    Stream<String> initialStream = \r\n      Stream.of(\"cat\", \"dog\", \"elephant\", \"fox\", \"rabbit\", \"duck\");\r\n\r\n    List<String> result = \r\n      CustomTakeWhile.takeWhile(initialStream, x -> x.length() % 2 != 0)\r\n        .collect(Collectors.toList());\r\n\r\n    assertEquals(asList(\"cat\", \"dog\"), result);\r\n}\r\n```","```\r\npublic class CustomForEach {\r\n\r\n    public static class Breaker {\r\n        private boolean shouldBreak = false;\r\n\r\n        public void stop() {\r\n            shouldBreak = true;\r\n        }\r\n\r\n        boolean get() {\r\n            return shouldBreak;\r\n        }\r\n    }\r\n\r\n    public static <T> void forEach(Stream<T> stream, BiConsumer<T, Breaker> consumer) {\r\n        Spliterator<T> spliterator = stream.spliterator();\r\n        boolean hadNext = true;\r\n        Breaker breaker = new Breaker();\r\n\r\n        while (hadNext && !breaker.get()) {\r\n            hadNext = spliterator.tryAdvance(elem -> {\r\n                consumer.accept(elem, breaker);\r\n            });\r\n        }\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void whenCustomForEachIsCalled_ThenCorrectItemsAreReturned() {\r\n    Stream<String> initialStream = Stream.of(\"cat\", \"dog\", \"elephant\", \"fox\", \"rabbit\", \"duck\");\r\n    List<String> result = new ArrayList<>();\r\n\r\n    CustomForEach.forEach(initialStream, (elem, breaker) -> {\r\n        if (elem.length() % 2 == 0) {\r\n            breaker.stop();\r\n        } else {\r\n            result.add(elem);\r\n        }\r\n    });\r\n\r\n    assertEquals(asList(\"cat\", \"dog\"), result);\r\n}\r\n```"]