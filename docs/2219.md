# Spring BeanCreationException

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-beancreationexception>

## **1。概述**

在本教程中，我们将讨论 **Spring `org.springframework.beans.factory.BeanCreationException.`** ，这是一个非常常见的异常，当`BeanFactory`创建 bean 定义的 bean 并遇到问题时抛出。本文将探讨该异常最常见的原因以及解决方案。

## 延伸阅读:

## [Spring 控制反转和依赖注入简介](/web/20220529013244/https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring)

A quick introduction to the concepts of Inversion of Control and Dependency Injection, followed by a simple demonstration using the Spring Framework[Read more](/web/20220529013244/https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring) →

## [Spring 中的 BeanNameAware 和 BeanFactoryAware 接口](/web/20220529013244/https://www.baeldung.com/spring-bean-name-factory-aware)

Have a look at working with the BeanNameAware and BeanFactoryAware interfaces in Spring.[Read more](/web/20220529013244/https://www.baeldung.com/spring-bean-name-factory-aware) →

## [Spring 5 功能 Bean 注册](/web/20220529013244/https://www.baeldung.com/spring-5-functional-beans)

See how to register beans using the functional approach in Spring 5.[Read more](/web/20220529013244/https://www.baeldung.com/spring-5-functional-beans) →

## **2。`org.springframework.beans.factory.NoSuchBeanDefinitionException`起因:**

到目前为止，`BeanCreationException`最常见的原因是 Spring 试图**注入一个在上下文中不存在的**bean。

例如，`BeanA`正在尝试注入`BeanB`:

[PRE0]

如果在上下文中没有找到`BeanB`，那么将抛出以下异常(创建 Bean 时出错):

[PRE1]

为了诊断这种类型的问题，我们将首先确保 bean 被声明为:

*   或者在 XML 配置文件中使用`<bean />`元素
*   或者通过`@Bean`注释在 Java `@Configuration`类中实现
*   或者用`@Component`、`@Repository`、`@Service`、`@Controller,`进行注释，并且类路径扫描对于该包是活动的

我们还将检查 Spring 是否真的获取了配置文件或类，并将它们加载到主上下文中。

## 延伸阅读:

## [Spring 控制反转和依赖注入简介](/web/20220529013244/https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring)

A quick introduction to the concepts of Inversion of Control and Dependency Injection, followed by a simple demonstration using the Spring Framework[Read more](/web/20220529013244/https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring) →

## [Spring 中的 BeanNameAware 和 BeanFactoryAware 接口](/web/20220529013244/https://www.baeldung.com/spring-bean-name-factory-aware)

Have a look at working with the BeanNameAware and BeanFactoryAware interfaces in Spring.[Read more](/web/20220529013244/https://www.baeldung.com/spring-bean-name-factory-aware) →

## [Spring 5 功能 Bean 注册](/web/20220529013244/https://www.baeldung.com/spring-5-functional-beans)

See how to register beans using the functional approach in Spring 5.[Read more](/web/20220529013244/https://www.baeldung.com/spring-5-functional-beans) →

## **3。`org.springframework.beans.factory.NoUniqueBeanDefinitionException`起因:**

bean 创建异常的另一个类似原因是 Spring 试图通过类型注入 bean，即通过它的接口，并在上下文中找到两个或更多实现接口的 bean。

例如，`BeanB1`和`BeanB2`都实现了相同的接口:

[PRE2]

这将导致 Spring bean 工厂抛出以下异常:

[PRE3]

## **4。`org.springframework.beans.BeanInstantiationException`起因:**

### **4.1。自定义异常**

接下来是一个在创建过程中抛出异常的 **bean。**一个容易理解问题的简化示例是在 bean 的构造函数中抛出一个异常:

[PRE4]

正如所料，这将导致 Spring 快速失败，并出现以下异常:

[PRE5]

### **4.2。`java.lang.InstantiationException`**

`BeanInstantiationException`的另一个可能出现的情况是在 XML 中将抽象类定义为 bean 这必须在 XML 中，因为在 Java `@Configuration`文件中没有办法做到这一点，并且类路径扫描将忽略抽象类:

[PRE6]

下面是 bean 的 XML 定义:

[PRE7]

此设置将导致类似的异常:

[PRE8]

### **4.3。`java.lang.NoSuchMethodException`**

如果 bean 没有默认的构造函数，而 Spring 试图通过查找该构造函数来实例化它，这将导致运行时异常:

[PRE9]

当类路径扫描机制选择这个 bean 时，失败将是:

[PRE10]

当类路径上的 Spring 依赖项没有**相同版本时，可能会出现类似的异常，但更难诊断。**这种版本不兼容可能会因为 API 的变化而导致`NoSuchMethodException`。解决这个问题的方法是确保所有的 Spring 库在项目中有完全相同的版本。

## **5。`org.springframework.beans.NotWritablePropertyException`起因:**

还有一种可能性是定义一个 bean，`BeanA,`并引用另一个 bean，`BeanB,`，而在`BeanA`中没有相应的 setter 方法:

[PRE11]

爱马仕

[PRE12]

同样，这个**只能出现在 XML 配置**中，因为当使用 Java `@Configuration`时，编译器将使这个问题不可能重现。

当然，为了解决这个问题，我们需要为`IBeanB`添加 setter:

[PRE13]

## **6。`org.springframework.beans.factory.CannotLoadBeanClassException`起因:**

**Spring 在无法加载已定义 bean** 的类时抛出这个异常。如果 Spring XML 配置包含一个没有相应类的 bean，就会出现这种情况。例如，如果类`BeanZ`不存在，下面的定义将导致一个异常:

[PRE14]

本例中`ClassNotFoundException`和完整异常的根本原因是:

[PRE15]

## **7。`BeanCreationException` 【T2 的孩子】**

### **7.1。`org.springframework.beans.factory.BeanCurrentlyInCreationException`**

`BeanCreationException`的一个子类是`BeanCurrentlyInCreationException.`，这通常发生在使用构造函数注入时，例如，在循环依赖的情况下:

[PRE16]

Spring 无法解决这种连接场景，最终结果将是:

[PRE17]

完整的异常非常详细:

[PRE18]

### **7.2。`org.springframework.beans.factory.BeanIsAbstractException`**

当 bean 工厂试图检索和实例化被声明为抽象的 Bean 时，可能会发生此实例化异常:

[PRE19]

我们在 XML 配置中将其声明为:

[PRE20]

如果我们试图通过名称从 Spring 上下文中检索`BeanA`，就像实例化另一个 bean 一样:

[PRE21]

这将导致以下异常:

[PRE22]

和完整的异常堆栈跟踪:

[PRE23]

## **8。结论**

在本文中，我们学习了如何处理可能导致春天到来的各种原因和问题，以及如何解决所有这些问题。

所有异常示例的实现都可以在 github 项目中找到。这是一个基于 Eclipse 的项目，因此应该很容易导入和运行。