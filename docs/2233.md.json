["```\r\npublic static long getBiggerPrime(int m) {\r\n    BigInteger prime = BigInteger.probablePrime(getNumberOfBits(m) + 1, new Random());\r\n    return prime.longValue();\r\n}\r\nprivate static int getNumberOfBits(int number) {\r\n    return Integer.SIZE - Integer.numberOfLeadingZeros(number);\r\n} \r\n```","```\r\npublic static int simpleTextSearch(char[] pattern, char[] text) {\r\n    int patternSize = pattern.length;\r\n    int textSize = text.length;\r\n\r\n    int i = 0;\r\n\r\n    while ((i + patternSize) <= textSize) {\r\n        int j = 0;\r\n        while (text[i + j] == pattern[j]) {\r\n            j += 1;\r\n            if (j >= patternSize)\r\n                return i;\r\n        }\r\n        i += 1;\r\n    }\r\n    return -1;\r\n}\r\n```","```\r\nText: baeldunbaeldunbaeldunbaeldun\r\nPattern: baeldung\r\n```","```\r\npublic static int RabinKarpMethod(char[] pattern, char[] text) {\r\n    int patternSize = pattern.length;\r\n    int textSize = text.length;      \r\n\r\n    long prime = getBiggerPrime(patternSize);\r\n\r\n    long r = 1;\r\n    for (int i = 0; i < patternSize - 1; i++) {\r\n        r *= 2;\r\n        r = r % prime;\r\n    }\r\n\r\n    long[] t = new long[textSize];\r\n    t[0] = 0;\r\n\r\n    long pfinger = 0;\r\n\r\n    for (int j = 0; j < patternSize; j++) {\r\n        t[0] = (2 * t[0] + text[j]) % prime;\r\n        pfinger = (2 * pfinger + pattern[j]) % prime;\r\n    }\r\n\r\n    int i = 0;\r\n    boolean passed = false;\r\n\r\n    int diff = textSize - patternSize;\r\n    for (i = 0; i <= diff; i++) {\r\n        if (t[i] == pfinger) {\r\n            passed = true;\r\n            for (int k = 0; k < patternSize; k++) {\r\n                if (text[i + k] != pattern[k]) {\r\n                    passed = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (passed) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        if (i < diff) {\r\n            long value = 2 * (t[i] - r * text[i]) + text[i + patternSize];\r\n            t[i + 1] = ((value % prime) + prime) % prime;\r\n        }\r\n    }\r\n    return -1;\r\n\r\n}\r\n```","```\r\npublic static int KnuthMorrisPrattSearch(char[] pattern, char[] text) {\r\n    int patternSize = pattern.length;\r\n    int textSize = text.length;\r\n\r\n    int i = 0, j = 0;\r\n\r\n    int[] shift = KnuthMorrisPrattShift(pattern);\r\n\r\n    while ((i + patternSize) <= textSize) {\r\n        while (text[i + j] == pattern[j]) {\r\n            j += 1;\r\n            if (j >= patternSize)\r\n                return i;\r\n        }\r\n\r\n        if (j > 0) {\r\n            i += shift[j - 1];\r\n            j = Math.max(j - shift[j - 1], 0);\r\n        } else {\r\n            i++;\r\n            j = 0;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n```","```\r\npublic static int[] KnuthMorrisPrattShift(char[] pattern) {\r\n    int patternSize = pattern.length;\r\n\r\n    int[] shift = new int[patternSize];\r\n    shift[0] = 1;\r\n\r\n    int i = 1, j = 0;\r\n\r\n    while ((i + j) < patternSize) {\r\n        if (pattern[i + j] == pattern[j]) {\r\n            shift[i + j] = i;\r\n            j++;\r\n        } else {\r\n            if (j == 0)\r\n                shift[i] = i + 1;\r\n\r\n            if (j > 0) {\r\n                i = i + shift[j - 1];\r\n                j = Math.max(j - shift[j - 1], 0);\r\n            } else {\r\n                i = i + 1;\r\n                j = 0;\r\n            }\r\n        }\r\n    }\r\n    return shift;\r\n}\r\n```","```\r\npublic static int BoyerMooreHorspoolSimpleSearch(char[] pattern, char[] text) {\r\n    int patternSize = pattern.length;\r\n    int textSize = text.length;\r\n\r\n    int i = 0, j = 0;\r\n\r\n    while ((i + patternSize) <= textSize) {\r\n        j = patternSize - 1;\r\n        while (text[i + j] == pattern[j]) {\r\n            j--;\r\n            if (j < 0)\r\n                return i;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}\r\n```","```\r\npublic static int BoyerMooreHorspoolSearch(char[] pattern, char[] text) {\r\n\r\n    int shift[] = new int[256];\r\n\r\n    for (int k = 0; k < 256; k++) {\r\n        shift[k] = pattern.length;\r\n    }\r\n\r\n    for (int k = 0; k < pattern.length - 1; k++){\r\n        shift[pattern[k]] = pattern.length - 1 - k;\r\n    }\r\n\r\n    int i = 0, j = 0;\r\n\r\n    while ((i + pattern.length) <= text.length) {\r\n        j = pattern.length - 1;\r\n\r\n        while (text[i + j] == pattern[j]) {\r\n            j -= 1;\r\n            if (j < 0)\r\n                return i;\r\n        }\r\n\r\n        i = i + shift[text[i + pattern.length - 1]];\r\n    }\r\n    return -1;\r\n}\r\n```"]