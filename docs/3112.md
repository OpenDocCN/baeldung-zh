# 解释了 Java 中的类型擦除

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-type-erasure>

## **1。概述**

在这篇简短的文章中，我们将讨论 Java 泛型中称为类型擦除的一个重要机制的基础知识。

## **2。什么是类型擦除？**

**类型擦除可以解释为只在[编译时](/web/20221021112600/https://www.baeldung.com/cs/compile-load-execution-time)强制类型约束并在运行时丢弃元素类型信息的过程。**

例如:

```
public static  <E> boolean containsElement(E [] elements, E element){
    for (E e : elements){
        if(e.equals(element)){
            return true;
        }
    }
    return false;
}
```

编译器用实际类型`Object`替换未绑定类型`E`:

```
public static  boolean containsElement(Object [] elements, Object element){
    for (Object e : elements){
        if(e.equals(element)){
            return true;
        }
    }
    return false;
}
```

因此，编译器确保了代码的类型安全，防止了运行时错误。

## **3。类型擦除的类型**

类型擦除可以发生在类(或变量)和方法级别。

### **3.1。类别类型擦除**

在类级别，编译器丢弃类上的类型参数，并用它的第一个绑定替换它们，如果类型参数未绑定，则用`Object`替换。

让我们使用数组实现一个`Stack`:

```
public class Stack<E> {
    private E[] stackContent;

    public Stack(int capacity) {
        this.stackContent = (E[]) new Object[capacity];
    }

    public void push(E data) {
        // ..
    }

    public E pop() {
        // ..
    }
}
```

编译时，编译器用`Object`替换未绑定的类型参数`E`:

```
public class Stack {
    private Object[] stackContent;

    public Stack(int capacity) {
        this.stackContent = (Object[]) new Object[capacity];
    }

    public void push(Object data) {
        // ..
    }

    public Object pop() {
        // ..
    }
}
```

在类型参数`E`被绑定的情况下:

```
public class BoundStack<E extends Comparable<E>> {
    private E[] stackContent;

    public BoundStack(int capacity) {
        this.stackContent = (E[]) new Object[capacity];
    }

    public void push(E data) {
        // ..
    }

    public E pop() {
        // ..
    }
}
```

编译器会用第一个绑定类`Comparable`替换绑定类型参数`E`，在这个例子中是`:`

```
public class BoundStack {
    private Comparable [] stackContent;

    public BoundStack(int capacity) {
        this.stackContent = (Comparable[]) new Object[capacity];
    }

    public void push(Comparable data) {
        // ..
    }

    public Comparable pop() {
        // ..
    }
}
```

### **3.2。方法类型擦除**

对于方法级类型擦除，如果方法是未绑定的或者是绑定时的第一个绑定类，则方法的类型参数不会被存储，而是被转换为其父类型`Object`。

让我们考虑一种显示任何给定数组内容的方法:

```
public static <E> void printArray(E[] array) {
    for (E element : array) {
        System.out.printf("%s ", element);
    }
}
```

编译时，编译器用`Object`替换类型参数`E`:

```
public static void printArray(Object[] array) {
    for (Object element : array) {
        System.out.printf("%s ", element);
    }
}
```

对于绑定方法类型参数:

```
public static <E extends Comparable<E>> void printArray(E[] array) {
    for (E element : array) {
        System.out.printf("%s ", element);
    }
}
```

我们将删除类型参数`E` 并用`Comparable:`代替

```
public static void printArray(Comparable[] array) {
    for (Comparable element : array) {
        System.out.printf("%s ", element);
    }
}
```

## **4。边缘案例**

在类型擦除过程中，编译器会创建一个综合方法来区分相似的方法。这些可能来自扩展同一个第一绑定类的方法签名。

让我们创建一个新的类来扩展我们之前对`Stack. `的实现。请注意，这里指的是我们在**3.1 节**中创建的`Stack`类，而不是`java.util.Stack`。

```
public class IntegerStack extends Stack<Integer> {

    public IntegerStack(int capacity) {
        super(capacity);
    }

    public void push(Integer value) {
        super.push(value);
    }
}
```

现在让我们看看下面的代码:

```
IntegerStack integerStack = new IntegerStack(5);
Stack stack = integerStack;
stack.push("Hello");
Integer data = integerStack.pop();
```

类型擦除后，我们有:

```
IntegerStack integerStack = new IntegerStack(5);
Stack stack = (IntegerStack) integerStack;
stack.push("Hello");
Integer data = (String) integerStack.pop();
```

注意我们如何在`IntegerStack`上推一个`S``tring`——因为`IntegerStack`从父类`Stack`继承了`push(Object)`。这当然是不正确的，因为它应该是一个整数，因为`integerStack`是一个`Stack<Integer>`类型。

因此，毫不奇怪，试图将一个`String`赋值给一个`Integer`会导致编译器在`push`期间插入一个来自强制转换的`ClassCastException`。

### **4.1。桥接方法**

为了解决上面的边缘情况，编译器有时会创建一个桥方法。这是 Java 编译器在编译扩展参数化类或实现参数化接口的类或接口时创建的合成方法，其中方法签名可能略有不同或不明确。

在我们上面的例子中，Java 编译器通过确保`IntegerStack`的`push(Integer)`方法和`Stack`的`push(Object)`方法之间没有方法签名不匹配，在删除后保留了泛型类型的多态性。

因此，编译器在这里创建了一个桥方法:

```
public class IntegerStack extends Stack {
    // Bridge method generated by the compiler

    public void push(Object value) {
        push((Integer)value);
    }

    public void push(Integer value) {
        super.push(value);
    }
}
```

因此，`Stack`类的`push`方法在类型擦除后，委托给了`IntegerStack` 类的原始`push`方法。

## **5。结论**

在本教程中，我们通过类型参数变量和方法中的例子讨论了类型擦除的概念。

您可以阅读更多关于这些概念的内容:

*   Java 语言规范:类型擦除
*   [Java 泛型的基础知识](/web/20221021112600/https://www.baeldung.com/java-generics)

和往常一样，本文附带的源代码可以在 GitHub 上的[处获得。](https://web.archive.org/web/20221021112600/https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-lang-oop-generics)