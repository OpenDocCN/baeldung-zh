# 从整数值中得到某个位置的一个比特

> 原文:[https://web . archive . org/web/20220930061024/https://www . bael dung . com/Java-get-bit-at-position](https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-get-bit-at-position)

## 1.概观

有时我们需要测试一个数中的一个二进制数字是否置位。这可能是因为我们使用数字作为一组标志，其中每个数字代表一个特定的布尔值。

在本教程中，我们将探索从整数值中获取特定位置的位的不同方法，如`byte`、`short`、`char`、`int`和`long`。

## 2.测试特定位

最常见的情况之一是，我们想要用[位掩码](/web/20220628091014/https://www.baeldung.com/java-bitmasking)测试整数值的特定位。

例如，让我们检查第三位是否设置在`byte`值中:

```
byte val1 = 0b0110_0100;
byte mask = 0b0000_0100;
boolean isSet1 = (val1 & mask) > 0;
assertTrue(isSet1); 
```

这里测试二进制数`01100100`以查看第三位–`00000100`是否通过使用[位与](/web/20220628091014/https://www.baeldung.com/java-bitwise-operators)来设置。结果大于零，确实如此。我们还可以测试它是否未设置:

```
byte val2 = 0b0110_0010;
boolean isSet2 = (val2 & mask) > 0;
assertFalse(isSet2);
```

这个例子基于`byte`数字类型，我们可以很容易地将其扩展到`short`、`char`、`int`和`long`值。

在这个解决方案中，我们对位掩码进行了硬编码。如果我们想推广解决方案来检查我们的数字中的任何一位呢？

## 3.使用移位运算符

开始之前，让我们先定义一个 32 位`int`中位位置的索引范围。最左边的位的索引为 31，最右边的位的索引为 0。这是因为我们的数字从最高有效位到最低有效位。例如，如果我们使用 64 位的`long`数，最左边的位就是 63。

### 3.1.左移一个遮罩

我们可以通过取值`1`并使用左移运算符将其移动到正确的位置来生成位掩码:

```
int val = 0b0110_0100;
int pos = 2;
int mask = 1 << pos;
boolean isSet = (val & mask) > 0;

assertTrue(isSet);
```

这里我们将`pos`设置为`2`，尽管它可以是我们的数字中任何有效的位位置。然后，我们使用左移运算符(`<<`)来生成我们的位掩码。最后，我们在`val`和`mask`之间做一个位与(`&`)运算。

如果结果大于零，则意味着目标位被置位。

### 3.2.将值左移

此外，还有另一种解决这个问题的方法。

我们可以对正在测试的值使用左移运算符，而不是构造位掩码。我们可以移动它的内容，使感兴趣的位位于最左边，而不是用位掩码过滤值。

那么我们需要做的就是检查最左边的位是否被置位。由于有符号整数被表示为[二进制补码](/web/20220628091014/https://www.baeldung.com/cs/two-complement)，我们可以通过测试得到的移位数是否为负来测试前导数字是否为 1。

```
int val = 0b0110_0100;
int pos = 2;
boolean isSet = ((val << (31 - pos)) < 0);

assertTrue(isSet);
```

上面的`pos`是 2，最左边的位置是 31，所以我们用 31 减去`pos`，等于 29。然后，我们将原始值左移 29 位，得到一个新值。在这个新值中，有趣的位在最左边的位置。最后，我们检查新值是否小于零。

### 3.3.将值右移

类似地，我们可以使用右移位运算符来测试整数值的一点。将整数值的目标位移动到最右边的位置并使用位掩码`1,`后，我们可以检查结果是否等于 1:

```
int val = 0b0110_0100;
int pos = 2;
boolean isSet = ((val >> pos) & 1) == 1;

assertTrue(isSet);
```

## 4.优化逐位解决方案

在我们可能需要大量执行这些计算的情况下，我们可能希望优化我们的解决方案，以使用最少数量的 CPU 指令。

让我们看一下左移解决方案的重写，它可能帮助我们实现这一点。它基于这样的假设，即按位运算通常比算术运算快:

```
boolean isSet = ((val << (~pos & 31)) < 0);
```

我们要注意，核心思想没有变。只是代码的编写有细微的不同:我们使用`(~pos & 31)`来代替前面的`(31-pos)`表达式。

为什么这两种表达效果一样？我们可以推导出这个过程:

```
(31 - pos) = (31 - pos) & 31
            = (31 + (-pos)) & 31
            = (31 & 31) + ((-pos) & 31)
            = (31 & 31) + ((~pos + 1) & 31)
            = (31 & 31) + (~pos & 31) + (1 & 31)
            = ((31 + 1) & 31) + (~pos & 31)
            = (32 & 31) + (~pos & 31)
            = 0 + (~pos & 31)
            = (~pos & 31)
```

本节开头我们提到最左边的位置是 31，最右边的位置是 0，所以`(31 – pos)`应该是正数或者零。如果我们在`(31 – pos)`和 31 之间做一个按位 AND ( `&`)运算，结果还是一样的。然后，我们一步一步来。最后，我们得到了`(~pos & 31)`表达式。

在这个过程中，还有一点需要说明:`(-pos)`如何转化为`(~pos + 1)`？为了得到整数的二进制补码负记数法[，我们可以做一个](https://web.archive.org/web/20220628091014/https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html#whyworks)[按位补码](/web/20220628091014/https://www.baeldung.com/java-bitwise-operators#4-bitwisecomplement-) ( `~`)运算，然后将结果加 1。

再进一步，我们可以使代码更简洁一点:

```
boolean isSet = ((val << ~pos) < 0);
```

在上面，我们已经略去了按位与( *&* )和 31。这是因为 JVM 将为我们做这项工作。一个`int`值有 32 位，JVM 确保它的有效移位范围应该在 0 到 31 之间。类似地，一个`long`值有 64 位，JVM 也确保它的有效移位范围应该在 0 到 63 之间。

## 5.使用`BigInteger`

虽然上面的二进制数学对于内置的数字类型来说是计算效率最高的，但是我们可能需要对超过 64 位的数字进行位检查，或者希望有更容易阅读的代码。

`BigInteger`类可以解决这两个问题。它支持非常大的位数，并提供了一个`testBit`方法:

```
int val = 0b0110_0100;
int pos = 2;
boolean isSet = BigInteger.valueOf(val).testBit(pos);

assertTrue(isSet);
```

## 6.结论

在本教程中，我们看了一些从整数值中获取某个位置的常用方法。

像往常一样，本教程的源代码可以在 GitHub 上找到[。](https://web.archive.org/web/20220628091014/https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-lang-operators-2)