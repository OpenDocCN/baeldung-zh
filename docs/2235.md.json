["```\r\npublic void traversePreOrder(Node node) {\r\n    if (node != null) {\r\n        visit(node.value);\r\n        traversePreOrder(node.left);\r\n        traversePreOrder(node.right);\r\n    }\r\n}\r\n```","```\r\npublic void traversePreOrderWithoutRecursion() {\r\n    Stack<Node> stack = new Stack<Node>();\r\n    Node current = root;\r\n    stack.push(root);\r\n    while(!stack.isEmpty()) {\r\n        current = stack.pop();\r\n        visit(current.value);\r\n\r\n        if(current.right != null) {\r\n            stack.push(current.right);\r\n        }    \r\n        if(current.left != null) {\r\n            stack.push(current.left);\r\n        }\r\n    }        \r\n}\r\n```","```\r\npublic void traverseInOrder(Node node) {\r\n    if (node != null) {\r\n        traverseInOrder(node.left);\r\n        visit(node.value);\r\n        traverseInOrder(node.right);\r\n    }\r\n}\r\n```","```\r\npublic void traverseInOrderWithoutRecursion() {\r\n    Stack stack = new Stack<>();\r\n    Node current = root;\r\n\r\n    while (current != null || !stack.isEmpty()) {\r\n        while (current != null) {\r\n            stack.push(current);\r\n            current = current.left;\r\n        }\r\n\r\n        Node top = stack.pop();\r\n        visit(top.value);\r\n        current = top.right;\r\n    }\r\n}\r\n```","```\r\npublic void traversePostOrder(Node node) {\r\n    if (node != null) {\r\n        traversePostOrder(node.left);\r\n        traversePostOrder(node.right);\r\n        visit(node.value);\r\n    }\r\n}\r\n```","```\r\npublic void traversePostOrderWithoutRecursion() {\r\n    Stack<Node> stack = new Stack<Node>();\r\n    Node prev = root;\r\n    Node current = root;\r\n    stack.push(root);\r\n\r\n    while (!stack.isEmpty()) {\r\n        current = stack.peek();\r\n        boolean hasChild = (current.left != null || current.right != null);\r\n        boolean isPrevLastChild = (prev == current.right || \r\n          (prev == current.left && current.right == null));\r\n\r\n        if (!hasChild || isPrevLastChild) {\r\n            current = stack.pop();\r\n            visit(current.value);\r\n            prev = current;\r\n        } else {\r\n            if (current.right != null) {\r\n                stack.push(current.right);\r\n            }\r\n            if (current.left != null) {\r\n                stack.push(current.left);\r\n            }\r\n        }\r\n    }   \r\n}\r\n```","```\r\npublic void dfs(int start) {\r\n    boolean[] isVisited = new boolean[adjVertices.size()];\r\n    dfsRecursive(start, isVisited);\r\n}\r\n\r\nprivate void dfsRecursive(int current, boolean[] isVisited) {\r\n    isVisited[current] = true;\r\n    visit(current);\r\n    for (int dest : adjVertices.get(current)) {\r\n        if (!isVisited[dest])\r\n            dfsRecursive(dest, isVisited);\r\n    }\r\n}\r\n```","```\r\npublic void dfsWithoutRecursion(int start) {\r\n    Stack<Integer> stack = new Stack<Integer>();\r\n    boolean[] isVisited = new boolean[adjVertices.size()];\r\n    stack.push(start);\r\n    while (!stack.isEmpty()) {\r\n        int current = stack.pop();\r\n        if(!isVisited[current]){\r\n            isVisited[current] = true;\r\n            visit(current);\r\n            for (int dest : adjVertices.get(current)) {\r\n                if (!isVisited[dest])\r\n                    stack.push(dest);\r\n            }\r\n    }\r\n}\r\n```","```\r\npublic List<Integer> topologicalSort(int start) {\r\n    LinkedList<Integer> result = new LinkedList<Integer>();\r\n    boolean[] isVisited = new boolean[adjVertices.size()];\r\n    topologicalSortRecursive(start, isVisited, result);\r\n    return result;\r\n}\r\n\r\nprivate void topologicalSortRecursive(int current, boolean[] isVisited, LinkedList<Integer> result) {\r\n    isVisited[current] = true;\r\n    for (int dest : adjVertices.get(current)) {\r\n        if (!isVisited[dest])\r\n            topologicalSortRecursive(dest, isVisited, result);\r\n    }\r\n    result.addFirst(current);\r\n}\r\n```"]