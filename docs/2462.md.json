["```\r\n$ cat theLordOfRings.txt\r\ntitle:The Lord of the Rings: The Return of the King\r\ndirector:Peter Jackson\r\nactor:Sean Astin\r\nactor:Ian McKellen\r\nGandalf and Aragorn lead the World of Men against Sauron's\r\narmy to draw his gaze from Frodo and Sam as they approach Mount Doom with the One Ring.\r\n```","```\r\nenum DupKeyOption {\r\n    OVERWRITE, DISCARD\r\n} \r\n```","```\r\npublic static Map<String, String> byBufferedReader(String filePath, DupKeyOption dupKeyOption) {\r\n    HashMap<String, String> map = new HashMap<>();\r\n    String line;\r\n    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\r\n        while ((line = reader.readLine()) != null) {\r\n            String[] keyValuePair = line.split(\":\", 2);\r\n            if (keyValuePair.length > 1) {\r\n                String key = keyValuePair[0];\r\n                String value = keyValuePair[1];\r\n                if (DupKeyOption.OVERWRITE == dupKeyOption) {\r\n                    map.put(key, value);\r\n                } else if (DupKeyOption.DISCARD == dupKeyOption) {\r\n                    map.putIfAbsent(key, value);\r\n                }\r\n            } else {\r\n                System.out.println(\"No Key:Value found in line, ignoring: \" + line);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return map;\r\n} \r\n```","```\r\nprivate static final Map<String, String> EXPECTED_MAP_DISCARD = Stream.of(new String[][]{\r\n    {\"title\", \"The Lord of the Rings: The Return of the King\"},\r\n    {\"director\", \"Peter Jackson\"},\r\n    {\"actor\", \"Sean Astin\"}\r\n  }).collect(Collectors.toMap(data -> data[0], data -> data[1]));\r\n\r\nprivate static final Map<String, String> EXPECTED_MAP_OVERWRITE = Stream.of(new String[][]{\r\n...\r\n    {\"actor\", \"Ian McKellen\"}\r\n  }).collect(Collectors.toMap(data -> data[0], data -> data[1]));\r\n```","```\r\n@Test\r\npublic void givenInputFile_whenInvokeByBufferedReader_shouldGetExpectedMap() {\r\n    Map<String, String> mapOverwrite = FileToHashMap.byBufferedReader(filePath, FileToHashMap.DupKeyOption.OVERWRITE);\r\n    assertThat(mapOverwrite).isEqualTo(EXPECTED_MAP_OVERWRITE);\r\n\r\n    Map<String, String> mapDiscard = FileToHashMap.byBufferedReader(filePath, FileToHashMap.DupKeyOption.DISCARD);\r\n    assertThat(mapDiscard).isEqualTo(EXPECTED_MAP_DISCARD);\r\n} \r\n```","```\r\npublic static Map<String, String> byStream(String filePath, DupKeyOption dupKeyOption) {\r\n    Map<String, String> map = new HashMap<>();\r\n    try (Stream<String> lines = Files.lines(Paths.get(filePath))) {\r\n        lines.filter(line -> line.contains(\":\"))\r\n            .forEach(line -> {\r\n                String[] keyValuePair = line.split(\":\", 2);\r\n                String key = keyValuePair[0];\r\n                String value = keyValuePair[1];\r\n                if (DupKeyOption.OVERWRITE == dupKeyOption) {\r\n                    map.put(key, value);\r\n                } else if (DupKeyOption.DISCARD == dupKeyOption) {\r\n                    map.putIfAbsent(key, value);\r\n                }\r\n            });\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return map;\r\n} \r\n```","```\r\n@Test\r\npublic void givenInputFile_whenInvokeByStream_shouldGetExpectedMap() {\r\n    Map<String, String> mapOverwrite = FileToHashMap.byStream(filePath, FileToHashMap.DupKeyOption.OVERWRITE);\r\n    assertThat(mapOverwrite).isEqualTo(EXPECTED_MAP_OVERWRITE);\r\n\r\n    Map<String, String> mapDiscard = FileToHashMap.byStream(filePath, FileToHashMap.DupKeyOption.DISCARD);\r\n    assertThat(mapDiscard).isEqualTo(EXPECTED_MAP_DISCARD);\r\n} \r\n```","```\r\npublic static Map<String, List<String>> aggregateByKeys(String filePath) {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    try (Stream<String> lines = Files.lines(Paths.get(filePath))) {\r\n        lines.filter(line -> line.contains(\":\"))\r\n          .forEach(line -> {\r\n              String[] keyValuePair = line.split(\":\", 2);\r\n              String key = keyValuePair[0];\r\n              String value = keyValuePair[1];\r\n              if (map.containsKey(key)) {\r\n                  map.get(key).add(value);\r\n              } else {\r\n                  map.put(key, Stream.of(value).collect(Collectors.toList()));\r\n              }\r\n          });\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return map;\r\n} \r\n```","```\r\nprivate static final Map<String, List<String>> EXPECTED_MAP_AGGREGATE = Stream.of(new String[][]{\r\n      {\"title\", \"The Lord of the Rings: The Return of the King\"},\r\n      {\"director\", \"Peter Jackson\"},\r\n      {\"actor\", \"Sean Astin\", \"Ian McKellen\"}\r\n  }).collect(Collectors.toMap(arr -> arr[0], arr -> Arrays.asList(Arrays.copyOfRange(arr, 1, arr.length))));\r\n```","```\r\n@Test\r\npublic void givenInputFile_whenInvokeAggregateByKeys_shouldGetExpectedMap() {\r\n    Map<String, List<String>> mapAgg = FileToHashMap.aggregateByKeys(filePath);\r\n    assertThat(mapAgg).isEqualTo(EXPECTED_MAP_AGGREGATE);\r\n}\r\n```"]