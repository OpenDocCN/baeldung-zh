["```\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-context</artifactId>\r\n    <version>5.2.6.RELEASE</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-expression</artifactId>\r\n    <version>5.2.6.RELEASE</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>com.google.guava</groupId>\r\n    <artifactId>guava</artifactId>\r\n    <version>31.0.1-jre</version>\r\n</dependency>\r\n```","```\r\npublic final class GlobalEventBus {\r\n\r\n    public static final String GLOBAL_EVENT_BUS_EXPRESSION\r\n      = \"T(com.baeldung.postprocessor.GlobalEventBus).getEventBus()\";\r\n\r\n    private static final String IDENTIFIER = \"global-event-bus\";\r\n    private static final GlobalEventBus GLOBAL_EVENT_BUS = new GlobalEventBus();\r\n    private final EventBus eventBus = new AsyncEventBus(IDENTIFIER, Executors.newCachedThreadPool());\r\n\r\n    private GlobalEventBus() {}\r\n\r\n    public static GlobalEventBus getInstance() {\r\n        return GlobalEventBus.GLOBAL_EVENT_BUS;\r\n    }\r\n\r\n    public static EventBus getEventBus() {\r\n        return GlobalEventBus.GLOBAL_EVENT_BUS.eventBus;\r\n    }\r\n\r\n    public static void subscribe(Object obj) {\r\n        getEventBus().register(obj);\r\n    }\r\n    public static void unsubscribe(Object obj) {\r\n        getEventBus().unregister(obj);\r\n    }\r\n    public static void post(Object event) {\r\n        getEventBus().post(event);\r\n    }\r\n}\r\n```","```\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@Inherited\r\npublic @interface Subscriber {\r\n    String value() default GlobalEventBus.GLOBAL_EVENT_BUS_EXPRESSION;\r\n}\r\n```","```\r\npublic class GuavaEventBusBeanPostProcessor\r\n  implements DestructionAwareBeanPostProcessor {\r\n\r\n    Logger logger = LoggerFactory.getLogger(this.getClass());\r\n    SpelExpressionParser expressionParser = new SpelExpressionParser();\r\n\r\n    @Override\r\n    public void postProcessBeforeDestruction(Object bean, String beanName)\r\n      throws BeansException {\r\n        this.process(bean, EventBus::unregister, \"destruction\");\r\n    }\r\n\r\n    @Override\r\n    public boolean requiresDestruction(Object bean) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n      throws BeansException {\r\n        return bean;\r\n    }\r\n\r\n    @Override\r\n    public Object postProcessAfterInitialization(Object bean, String beanName)\r\n      throws BeansException {\r\n        this.process(bean, EventBus::register, \"initialization\");\r\n        return bean;\r\n    }\r\n\r\n    private void process(Object bean, BiConsumer<EventBus, Object> consumer, String action) {\r\n       // See implementation below\r\n    }\r\n}\r\n```","```\r\nprivate void process(Object bean, BiConsumer<EventBus, Object> consumer, String action) {\r\n    Object proxy = this.getTargetObject(bean);\r\n    Subscriber annotation = AnnotationUtils.getAnnotation(proxy.getClass(), Subscriber.class);\r\n    if (annotation == null)\r\n        return;\r\n    this.logger.info(\"{}: processing bean of type {} during {}\",\r\n      this.getClass().getSimpleName(), proxy.getClass().getName(), action);\r\n    String annotationValue = annotation.value();\r\n    try {\r\n        Expression expression = this.expressionParser.parseExpression(annotationValue);\r\n        Object value = expression.getValue();\r\n        if (!(value instanceof EventBus)) {\r\n            this.logger.error(\r\n              \"{}: expression {} did not evaluate to an instance of EventBus for bean of type {}\",\r\n              this.getClass().getSimpleName(), annotationValue, proxy.getClass().getSimpleName());\r\n            return;\r\n        }\r\n        EventBus eventBus = (EventBus)value;\r\n        consumer.accept(eventBus, proxy);\r\n    } catch (ExpressionException ex) {\r\n        this.logger.error(\"{}: unable to parse/evaluate expression {} for bean of type {}\",\r\n          this.getClass().getSimpleName(), annotationValue, proxy.getClass().getName());\r\n    }\r\n}\r\n```","```\r\nprivate Object getTargetObject(Object proxy) throws BeansException {\r\n    if (AopUtils.isJdkDynamicProxy(proxy)) {\r\n        try {\r\n            return ((Advised)proxy).getTargetSource().getTarget();\r\n        } catch (Exception e) {\r\n            throw new FatalBeanException(\"Error getting target of JDK proxy\", e);\r\n        }\r\n    }\r\n    return proxy;\r\n}\r\n```","```\r\npublic class StockTrade {\r\n\r\n    private String symbol;\r\n    private int quantity;\r\n    private double price;\r\n    private Date tradeDate;\r\n\r\n    // constructor\r\n}\r\n```","```\r\n@FunctionalInterface\r\npublic interface StockTradeListener {\r\n    void stockTradePublished(StockTrade trade);\r\n}\r\n```","```\r\n@Subscriber\r\npublic class StockTradePublisher {\r\n\r\n    Set<StockTradeListener> stockTradeListeners = new HashSet<>();\r\n\r\n    public void addStockTradeListener(StockTradeListener listener) {\r\n        synchronized (this.stockTradeListeners) {\r\n            this.stockTradeListeners.add(listener);\r\n        }\r\n    }\r\n\r\n    public void removeStockTradeListener(StockTradeListener listener) {\r\n        synchronized (this.stockTradeListeners) {\r\n            this.stockTradeListeners.remove(listener);\r\n        }\r\n    }\r\n\r\n    @Subscribe\r\n    @AllowConcurrentEvents\r\n    void handleNewStockTradeEvent(StockTrade trade) {\r\n        // publish to DB, send to PubNub, ...\r\n        Set<StockTradeListener> listeners;\r\n        synchronized (this.stockTradeListeners) {\r\n            listeners = new HashSet<>(this.stockTradeListeners);\r\n        }\r\n        listeners.forEach(li -> li.stockTradePublished(trade));\r\n    }\r\n}\r\n```","```\r\n@Configuration\r\npublic class PostProcessorConfiguration {\r\n\r\n    @Bean\r\n    public GlobalEventBus eventBus() {\r\n        return GlobalEventBus.getInstance();\r\n    }\r\n\r\n    @Bean\r\n    public GuavaEventBusBeanPostProcessor eventBusBeanPostProcessor() {\r\n        return new GuavaEventBusBeanPostProcessor();\r\n    }\r\n\r\n    @Bean\r\n    public StockTradePublisher stockTradePublisher() {\r\n        return new StockTradePublisher();\r\n    }\r\n}\r\n```","```\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n@ContextConfiguration(classes = PostProcessorConfiguration.class)\r\npublic class StockTradeIntegrationTest {\r\n\r\n    @Autowired\r\n    StockTradePublisher stockTradePublisher;\r\n\r\n    @Test\r\n    public void givenValidConfig_whenTradePublished_thenTradeReceived() {\r\n        Date tradeDate = new Date();\r\n        StockTrade stockTrade = new StockTrade(\"AMZN\", 100, 2483.52d, tradeDate);\r\n        AtomicBoolean assertionsPassed = new AtomicBoolean(false);\r\n        StockTradeListener listener = trade -> assertionsPassed\r\n          .set(this.verifyExact(stockTrade, trade));\r\n        this.stockTradePublisher.addStockTradeListener(listener);\r\n        try {\r\n            GlobalEventBus.post(stockTrade);\r\n            await().atMost(Duration.ofSeconds(2L))\r\n              .untilAsserted(() -> assertThat(assertionsPassed.get()).isTrue());\r\n        } finally {\r\n            this.stockTradePublisher.removeStockTradeListener(listener);\r\n        }\r\n    }\r\n\r\n    boolean verifyExact(StockTrade stockTrade, StockTrade trade) {\r\n        return Objects.equals(stockTrade.getSymbol(), trade.getSymbol())\r\n          && Objects.equals(stockTrade.getTradeDate(), trade.getTradeDate())\r\n          && stockTrade.getQuantity() == trade.getQuantity()\r\n          && stockTrade.getPrice() == trade.getPrice();\r\n    }\r\n}\r\n```"]