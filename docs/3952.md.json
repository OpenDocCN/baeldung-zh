["```\r\n<dependency>\r\n    <groupId>io.github.resilience4j</groupId>\r\n    <artifactId>resilience4j-circuitbreaker</artifactId>\r\n    <version>0.12.1</version>\r\n</dependency>\r\n```","```\r\nCircuitBreakerRegistry circuitBreakerRegistry\r\n  = CircuitBreakerRegistry.ofDefaults();\r\n```","```\r\nCircuitBreakerConfig config = CircuitBreakerConfig.custom()\r\n  .failureRateThreshold(20)\r\n  .ringBufferSizeInClosedState(5)\r\n  .build();\r\n```","```\r\ninterface RemoteService {\r\n    int process(int i);\r\n}\r\n\r\nCircuitBreakerRegistry registry = CircuitBreakerRegistry.of(config);\r\nCircuitBreaker circuitBreaker = registry.circuitBreaker(\"my\");\r\nFunction<Integer, Integer> decorated = CircuitBreaker\r\n  .decorateFunction(circuitBreaker, service::process);\r\n```","```\r\nwhen(service.process(any(Integer.class))).thenThrow(new RuntimeException());\r\n\r\nfor (int i = 0; i < 10; i++) {\r\n    try {\r\n        decorated.apply(i);\r\n    } catch (Exception ignore) {}\r\n}\r\n\r\nverify(service, times(5)).process(any(Integer.class));\r\n```","```\r\nRateLimiterConfig config = RateLimiterConfig.custom().limitForPeriod(2).build();\r\nRateLimiterRegistry registry = RateLimiterRegistry.of(config);\r\nRateLimiter rateLimiter = registry.rateLimiter(\"my\");\r\nFunction<Integer, Integer> decorated\r\n  = RateLimiter.decorateFunction(rateLimiter, service::process);\r\n```","```\r\nBulkheadConfig config = BulkheadConfig.custom().maxConcurrentCalls(1).build();\r\nBulkheadRegistry registry = BulkheadRegistry.of(config);\r\nBulkhead bulkhead = registry.bulkhead(\"my\");\r\nFunction<Integer, Integer> decorated\r\n  = Bulkhead.decorateFunction(bulkhead, service::process);\r\n```","```\r\nCountDownLatch latch = new CountDownLatch(1);\r\nwhen(service.process(anyInt())).thenAnswer(invocation -> {\r\n    latch.countDown();\r\n    Thread.currentThread().join();\r\n    return null;\r\n});\r\n\r\nForkJoinTask<?> task = ForkJoinPool.commonPool().submit(() -> {\r\n    try {\r\n        decorated.apply(1);\r\n    } finally {\r\n        bulkhead.onComplete();\r\n    }\r\n});\r\nlatch.await();\r\nassertThat(bulkhead.isCallPermitted()).isFalse();\r\n```","```\r\nRetryConfig config = RetryConfig.custom().maxAttempts(2).build();\r\nRetryRegistry registry = RetryRegistry.of(config);\r\nRetry retry = registry.retry(\"my\");\r\nFunction<Integer, Void> decorated\r\n  = Retry.decorateFunction(retry, (Integer s) -> {\r\n        service.process(s);\r\n        return null;\r\n    });\r\n```","```\r\nwhen(service.process(anyInt())).thenThrow(new RuntimeException());\r\ntry {\r\n    decorated.apply(1);\r\n    fail(\"Expected an exception to be thrown if all retries failed\");\r\n} catch (Exception e) {\r\n    verify(service, times(2)).process(any(Integer.class));\r\n}\r\n```","```\r\njavax.cache.Cache cache = ...; // Use appropriate cache here\r\nCache<Integer, Integer> cacheContext = Cache.of(cache);\r\nFunction<Integer, Integer> decorated\r\n  = Cache.decorateSupplier(cacheContext, () -> service.process(1));\r\n```","```\r\nlong ttl = 1;\r\nTimeLimiterConfig config\r\n  = TimeLimiterConfig.custom().timeoutDuration(Duration.ofMillis(ttl)).build();\r\nTimeLimiter timeLimiter = TimeLimiter.of(config);\r\n```","```\r\nFuture futureMock = mock(Future.class);\r\nCallable restrictedCall\r\n  = TimeLimiter.decorateFutureSupplier(timeLimiter, () -> futureMock);\r\nrestrictedCall.call();\r\n\r\nverify(futureMock).get(ttl, TimeUnit.MILLISECONDS);\r\n```","```\r\nCallable chainedCallable\r\n  = CircuitBreaker.decorateCallable(circuitBreaker, restrictedCall);\r\n```"]