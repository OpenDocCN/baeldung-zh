["```\r\npublic class SimpleExclusiveLockByKey {\r\n\r\n    private static Set<String> usedKeys= ConcurrentHashMap.newKeySet();\r\n\r\n    public boolean tryLock(String key) {\r\n        return usedKeys.add(key);\r\n    }\r\n\r\n    public void unlock(String key) {\r\n        usedKeys.remove(key);\r\n    }\r\n\r\n}\r\n```","```\r\nString key = \"key\";\r\nSimpleExclusiveLockByKey lockByKey = new SimpleExclusiveLockByKey();\r\ntry {\r\n    lockByKey.tryLock(key);\r\n    // insert the code that needs to be executed only if the key lock is available\r\n} finally { // CRUCIAL\r\n    lockByKey.unlock(key);\r\n}\r\n```","```\r\nprivate static class LockWrapper {\r\n    private final Lock lock = new ReentrantLock();\r\n    private final AtomicInteger numberOfThreadsInQueue = new AtomicInteger(1);\r\n\r\n    private LockWrapper addThreadInQueue() {\r\n        numberOfThreadsInQueue.incrementAndGet(); \r\n        return this;\r\n    }\r\n\r\n    private int removeThreadFromQueue() {\r\n        return numberOfThreadsInQueue.decrementAndGet(); \r\n    }\r\n\r\n}\r\n```","```\r\nprivate static ConcurrentHashMap<String, LockWrapper> locks = new ConcurrentHashMap<String, LockWrapper>(); \r\n```","```\r\npublic void lock(String key) {\r\n    LockWrapper lockWrapper = locks.compute(key, (k, v) -> v == null ? new LockWrapper() : v.addThreadInQueue());\r\n    lockWrapper.lock.lock();\r\n}\r\n```","```\r\npublic void unlock(String key) {\r\n    LockWrapper lockWrapper = locks.get(key);\r\n    lockWrapper.lock.unlock();\r\n    if (lockWrapper.removeThreadFromQueue() == 0) { \r\n        // NB : We pass in the specific value to remove to handle the case where another thread would queue right before the removal\r\n        locks.remove(key, lockWrapper);\r\n    }\r\n}\r\n```","```\r\npublic class LockByKey {\r\n\r\n    private static class LockWrapper {\r\n        private final Lock lock = new ReentrantLock();\r\n        private final AtomicInteger numberOfThreadsInQueue = new AtomicInteger(1);\r\n\r\n        private LockWrapper addThreadInQueue() {\r\n            numberOfThreadsInQueue.incrementAndGet(); \r\n            return this;\r\n        }\r\n\r\n        private int removeThreadFromQueue() {\r\n            return numberOfThreadsInQueue.decrementAndGet(); \r\n        }\r\n\r\n    }\r\n\r\n    private static ConcurrentHashMap<String, LockWrapper> locks = new ConcurrentHashMap<String, LockWrapper>();\r\n\r\n    public void lock(String key) {\r\n        LockWrapper lockWrapper = locks.compute(key, (k, v) -> v == null ? new LockWrapper() : v.addThreadInQueue());\r\n        lockWrapper.lock.lock();\r\n    }\r\n\r\n    public void unlock(String key) {\r\n        LockWrapper lockWrapper = locks.get(key);\r\n        lockWrapper.lock.unlock();\r\n        if (lockWrapper.removeThreadFromQueue() == 0) { \r\n            // NB : We pass in the specific value to remove to handle the case where another thread would queue right before the removal\r\n            locks.remove(key, lockWrapper);\r\n        }\r\n    }\r\n\r\n}\r\n```","```\r\nString key = \"key\"; \r\nLockByKey lockByKey = new LockByKey(); \r\ntry { \r\n    lockByKey.lock(key);\r\n    // insert your code here \r\n} finally { // CRUCIAL \r\n    lockByKey.unlock(key); \r\n}\r\n```","```\r\npublic class SimultaneousEntriesLockByKey {\r\n\r\n    private static final int ALLOWED_THREADS = 2;\r\n\r\n    private static ConcurrentHashMap<String, Semaphore> semaphores = new ConcurrentHashMap<String, Semaphore>();\r\n\r\n    public void lock(String key) {\r\n        Semaphore semaphore = semaphores.compute(key, (k, v) -> v == null ? new Semaphore(ALLOWED_THREADS) : v);\r\n        semaphore.acquireUninterruptibly();\r\n    }\r\n\r\n    public void unlock(String key) {\r\n        Semaphore semaphore = semaphores.get(key);\r\n        semaphore.release();\r\n        if (semaphore.availablePermits() == ALLOWED_THREADS) { \r\n            semaphores.remove(key, semaphore);\r\n        }  \r\n    }\r\n\r\n}\r\n```","```\r\nString key = \"key\"; \r\nSimultaneousEntriesLockByKey lockByKey = new SimultaneousEntriesLockByKey(); \r\ntry { \r\n    lockByKey.lock(key); \r\n    // insert your code here \r\n} finally { // CRUCIAL \r\n    lockByKey.unlock(key); \r\n}\r\n```"]