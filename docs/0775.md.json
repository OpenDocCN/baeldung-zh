["```\r\npublic class BaeldungSynchronizedMethods {\r\n\r\n    private int sum = 0;\r\n\r\n    public void calculate() {\r\n        setSum(getSum() + 1);\r\n    }\r\n\r\n    // standard setters and getters\r\n} \r\n```","```\r\n@Test\r\npublic void givenMultiThread_whenNonSyncMethod() {\r\n    ExecutorService service = Executors.newFixedThreadPool(3);\r\n    BaeldungSynchronizedMethods summation = new BaeldungSynchronizedMethods();\r\n\r\n    IntStream.range(0, 1000)\r\n      .forEach(count -> service.submit(summation::calculate));\r\n    service.awaitTermination(1000, TimeUnit.MILLISECONDS);\r\n\r\n    assertEquals(1000, summation.getSum());\r\n}\r\n```","```\r\njava.lang.AssertionError: expected:<1000> but was:<965>\r\nat org.junit.Assert.fail(Assert.java:88)\r\nat org.junit.Assert.failNotEquals(Assert.java:834)\r\n...\r\n```","```\r\npublic synchronized void synchronisedCalculate() {\r\n    setSum(getSum() + 1);\r\n}\r\n```","```\r\n@Test\r\npublic void givenMultiThread_whenMethodSync() {\r\n    ExecutorService service = Executors.newFixedThreadPool(3);\r\n    SynchronizedMethods method = new SynchronizedMethods();\r\n\r\n    IntStream.range(0, 1000)\r\n      .forEach(count -> service.submit(method::synchronisedCalculate));\r\n    service.awaitTermination(1000, TimeUnit.MILLISECONDS);\r\n\r\n    assertEquals(1000, method.getSum());\r\n}\r\n```","```\r\n public static synchronized void syncStaticCalculate() {\r\n     staticSum = staticSum + 1;\r\n }\r\n```","```\r\n@Test\r\npublic void givenMultiThread_whenStaticSyncMethod() {\r\n    ExecutorService service = Executors.newCachedThreadPool();\r\n\r\n    IntStream.range(0, 1000)\r\n      .forEach(count -> \r\n        service.submit(BaeldungSynchronizedMethods::syncStaticCalculate));\r\n    service.awaitTermination(100, TimeUnit.MILLISECONDS);\r\n\r\n    assertEquals(1000, BaeldungSynchronizedMethods.staticSum);\r\n}\r\n```","```\r\npublic void performSynchronisedTask() {\r\n    synchronized (this) {\r\n        setCount(getCount()+1);\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenMultiThread_whenBlockSync() {\r\n    ExecutorService service = Executors.newFixedThreadPool(3);\r\n    BaeldungSynchronizedBlocks synchronizedBlocks = new BaeldungSynchronizedBlocks();\r\n\r\n    IntStream.range(0, 1000)\r\n      .forEach(count -> \r\n        service.submit(synchronizedBlocks::performSynchronisedTask));\r\n    service.awaitTermination(100, TimeUnit.MILLISECONDS);\r\n\r\n    assertEquals(1000, synchronizedBlocks.getCount());\r\n}\r\n```","```\r\npublic static void performStaticSyncTask(){\r\n    synchronized (SynchronisedBlocks.class) {\r\n        setStaticCount(getStaticCount() + 1);\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenMultiThread_whenStaticSyncBlock() {\r\n    ExecutorService service = Executors.newCachedThreadPool();\r\n\r\n    IntStream.range(0, 1000)\r\n      .forEach(count -> \r\n        service.submit(BaeldungSynchronizedBlocks::performStaticSyncTask));\r\n    service.awaitTermination(100, TimeUnit.MILLISECONDS);\r\n\r\n    assertEquals(1000, BaeldungSynchronizedBlocks.getStaticCount());\r\n}\r\n```","```\r\nObject lock = new Object();\r\nsynchronized (lock) {\r\n    System.out.println(\"First time acquiring it\");\r\n\r\n    synchronized (lock) {\r\n        System.out.println(\"Entering again\");\r\n\r\n         synchronized (lock) {\r\n             System.out.println(\"And again\");\r\n         }\r\n    }\r\n}\r\n```"]