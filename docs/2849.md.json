["```\r\nservices:\r\n  zookeeper:\r\n    image: confluentinc/cp-zookeeper:6.2.0\r\n    hostname: zookeeper\r\n    ...\r\n\r\n  broker:\r\n    image: confluentinc/cp-kafka:6.2.0\r\n    hostname: broker\r\n    ...\r\n\r\n  ksqldb-server:\r\n    image: confluentinc/ksqldb-server:0.19.0\r\n    hostname: ksqldb-server\r\n    depends_on:\r\n      - broker\r\n    ports:\r\n      - \"8088:8088\"\r\n    healthcheck:\r\n      test: curl -f http://ksqldb-server:8088/ || exit 1\r\n    environment:\r\n      KSQL_LISTENERS: http://0.0.0.0:8088\r\n      KSQL_BOOTSTRAP_SERVERS: broker:9092\r\n      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\r\n      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\r\n\r\n  ksqldb-cli:\r\n    image: confluentinc/ksqldb-cli:0.19.0\r\n    container_name: ksqldb-cli\r\n    depends_on:\r\n      - broker\r\n      - ksqldb-server\r\n    entrypoint: /bin/sh\r\n    tty: true\r\n```","```\r\ndocker-compose up\r\n```","```\r\ndocker exec -it ksqldb-cli ksql http://ksqldb-server:8088\r\n```","```\r\nksql> SET 'auto.offset.reset' = 'earliest';\r\n```","```\r\n<repository>\r\n    <id>confluent</id>\r\n    <name>confluent-repo</name>\r\n    <url>http://packages.confluent.io/maven/</url>\r\n</repository>\r\n```","```\r\n<dependency>\r\n    <groupId>io.confluent.ksql</groupId>\r\n    <artifactId>ksqldb-api-client</artifactId>\r\n    <version>6.2.0</version>\r\n</dependency>\r\n```","```\r\nCREATE STREAM readings (sensor_id VARCHAR KEY, timestamp VARCHAR, reading INT)\r\n  WITH (KAFKA_TOPIC = 'readings',\r\n        VALUE_FORMAT = 'JSON',\r\n        TIMESTAMP = 'timestamp',\r\n        TIMESTAMP_FORMAT = 'yyyy-MM-dd HH:mm:ss',\r\n        PARTITIONS = 1);\r\n```","```\r\nClientOptions options = ClientOptions.create()\r\n  .setHost(KSQLDB_SERVER_HOST)\r\n  .setPort(KSQLDB_SERVER_PORT);\r\n\r\nClient client = Client.create(options);\r\n\r\nMap<String, Object> properties = Collections.singletonMap(\r\n  \"auto.offset.reset\", \"earliest\"\r\n);\r\n\r\nCompletableFuture<ExecuteStatementResult> result = \r\n  client.executeStatement(CREATE_READINGS_STREAM, properties); \r\n```","```\r\nCREATE TABLE alerts AS\r\n  SELECT\r\n    sensor_id,\r\n    TIMESTAMPTOSTRING(WINDOWSTART, 'yyyy-MM-dd HH:mm:ss', 'UTC') \r\n      AS start_period,\r\n    TIMESTAMPTOSTRING(WINDOWEND, 'yyyy-MM-dd HH:mm:ss', 'UTC') \r\n      AS end_period,\r\n    AVG(reading) AS average_reading\r\n  FROM readings\r\n  WINDOW TUMBLING (SIZE 30 MINUTES)\r\n  GROUP BY id \r\n  HAVING AVG(reading) > 25\r\n  EMIT CHANGES;\r\n```","```\r\nCompletableFuture<ExecuteStatementResult> result = \r\n  client.executeStatement(CREATE_ALERTS_TABLE, properties)\r\n```","```\r\nList<KsqlObject> rows = Arrays.asList(\r\n  new KsqlObject().put(\"sensor_id\", \"sensor-1\")\r\n    .put(\"timestamp\", \"2021-08-01 09:00:00\").put(\"reading\", 22),\r\n  new KsqlObject().put(\"sensor_id\", \"sensor-1\")\r\n    .put(\"timestamp\", \"2021-08-01 09:10:00\").put(\"reading\", 20),\r\n  new KsqlObject().put(\"sensor_id\", \"sensor-2\")\r\n    .put(\"timestamp\", \"2021-08-01 10:00:00\").put(\"reading\", 26),\r\n\r\n  // additional rows\r\n);\r\n\r\nCompletableFuture<Void> result = CompletableFuture.allOf(\r\n  rows.stream()\r\n    .map(row -> client.insertInto(READINGS_TABLE, row))\r\n    .toArray(CompletableFuture[]::new)\r\n);\r\n```","```\r\nSELECT * FROM alerts EMIT CHANGES;\r\n```","```\r\npublic CompletableFuture<Void> subscribeOnAlerts(Subscriber<Row> subscriber) {\r\n    return client.streamQuery(ALERTS_QUERY, PROPERTIES)\r\n      .thenAccept(streamedQueryResult -> streamedQueryResult.subscribe(subscriber))\r\n      .whenComplete((result, ex) -> {\r\n          if (ex != null) {\r\n              log.error(\"Alerts push query failed\", ex);\r\n          }\r\n      });\r\n}\r\n```","```\r\n@Testcontainers\r\nclass KsqlDBApplicationLiveTest {\r\n\r\n    @Container\r\n    public static DockerComposeContainer dockerComposeContainer =\r\n      new DockerComposeContainer<>(KSQLDB_COMPOSE_FILE)\r\n        .withServices(\"zookeeper\", \"broker\", \"ksqldb-server\")\r\n        .withExposedService(\"ksqldb-server\", 8088,\r\n          Wait.forHealthcheck().withStartupTimeout(Duration.ofMinutes(5)))\r\n        .withLocalCompose(true);\r\n\r\n    // setup and teardown\r\n\r\n    @Test\r\n    void givenSensorReadings_whenSubscribedToAlerts_thenAlertsAreConsumed() {\r\n        createAlertsMaterializedView();\r\n\r\n        // Reactive Streams Subscriber impl for receiving streaming data\r\n        RowSubscriber<Alert> alertSubscriber = new RowSubscriber<>(Alert.class);\r\n\r\n        ksqlDBApplication.subscribeOnAlerts(alertSubscriber);\r\n        insertSampleData();\r\n\r\n        await().atMost(Duration.ofMinutes(3)).untilAsserted(() ->\r\n          assertThat(alertSubscriber.consumedItems)\r\n            .containsOnly(\r\n              expectedAlert(\"sensor-1\", \"2021-08-01 09:30:00\", \"2021-08-01 10:00:00\", 28.0),\r\n              expectedAlert(\"sensor-2\", \"2021-08-01 10:00:00\", \"2021-08-01 10:30:00\", 26.0)\r\n            )\r\n        );\r\n    }\r\n}\r\n```","```\r\nString pullQuery = \"SELECT * FROM alerts WHERE sensor_id = 'sensor-2';\";\r\n\r\nList<Row> rows = client.executeQuery(pullQuery, PROPERTIES).get() \r\n```"]