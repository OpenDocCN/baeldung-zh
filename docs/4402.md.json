["```\r\nString inputString = \"someString789\";\r\nboolean result = CharMatcher.javaLetterOrDigit().matchesAllOf(inputString); \r\n```","```\r\nString number = \"8 123 456 123\";\r\nString result = CharMatcher.whitespace().collapseFrom(number, '-'); \r\n```","```\r\nString number = \"8 123 456 123\";\r\nint result = CharMatcher.digit().countIn(number);\r\n```","```\r\nIllegalArgumentException e = new IllegalArgumentException(\"Some argument is incorrect\");\r\nList<StackTraceElement> stackTraceElements = Throwables.lazyStackTrace(e); \r\n```","```\r\nUser[] usersArray = {new User(1L, \"John\", 45), new User(2L, \"Max\", 15)};\r\nImmutableMultiset<User> users = FluentIterable.of(usersArray).toMultiset();\r\n```","```\r\nList<String> userNames = Arrays.asList(\"David\", \"Eugen\", \"Alex\", \"Alex\", \"David\", \"David\", \"David\");\r\n\r\nMultiset<String> userNamesMultiset = HashMultiset.create(userNames);\r\n\r\nassertEquals(7, userNamesMultiset.size());\r\nassertEquals(4, userNamesMultiset.count(\"David\"));\r\nassertEquals(2, userNamesMultiset.count(\"Alex\"));\r\nassertEquals(1, userNamesMultiset.count(\"Eugen\"));\r\nassertThat(userNamesMultiset.elementSet(), anyOf(containsInAnyOrder(\"Alex\", \"David\", \"Eugen\")));\r\n```","```\r\nRangeSet<Integer> rangeSet = TreeRangeSet.create();\r\nrangeSet.add(Range.closed(1, 10));\r\n```","```\r\nrangeSet.add(Range.closed(5, 15));\r\n```","```\r\nrangeSet.add(Range.closedOpen(10, 17));\r\n```","```\r\nrangeSet.contains(15);\r\n```","```\r\nrangeSet.contains(17); \r\n```","```\r\nrangeSet.encloses(Range.closed(2, 3));\r\n```","```\r\nrangeSet.add(Range.greaterThan(22)); \r\n```","```\r\nList<String> first = Lists.newArrayList(\"value1\", \"value2\");\r\nList<String> second = Lists.newArrayList(\"value3\", \"value4\");\r\n\r\nList<List<String>> cartesianProduct = Lists.cartesianProduct(first, second);\r\n\r\nList<String> pair1 = Lists.newArrayList(\"value2\", \"value3\");\r\nList<String> pair2 = Lists.newArrayList(\"value2\", \"value4\");\r\nList<String> pair3 = Lists.newArrayList(\"value1\", \"value3\");\r\nList<String> pair4 = Lists.newArrayList(\"value1\", \"value4\");\r\n\r\nassertThat(cartesianProduct, anyOf(containsInAnyOrder(pair1, pair2, pair3, pair4))); \r\n```","```\r\nLinkedHashMap<Object, Object> someLinkedMap = Maps.newLinkedHashMapWithExpectedSize(512);\r\n```","```\r\nMultiset<String> multisetToModify = HashMultiset.create();\r\nMultiset<String> occurrencesToRemove = HashMultiset.create();\r\n\r\nmultisetToModify.add(\"John\");\r\nmultisetToModify.add(\"Max\");\r\nmultisetToModify.add(\"Alex\");\r\n\r\noccurrencesToRemove.add(\"Alex\");\r\noccurrencesToRemove.add(\"John\");\r\n\r\nMultisets.removeOccurrences(multisetToModify, occurrencesToRemove);\r\n```","```\r\nint inputData = 15;\r\n\r\nHashFunction hashFunction = Hashing.sha384();\r\nHashCode hashCode = hashFunction.hashInt(inputData);\r\n```","```\r\nint inputData = 15;\r\n\r\nHashFunction crc32Function = Hashing.crc32();\r\nHashCode crc32HashCode = crc32Function.hashInt(inputData);\r\n\r\nHashFunction hashFunction = Hashing.concatenating(Hashing.crc32(), Hashing.crc32());\r\nHashCode concatenatedHashCode = hashFunction.hashInt(inputData); \r\n```","```\r\nArrayList<String> stringList = new ArrayList<>();\r\nArrayList<Integer> intList = new ArrayList<>();\r\nboolean isAssignableFrom = stringList.getClass().isAssignableFrom(intList.getClass());\r\n```","```\r\nTypeToken<ArrayList<String>> listString = new TypeToken<ArrayList<String>>() { };\r\nTypeToken<ArrayList<Integer>> integerString = new TypeToken<ArrayList<Integer>>() { };\r\n\r\nboolean isSupertypeOf = listString.isSupertypeOf(integerString);\r\n```","```\r\nTypeToken<ArrayList<String>> stringList = new TypeToken<ArrayList<String>>() { };\r\nTypeToken<List> list = new TypeToken<List>() { };\r\n\r\nboolean isSubtypeOf = stringList.isSubtypeOf(list);\r\n```","```\r\nByteSource charSource = Files.asByteSource(file);\r\nOptional<Long> size = charSource.sizeIfKnown();\r\n```","```\r\nCharSource charSource = Files.asCharSource(file, Charsets.UTF_8);\r\nOptional<Long> length = charSource.lengthIfKnown(); \r\n```"]