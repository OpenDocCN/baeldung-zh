["```\r\nlong start = System.currentTimeMillis();\r\nlong end = start + 30 * 1000;\r\nwhile (System.currentTimeMillis() < end) {\r\n    // Some expensive operation on the item.\r\n}\r\n```","```\r\nclass LongRunningTask implements Runnable {\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < Long.MAX_VALUE; i++) {\r\n            if(Thread.interrupted()) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","```\r\nclass TimeOutTask extends TimerTask {\r\n    private Thread thread;\r\n    private Timer timer;\r\n\r\n    public TimeOutTask(Thread thread, Timer timer) {\r\n        this.thread = thread;\r\n        this.timer = timer;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        if(thread != null && thread.isAlive()) {\r\n            thread.interrupt();\r\n            timer.cancel();\r\n        }\r\n    }\r\n}\r\n```","```\r\nThread thread = new Thread(new LongRunningTask());\r\nthread.start();\r\n\r\nTimer timer = new Timer();\r\nTimeOutTask timeOutTask = new TimeOutTask(thread, timer);\r\ntimer.schedule(timeOutTask, 3000);\r\n```","```\r\nExecutorService executor = Executors.newSingleThreadExecutor();\r\nFuture future = executor.submit(new LongRunningTask());\r\ntry {\r\n    future.get(7, TimeUnit.SECONDS);\r\n} catch (TimeoutException e) {\r\n    future.cancel(true);\r\n} catch (Exception e) {\r\n    // handle other exceptions\r\n} finally {\r\n    executor.shutdownNow();\r\n}\r\n```","```\r\nScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\r\nFuture future = executor.submit(new LongRunningTask());\r\nRunnable cancelTask = () -> future.cancel(true);\r\n\r\nexecutor.schedule(cancelTask, 3000, TimeUnit.MILLISECONDS);\r\nexecutor.shutdown();\r\n```","```\r\nclass Step {\r\n    private static int MAX = Integer.MAX_VALUE/2;\r\n    int number;\r\n\r\n    public Step(int number) {\r\n        this.number = number;\r\n    }\r\n\r\n    public void perform() throws InterruptedException {\r\n        Random rnd = new Random();\r\n        int target = rnd.nextInt(MAX);\r\n        while (rnd.nextInt(MAX) != target) {\r\n            if (Thread.interrupted()) {\r\n                throw new InterruptedException();\r\n            }\r\n        }\r\n    }\r\n}\r\n```","```\r\npublic class SteppedTask implements Runnable {\r\n    private List<Step> steps;\r\n\r\n    public SteppedTask(List<Step> steps) {\r\n        this.steps = steps;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        for (Step step : steps) {\r\n            try {\r\n                step.perform();\r\n            } catch (InterruptedException e) {\r\n                // handle interruption exception\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","```\r\nList<Step> steps = Stream.of(\r\n  new Step(1),\r\n  new Step(2),\r\n  new Step(3),\r\n  new Step(4))\r\n.collect(Collectors.toList());\r\n\r\nThread thread = new Thread(new SteppedTask(steps));\r\nthread.start();\r\n\r\nTimer timer = new Timer();\r\nTimeOutTask timeOutTask = new TimeOutTask(thread, timer);\r\ntimer.schedule(timeOutTask, 10000);\r\n```"]