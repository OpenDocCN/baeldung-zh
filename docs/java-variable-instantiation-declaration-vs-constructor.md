# Java 中变量在声明和构造函数上的实例化

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-variable-instantiation-declaration-vs-constructor>

## 1.介绍

Java 开发人员不确定是在声明变量时初始化变量，还是在构造函数中初始化变量。

在本教程中，我们将看看**当我们在声明变量或在构造函数**中初始化变量时会发生什么。如果它们存在的话，我们将试着指出它们之间的一些不同和相似之处。

## 2.字段声明初始化

我们需要知道, **Java 编译器取出所有字段声明初始化，并按照它们在类中出现的顺序将它们作为代码移动到构造函数**中。由此，**我们可以推断出** **在声明中初始化变量和在构造函数中初始化变量没有太大的区别**，因为在编译之后，它们最终还是会出现在构造函数中:

```java
public class A {
    private B b = new B();
}
```

## 3.构造函数字段初始化

从上面的代码中，经过编译，我们得到了这个构造函数:

```java
public class A {
    private B b;

    public A() {
        this.b = new B();
    }
}
```

那么我们在哪里初始化数据重要吗？

知道编译后会发生什么后，没有那么多。这更像是一种偏好，是我们根据自己的经历形成的。

## 4.指导方针

在决定是在字段声明还是在构造函数中初始化数据时，我们可以参考一些指导方针。

这是一个依赖注入构造函数:

```java
public A(B b) {
    this.b = b;
}
```

初始化变量的一个推荐方法是使用依赖注入。通过使用这种初始化对象的方式，我们遵循不同的原则。

### 4.1.可读性

为了获得更好的可读性，在字段声明或构造函数中初始化数据可能很重要，而不是两者都初始化。当然，我们应该以此为指导方针，而不是规则，因为你可以两者兼得。

将所有的初始化放在一个地方可以更容易地知道在哪里寻找初始化代码。这将使任何未来的开发者更容易在一个地方查看初始化，而不是分散在多个地方。

### 4.2.单一责任

通过使用依赖注入构造函数，我们从`A`类中移除了实例化`B`对象的责任。在可能的情况下，遵循`**the single responsibility**`原则总是更好。

这也将意味着我们将有**更低的类间耦合**，这是另一个要遵循的令人敬畏的准则。

### 4.3.易测性

使用这个构造函数往往有更简单的方法来测试我们的代码，因为我们可以很容易地模仿我们的`B`对象，然后用这个构造函数将它注入我们的 A 对象:

```java
B b = mock(B.class);
A a = new A(b);
```

### 4.4.可维护性

更低的耦合类也给我们带来了更好的代码可维护性。因此，我们将能够更容易地修改代码。

## 5.结论

在本文中，我们已经看到，使用字段声明或构造函数初始化**更像是一种偏好**，它们之间的一些差异可能是我们想要遵循的设计原则。

使用构造函数初始化和**依赖注入可以给我们一些设计原则**的优势。

与往常一样，GitHub 上的[提供了示例的源代码。](https://web.archive.org/web/20221218190253/https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-lang-5)