["```\r\nvolatile int value;\r\n\r\nboolean cas(int expectedValue, int newValue) {\r\n    if(value == expectedValue) {\r\n        value = newValue;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```","```\r\nvoid testCas() {\r\n    int v = value;\r\n    int x = v + 1;\r\n\r\n    while(!cas(v, x)) {\r\n        v = value;\r\n        x = v + 1;\r\n    }\r\n}\r\n```","```\r\npublic class NonBlockingQueue<T> {\r\n\r\n    private final AtomicReference<Node<T>> head, tail;\r\n    private final AtomicInteger size;\r\n\r\n    public NonBlockingQueue() {\r\n        head = new AtomicReference<>(null);\r\n        tail = new AtomicReference<>(null);\r\n        size = new AtomicInteger();\r\n        size.set(0);\r\n    }\r\n}\r\n```","```\r\nprivate class Node<T> {\r\n    private volatile T value;\r\n    private volatile Node<T> next;\r\n    private volatile Node<T> previous;\r\n\r\n    public Node(T value) {\r\n        this.value = value;\r\n        this.next = null;\r\n    }\r\n\r\n    // getters and setters \r\n}\r\n```","```\r\npublic void add(T element) {\r\n    if (element == null) {\r\n        throw new NullPointerException();\r\n    }\r\n\r\n    Node<T> node = new Node<>(element);\r\n    Node<T> currentTail;\r\n    do {\r\n        currentTail = tail.get();\r\n        node.setPrevious(currentTail);\r\n    } while(!tail.compareAndSet(currentTail, node));\r\n\r\n    if(node.previous != null) {\r\n        node.previous.next = node;\r\n    }\r\n\r\n    head.compareAndSet(null, node); // for inserting the first element\r\n    size.incrementAndGet();\r\n}\r\n```","```\r\npublic T get() {\r\n    if(head.get() == null) {\r\n        throw new NoSuchElementException();\r\n    }\r\n\r\n    Node<T> currentHead;\r\n    Node<T> nextNode;\r\n    do {\r\n        currentHead = head.get();\r\n        nextNode = currentHead.getNext();\r\n    } while(!head.compareAndSet(currentHead, nextNode));\r\n\r\n    size.decrementAndGet();\r\n    return currentHead.getValue();\r\n}\r\n```"]