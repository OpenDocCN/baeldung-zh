["```\r\n<dependencies>\r\n    ...\r\n    <dependency>\r\n        <groupId>org.projectlombok</groupId>\r\n        <artifactId>lombok</artifactId>\r\n        <version>1.18.20</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n    ...\r\n</dependencies>\r\n```","```\r\n@Entity\r\npublic class User implements Serializable {\r\n\r\n    private @Id Long id; // will be set when persisting\r\n\r\n    private String firstName;\r\n    private String lastName;\r\n    private int age;\r\n\r\n    public User() {\r\n    }\r\n\r\n    public User(String firstName, String lastName, int age) {\r\n        this.firstName = firstName;\r\n        this.lastName = lastName;\r\n        this.age = age;\r\n    }\r\n\r\n    // getters and setters: ~30 extra lines of code\r\n}\r\n```","```\r\n@Entity\r\n@Getter @Setter @NoArgsConstructor // <--- THIS is it\r\npublic class User implements Serializable {\r\n\r\n    private @Id Long id; // will be set when persisting\r\n\r\n    private String firstName;\r\n    private String lastName;\r\n    private int age;\r\n\r\n    public User(String firstName, String lastName, int age) {\r\n        this.firstName = firstName;\r\n        this.lastName = lastName;\r\n        this.age = age;\r\n    }\r\n}\r\n```","```\r\nprivate @Id @Setter(AccessLevel.PROTECTED) Long id;\r\n```","```\r\npublic class GetterLazy {\r\n\r\n    @Getter(lazy = true)\r\n    private final Map<String, Long> transactions = getTransactions();\r\n\r\n    private Map<String, Long> getTransactions() {\r\n\r\n        final Map<String, Long> cache = new HashMap<>();\r\n        List<String> txnRows = readTxnListFromFile();\r\n\r\n        txnRows.forEach(s -> {\r\n            String[] txnIdValueTuple = s.split(DELIMETER);\r\n            cache.put(txnIdValueTuple[0], Long.parseLong(txnIdValueTuple[1]));\r\n        });\r\n\r\n        return cache;\r\n    }\r\n}\r\n```","```\r\npublic class GetterLazy {\r\n\r\n    private final AtomicReference<Object> transactions = new AtomicReference();\r\n\r\n    public GetterLazy() {\r\n    }\r\n\r\n    //other methods\r\n\r\n    public Map<String, Long> getTransactions() {\r\n        Object value = this.transactions.get();\r\n        if (value == null) {\r\n            synchronized(this.transactions) {\r\n                value = this.transactions.get();\r\n                if (value == null) {\r\n                    Map<String, Long> actualValue = this.readTxnsFromFile();\r\n                    value = actualValue == null ? this.transactions : actualValue;\r\n                    this.transactions.set(value);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (Map)((Map)(value == this.transactions ? null : value));\r\n    }\r\n}\r\n```","```\r\npublic class LoginResult {\r\n\r\n    private final Instant loginTs;\r\n\r\n    private final String authToken;\r\n    private final Duration tokenValidity;\r\n\r\n    private final URL tokenRefreshUrl;\r\n\r\n    // constructor taking every field and checking nulls\r\n\r\n    // read-only accessor, not necessarily as get*() form\r\n}\r\n```","```\r\n@RequiredArgsConstructor\r\n@Accessors(fluent = true) @Getter\r\npublic class LoginResult {\r\n\r\n    private final @NonNull Instant loginTs;\r\n\r\n    private final @NonNull String authToken;\r\n    private final @NonNull Duration tokenValidity;\r\n\r\n    private final @NonNull URL tokenRefreshUrl;\r\n\r\n}\r\n```","```\r\n// Imagine fields were no longer final now\r\nreturn new LoginResult()\r\n  .loginTs(Instant.now())\r\n  .authToken(\"asdasd\")\r\n  . // and so on\r\n```","```\r\n@OneToMany(mappedBy = \"user\")\r\nprivate List<UserEvent> events;\r\n```","```\r\npublic class ApiClientConfiguration {\r\n\r\n    private String host;\r\n    private int port;\r\n    private boolean useHttps;\r\n\r\n    private long connectTimeout;\r\n    private long readTimeout;\r\n\r\n    private String username;\r\n    private String password;\r\n\r\n    // Whatever other options you may thing.\r\n\r\n    // Empty constructor? All combinations?\r\n\r\n    // getters... and setters?\r\n}\r\n```","```\r\n@Builder\r\npublic class ApiClientConfiguration {\r\n\r\n    // ... everything else remains the same\r\n\r\n}\r\n```","```\r\nApiClientConfiguration config = \r\n    ApiClientConfiguration.builder()\r\n        .host(\"api.server.com\")\r\n        .port(443)\r\n        .useHttps(true)\r\n        .connectTimeout(15_000L)\r\n        .readTimeout(5_000L)\r\n        .username(\"myusername\")\r\n        .password(\"secret\")\r\n    .build();\r\n```","```\r\npublic String resourceAsString() {\r\n    try (InputStream is = this.getClass().getResourceAsStream(\"sure_in_my_jar.txt\")) {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n        return br.lines().collect(Collectors.joining(\"\\n\"));\r\n    } catch (IOException | UnsupportedCharsetException ex) {\r\n        // If this ever happens, then its a bug.\r\n        throw new RuntimeException(ex); <--- encapsulate into a Runtime ex.\r\n    }\r\n}\r\n```","```\r\n@SneakyThrows\r\npublic String resourceAsString() {\r\n    try (InputStream is = this.getClass().getResourceAsStream(\"sure_in_my_jar.txt\")) {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n        return br.lines().collect(Collectors.joining(\"\\n\"));\r\n    } \r\n}\r\n```","```\r\n@Cleanup InputStream is = this.getClass().getResourceAsStream(\"res.txt\");\r\n```","```\r\n@Cleanup(\"dispose\") JFrame mainFrame = new JFrame(\"Main Window\");\r\n```","```\r\npublic class ApiClientConfiguration {\r\n\r\n    private static Logger LOG = LoggerFactory.getLogger(ApiClientConfiguration.class);\r\n\r\n    // LOG.debug(), LOG.info(), ...\r\n\r\n}\r\n```","```\r\n@Slf4j // or: @Log @CommonsLog @Log4j @Log4j2 @XSlf4j\r\npublic class ApiClientConfiguration {\r\n\r\n    // log.debug(), log.info(), ...\r\n\r\n}\r\n```","```\r\n@Synchronized\r\npublic /* better than: synchronized */ void putValueInCache(String key, Object value) {\r\n    // whatever here will be thread-safe code\r\n}\r\n```","```\r\npublic interface HasContactInformation {\r\n\r\n    String getFirstName();\r\n    void setFirstName(String firstName);\r\n\r\n    String getFullName();\r\n\r\n    String getLastName();\r\n    void setLastName(String lastName);\r\n\r\n    String getPhoneNr();\r\n    void setPhoneNr(String phoneNr);\r\n\r\n}\r\n```","```\r\n@Data\r\npublic class ContactInformationSupport implements HasContactInformation {\r\n\r\n    private String firstName;\r\n    private String lastName;\r\n    private String phoneNr;\r\n\r\n    @Override\r\n    public String getFullName() {\r\n        return getFirstName() + \" \" + getLastName();\r\n    }\r\n}\r\n```","```\r\npublic class User implements HasContactInformation {\r\n\r\n    // Whichever other User-specific attributes\r\n\r\n    @Delegate(types = {HasContactInformation.class})\r\n    private final ContactInformationSupport contactInformation =\r\n            new ContactInformationSupport();\r\n\r\n    // User itself will implement all contact information by delegation\r\n\r\n}\r\n```"]