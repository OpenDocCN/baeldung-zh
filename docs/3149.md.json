["```\r\n<dependency>\r\n    <groupId>io.rsocket</groupId>\r\n    <artifactId>rsocket-core</artifactId>\r\n    <version>0.11.13</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.rsocket</groupId>\r\n    <artifactId>rsocket-transport-netty</artifactId>\r\n    <version>0.11.13</version>\r\n</dependency>\r\n```","```\r\npublic class Server {\r\n    private final Disposable server;\r\n\r\n    public Server() {\r\n        this.server = RSocketFactory.receive()\r\n          .acceptor((setupPayload, reactiveSocket) -> Mono.just(new RSocketImpl()))\r\n          .transport(TcpServerTransport.create(\"localhost\", TCP_PORT))\r\n          .start()\r\n          .subscribe();\r\n    }\r\n\r\n    public void dispose() {\r\n        this.server.dispose();\r\n    }\r\n\r\n    private class RSocketImpl extends AbstractRSocket {}\r\n}\r\n```","```\r\nServer server = new Server();\r\n```","```\r\n@Override\r\npublic Mono<Payload> requestResponse(Payload payload) {\r\n    try {\r\n        return Mono.just(payload); // reflect the payload back to the sender\r\n    } catch (Exception x) {\r\n        return Mono.error(x);\r\n    }\r\n}\r\n```","```\r\npublic class ReqResClient {\r\n\r\n    private final RSocket socket;\r\n\r\n    public ReqResClient() {\r\n        this.socket = RSocketFactory.connect()\r\n          .transport(TcpClientTransport.create(\"localhost\", TCP_PORT))\r\n          .start()\r\n          .block();\r\n    }\r\n\r\n    public String callBlocking(String string) {\r\n        return socket\r\n          .requestResponse(DefaultPayload.create(string))\r\n          .map(Payload::getDataUtf8)\r\n          .block();\r\n    }\r\n\r\n    public void dispose() {\r\n        this.socket.dispose();\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void whenSendingAString_thenRevceiveTheSameString() {\r\n    ReqResClient client = new ReqResClient();\r\n    String string = \"Hello RSocket\";\r\n\r\n    assertEquals(string, client.callBlocking(string));\r\n\r\n    client.dispose();\r\n}\r\n```","```\r\n@Override\r\npublic Mono<Void> fireAndForget(Payload payload) {\r\n    try {\r\n        dataPublisher.publish(payload); // forward the payload\r\n        return Mono.empty();\r\n    } catch (Exception x) {\r\n        return Mono.error(x);\r\n    }\r\n}\r\n```","```\r\npublic class FireNForgetClient {\r\n    private final RSocket socket;\r\n    private final List<Float> data;\r\n\r\n    public FireNForgetClient() {\r\n        this.socket = RSocketFactory.connect()\r\n          .transport(TcpClientTransport.create(\"localhost\", TCP_PORT))\r\n          .start()\r\n          .block();\r\n    }\r\n\r\n    /** Send binary velocity (float) every 50ms */\r\n    public void sendData() {\r\n        data = Collections.unmodifiableList(generateData());\r\n        Flux.interval(Duration.ofMillis(50))\r\n          .take(data.size())\r\n          .map(this::createFloatPayload)\r\n          .flatMap(socket::fireAndForget)\r\n          .blockLast();\r\n    }\r\n\r\n    // ... \r\n}\r\n```","```\r\n@Override\r\npublic Flux<Payload> requestStream(Payload payload) {\r\n    return Flux.from(dataPublisher);\r\n}\r\n```","```\r\npublic class ReqStreamClient {\r\n\r\n    private final RSocket socket;\r\n\r\n    public ReqStreamClient() {\r\n        this.socket = RSocketFactory.connect()\r\n          .transport(TcpClientTransport.create(\"localhost\", TCP_PORT))\r\n          .start()\r\n          .block();\r\n    }\r\n\r\n    public Flux<Float> getDataStream() {\r\n        return socket\r\n          .requestStream(DefaultPayload.create(DATA_STREAM_NAME))\r\n          .map(Payload::getData)\r\n          .map(buf -> buf.getFloat())\r\n          .onErrorReturn(null);\r\n    }\r\n\r\n    public void dispose() {\r\n        this.socket.dispose();\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void whenSendingStream_thenReceiveTheSameStream() {\r\n    FireNForgetClient fnfClient = new FireNForgetClient(); \r\n    ReqStreamClient streamClient = new ReqStreamClient();\r\n\r\n    List<Float> data = fnfClient.getData();\r\n    List<Float> dataReceived = new ArrayList<>();\r\n\r\n    Disposable subscription = streamClient.getDataStream()\r\n      .index()\r\n      .subscribe(\r\n        tuple -> {\r\n            assertEquals(\"Wrong value\", data.get(tuple.getT1().intValue()), tuple.getT2());\r\n            dataReceived.add(tuple.getT2());\r\n        },\r\n        err -> LOG.error(err.getMessage())\r\n      );\r\n\r\n    fnfClient.sendData();\r\n\r\n    // ... dispose client & subscription\r\n\r\n    assertEquals(\"Wrong data count received\", data.size(), dataReceived.size());\r\n}\r\n```","```\r\n@Override\r\npublic Flux<Payload> requestChannel(Publisher<Payload> payloads) {\r\n    Flux.from(payloads)\r\n      .subscribe(gameController::processPayload);\r\n    return Flux.from(gameController);\r\n}\r\n```","```\r\npublic class GameController implements Publisher<Payload> {\r\n\r\n    @Override\r\n    public void subscribe(Subscriber<? super Payload> subscriber) {\r\n        // send Payload messages to the subscriber at random intervals\r\n    }\r\n\r\n    public void processPayload(Payload payload) {\r\n        // react to messages from the other player\r\n    }\r\n}\r\n```","```\r\npublic class ChannelClient {\r\n\r\n    private final RSocket socket;\r\n    private final GameController gameController;\r\n\r\n    public ChannelClient() {\r\n        this.socket = RSocketFactory.connect()\r\n          .transport(TcpClientTransport.create(\"localhost\", TCP_PORT))\r\n          .start()\r\n          .block();\r\n\r\n        this.gameController = new GameController(\"Client Player\");\r\n    }\r\n\r\n    public void playGame() {\r\n        socket.requestChannel(Flux.from(gameController))\r\n          .doOnNext(gameController::processPayload)\r\n          .blockLast();\r\n    }\r\n\r\n    public void dispose() {\r\n        this.socket.dispose();\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void whenRunningChannelGame_thenLogTheResults() {\r\n    ChannelClient client = new ChannelClient();\r\n    client.playGame();\r\n    client.dispose();\r\n}\r\n```"]