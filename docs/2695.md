# 番石榴地图指南

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/guava-bimap>

## **1。概述**

在本教程中，我们将展示如何使用 Google Guava 的`BiMap`界面及其多种实现。

`BiMap`(或“双向映射”)是一种特殊的映射，它维护映射的反向视图，同时确保不存在重复值，并且总是可以安全地使用某个值来取回密钥。

`BiMap`的基本实现是`HashBiMap`，它在内部使用两个`Map`，一个用于键到值的映射，另一个用于值到键的映射。

## **2。谷歌番石榴的`BiMap`**

让我们来看看如何使用`BiMap`类。

我们将从在`pom.xml`中添加 Google Guava 库依赖项开始:

[PRE0]

依赖关系的最新版本可以在[这里](https://web.archive.org/web/20220117212928/https://search.maven.org/classic/#search|gav|1|g%3A%22com.google.guava%22%20AND%20a%3A%22guava%22)查看。

## **3。创建双地图**

您可以通过多种方式创建`BiMap`的实例，如下所示:

*   如果要处理一个定制的 Java 对象，使用 HashBiMap 类中的`create`方法:

[PRE1]

*   如果我们已经有一个现有的映射，您可以使用来自类`HashBiMap`的`create`方法的重载版本创建一个`BiMap`的实例:

[PRE2]

*   如果你要处理一个类型为`Enum,` 的键，使用`EnumHashBiMap`类中的`create`方法:

[PRE3]

*   如果您打算创建一个不可变的映射，使用`ImmutableBiMap`类(它遵循一个构建器模式):

[PRE4]

## **4。使用双地图**

让我们从一个简单的例子开始，展示一下`BiMap,`的用法，我们可以得到一个基于值的键和一个基于键的值:

[PRE5]

注意:上面的`inverse`方法返回了`BiMap`的逆视图，它将每个 BiMap 的值映射到其相关的键。

当我们试图存储一个重复值两次时,`BiMap`抛出一个`IllegalArgumentException`。

让我们看一个同样的例子:

[PRE6]

如果我们希望覆盖已经存在于`BiMap`中的值，我们可以使用`forcePut`方法:

[PRE7]

## **5。结论**

在这篇简明教程中，我们举例说明了在番石榴库中使用`BiMap`的例子。它主要用于根据 map 中的值获取一个键。

这些例子的实现可以在 GitHub 项目中找到——这是一个基于 Maven 的项目，所以它应该很容易导入和运行。