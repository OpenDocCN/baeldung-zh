# Spring Boot resilience 4j 指南

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-boot-resilience4j>

## 1.概观

Resilience4j 是一个轻量级的容错库，它为 web 应用程序提供了多种容错和稳定性模式。在本教程中，我们将**学习如何通过一个简单的 Spring Boot 应用程序**来使用这个库。

## 2.设置

在这一部分，让我们关注**为我们的 Spring Boot 项目**设置关键方面。

### 2.1.Maven 依赖性

首先，我们需要添加`[spring-boot-starter-web](https://web.archive.org/web/20221128052426/https://search.maven.org/search?q=g:org.springframework.boot%20AND%20a:spring-boot-starter-web)`依赖项来引导一个简单的 web 应用程序:

[PRE0]

接下来，**我们需要 [`resilience4j-spring-boot2`](https://web.archive.org/web/20221128052426/https://search.maven.org/search?q=resilience4j-spring-boot2) 和`[spring-boot-starter-aop](https://web.archive.org/web/20221128052426/https://search.maven.org/search?q=spring-boot-starter-aop)`依赖项来使用 Resilience-4j 库中的特性，在我们的 Spring Boot 应用程序中使用注释**:

[PRE1]

此外，我们还需要添加`[spring-boot-starter-actuator](https://web.archive.org/web/20221128052426/https://search.maven.org/artifact/org.springframework.boot/spring-boot-starter-actuator)`依赖项，通过一组公开的端点来监控应用程序的当前状态:

[PRE2]

最后，让我们添加`[wiremock-jre8](https://web.archive.org/web/20221128052426/https://search.maven.org/search?q=g:com.github.tomakehurst%20AND%20a:wiremock-jre8)`依赖项，因为它将帮助我们使用[模拟 HTTP 服务器](/web/20221128052426/https://www.baeldung.com/introduction-to-wiremock)测试 REST APIs:

[PRE3]

### 2.2.`RestController`和外部 API 调用者

在使用 Resilience4j 库的不同特性时，我们的 web 应用程序需要与外部 API 进行交互。因此，让我们继续为`[RestTemplate](/web/20221128052426/https://www.baeldung.com/rest-template) `添加一个 bean，它将帮助我们进行 API 调用。

[PRE4]

接下来，让我们将`ExternalAPICaller`类定义为一个`Component`，并将 *restTemplate* bean 用作成员:

[PRE5]

在这之后，我们可以**定义`ResilientAppController`类，该类公开 REST API 端点并在内部使用`ExternalAPICaller` bean 调用外部 API** :

[PRE6]

### 2.3.执行器端点

我们可以通过 [Spring Boot 执行器](/web/20221128052426/https://www.baeldung.com/spring-boot-actuators)来**暴露健康端点，从而在任何给定的时间知道应用程序**的确切状态。

因此，让我们将配置添加到`application.properties` 文件并启用端点:

[PRE7]

此外，当我们需要时，我们将在同一个`application.properties` 文件中添加特定于特性的配置。

### 2.4.单元测试

我们的 web 应用程序将在现实场景中调用外部服务。然而，我们可以通过使用`WireMockExtension`类启动一个外部服务来**模拟这样一个正在运行的服务的存在。**

因此，让我们将`EXTERNAL_SERVICE`定义为`ResilientAppControllerUnitTest`类中的静态成员:

[PRE8]

此外，让我们添加一个`TestRestTemplate`实例来调用 API:

[PRE9]

### 2.5.异常处理程序

Resilience4j 库将根据上下文中的容错模式抛出一个异常来保护服务资源。但是，这些异常应该转化为 HTTP 响应，并为客户端提供有意义的状态代码。

所以，让我们**定义`ApiExceptionHandler`类来保存不同异常**的处理程序:

[PRE10]

当我们探索不同的容错模式时，我们将在这个类中添加处理程序。

## 3.断路器

**[断路器模式](/web/20221128052426/https://www.baeldung.com/resilience4j#circuit-breaker)通过限制上游服务在部分或完全停机期间调用下游服务来保护下游服务**。

让我们从暴露`/api/circuit-breaker`端点并添加`@CircuitBreaker`注释开始:

[PRE11]

根据需要，我们还需要在`ExternalAPICaller`类中定义`callApi()`方法来调用外部端点`/api/external`:

[PRE12]

接下来，让我们在`application.properties`文件中添加断路器的配置:

[PRE13]

本质上，该配置将允许对处于[关闭状态](/web/20221128052426/https://www.baeldung.com/resilience4j#1-circuit-breakers-states-and-settings)的服务的 50%的失败调用，之后它将打开电路并开始拒绝带有`CallNotPermittedException`的请求。因此，在`ApiExceptionHandler`类中为这个异常添加一个处理程序是个好主意:

[PRE14]

最后，让我们通过使用`EXTERNAL_SERVICE:`模拟下游服务停机的场景来测试`/api/circuit-breaker` API 端点

[PRE15]

我们可以注意到，由于下游服务中断，前五次调用都失败了。之后，电路切换到开路状态。因此，随后的五次尝试都被拒绝，并带有`503` HTTP 状态代码，而没有真正调用底层 API。

## 4.重试

**[重试模式](/web/20221128052426/https://www.baeldung.com/resilience4j#retry)通过从瞬态问题中恢复来为系统提供弹性**。让我们从添加带有`@Retry`注释的`/api/retry` API 端点开始:

[PRE16]

此外，我们可以**可选地提供一个后备机制，当所有的重试尝试都失败时**。在这种情况下，我们提供了`fallbackAfterRetry `作为后备方法:

[PRE17]

接下来，让我们更新`application.properties`文件，添加控制重试行为的配置:

[PRE18]

因此，我们计划最多重试 3 次，每次延迟`1s`。

最后，让我们测试一下`/api/retry` API 端点的重试行为:

[PRE19]

我们可以注意到，在第一个场景中，没有问题，所以一次尝试就足够了。另一方面，当出现问题时，有三次尝试，之后 API 通过回退机制做出响应。

## 5.时间限制器

我们可以**使用[时间限制器模式](/web/20221128052426/https://www.baeldung.com/resilience4j#time-limiter)来设置对外部系统**进行异步调用的超时阈值。

让我们添加内部调用慢速 API 的`/api/time-limiter` API 端点:

[PRE20]

此外，让我们通过在`callApiWithDelay()`方法中添加睡眠时间来模拟外部 API 调用中的延迟:

[PRE21]

接下来，我们需要为`application.properties`文件中的`timeLimiterApi` 提供配置:

[PRE22]

我们可以注意到阈值被设置为 2s。之后，Resilience4j 库用一个`TimeoutException`在内部取消异步操作。因此，让我们**在`ApiExceptionHandler`类中为这个异常添加一个处理程序，以返回一个带有`408` HTTP 状态代码**的 API 响应:

[PRE23]

最后，让我们验证为`/api/time-limiter` API 端点配置的时间限制模式:

[PRE24]

正如预期的那样，由于下游 API 调用被设置为花费 5 秒多的时间来完成，我们目睹了 API 调用的超时。

## 6.防水壁

**[隔板模式](/web/20221128052426/https://www.baeldung.com/resilience4j#bulkhead)限制了对外部服务的最大并发调用数。**

让我们从添加带有`@Bulkhead`注释的`/api/bulkhead` API 端点开始:

[PRE25]

接下来，让我们在`application.properties`文件中定义配置来控制隔板功能:

[PRE26]

这样，我们希望将并发调用的最大数量限制为`3`，这样，如果隔板已满，每个线程只能等待`1ms`。此后，请求被拒绝，并出现`BulkheadFullException`例外。此外，我们希望向客户机返回一个有意义的 HTTP 状态代码，所以让我们添加一个异常处理程序:

[PRE27]

最后，让我们通过并行调用五个请求来测试隔板行为:

[PRE28]

我们注意到**只有三个请求是成功的，而其他请求都被拒绝，并显示了`BANDWIDTH_LIMIT_EXCEEDED ` HTTP 状态代码**。

## 7.限速器

**[速率限制器模式](/web/20221128052426/https://www.baeldung.com/resilience4j#rate-limiter)限制对资源的请求速率。**

让我们从添加带有`@RateLimiter`注释的`/api/rate-limiter` API 端点开始:

[PRE29]

接下来，让我们在`application.properties`文件中定义速率限制器的配置:

[PRE30]

有了这个配置，我们想把 API 调用速率限制在`5` `req/min`而不等待。**达到允许速率的阈值后，请求将被拒绝，例外情况为`RequestNotPermitted`**。因此，让我们在`ApiExceptionHandler`类中定义一个处理程序，将其转换成有意义的 HTTP 状态响应代码:

[PRE31]

最后，让我们用`50`请求来测试我们的速率受限的 API 端点:

[PRE32]

不出所料，**只有五个请求成功，而所有其他请求都失败了，HTTP 状态代码为**。

## 8.执行器端点

我们已经将应用程序配置为支持用于监控目的的执行器端点。使用这些端点，我们可以使用一个或多个已配置的容错模式来确定应用程序随时间的行为。

首先，我们通常可以使用对`/actuator`端点的 GET 请求来**找到所有公开的端点:**

[PRE33]

我们可以看到一个 JSON 响应，带有类似于`bulkheads`、*断路器*、*速率限制器*等字段。每个字段根据其与容错模式的关联为我们提供特定的信息。

接下来，让我们看看与重试模式相关的字段:

[PRE34]

接下来，让我们检查应用程序以查看重试实例列表:

[PRE35]

正如所料，我们可以在配置的重试实例列表中看到`retryApi`实例。

最后，让我们通过浏览器向`/api/retry` API 端点发出 GET 请求，然后**使用`/actuator/retryevents`端点**观察重试事件:

[PRE36]

由于下游服务关闭，我们可以看到三次重试尝试，任意两次尝试之间的等待时间为`1s`。就像我们配置的一样。

## 9.结论

在本文中，我们学习了如何在 Sprint Boot 应用程序中使用 Resilience4j 库。此外，**我们深入研究了几种容错模式，如断路器、速率限制器、时间限制器、隔板和重试。**

和往常一样，该教程的完整源代码可以在 GitHub 上的[处获得。](https://web.archive.org/web/20221128052426/https://github.com/eugenp/tutorials/tree/master/spring-boot-modules/spring-boot-libraries-2)