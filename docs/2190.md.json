["```\r\npublic class State {\r\n    private List<Stack<String>> state;\r\n    private int heuristics;\r\n\r\n    // copy constructor, setters, and getters\r\n}\r\n```","```\r\npublic int getHeuristicsValue(\r\n  List<Stack<String>> currentState, Stack<String> goalStateStack) {\r\n\r\n    Integer heuristicValue;\r\n    heuristicValue = currentState.stream()\r\n      .mapToInt(stack -> {\r\n          return getHeuristicsValueForStack(\r\n            stack, currentState, goalStateStack);\r\n    }).sum();\r\n\r\n    return heuristicValue;\r\n}\r\n\r\npublic int getHeuristicsValueForStack(\r\n  Stack<String> stack,\r\n  List<Stack<String>> currentState,\r\n  Stack<String> goalStateStack) {\r\n\r\n    int stackHeuristics = 0;\r\n    boolean isPositioneCorrect = true;\r\n    int goalStartIndex = 0;\r\n    for (String currentBlock : stack) {\r\n        if (isPositioneCorrect \r\n          && currentBlock.equals(goalStateStack.get(goalStartIndex))) {\r\n            stackHeuristics += goalStartIndex;\r\n        } else {\r\n            stackHeuristics -= goalStartIndex;\r\n            isPositioneCorrect = false;\r\n        }\r\n        goalStartIndex++;\r\n    }\r\n    return stackHeuristics;\r\n} \r\n```","```\r\nprivate State pushElementToNewStack(\r\n  List<Stack<String>> currentStackList,\r\n  String block,\r\n  int currentStateHeuristics,\r\n  Stack<String> goalStateStack) {\r\n\r\n    State newState = null;\r\n    Stack<String> newStack = new Stack<>();\r\n    newStack.push(block);\r\n    currentStackList.add(newStack);\r\n    int newStateHeuristics \r\n      = getHeuristicsValue(currentStackList, goalStateStack);\r\n    if (newStateHeuristics > currentStateHeuristics) {\r\n        newState = new State(currentStackList, newStateHeuristics);\r\n    } else {\r\n        currentStackList.remove(newStack);\r\n    }\r\n    return newState;\r\n}\r\n```","```\r\nprivate State pushElementToExistingStacks(\r\n  Stack currentStack,\r\n  List<Stack<String>> currentStackList,\r\n  String block,\r\n  int currentStateHeuristics,\r\n  Stack<String> goalStateStack) {\r\n\r\n    return currentStackList.stream()\r\n      .filter(stack -> stack != currentStack)\r\n      .map(stack -> {\r\n          return pushElementToStack(\r\n            stack, block, currentStackList,\r\n            currentStateHeuristics, goalStateStack);\r\n        })\r\n      .filter(Objects::nonNull)\r\n      .findFirst()\r\n      .orElse(null);\r\n}\r\n\r\nprivate State pushElementToStack(\r\n  Stack stack,\r\n  String block,\r\n  List<Stack<String>> currentStackList,\r\n  int currentStateHeuristics,\r\n  Stack<String> goalStateStack) {\r\n\r\n    stack.push(block);\r\n    int newStateHeuristics \r\n      = getHeuristicsValue(currentStackList, goalStateStack);\r\n    if (newStateHeuristics > currentStateHeuristics) {\r\n        return new State(currentStackList, newStateHeuristics);\r\n    }\r\n    stack.pop();\r\n    return null;\r\n}\r\n```","```\r\npublic List<State> getRouteWithHillClimbing(\r\n  Stack<String> initStateStack, Stack<String> goalStateStack) throws Exception {\r\n    // instantiate initState with initStateStack\r\n    // ...\r\n    List<State> resultPath = new ArrayList<>();\r\n    resultPath.add(new State(initState));\r\n\r\n    State currentState = initState;\r\n    boolean noStateFound = false;\r\n\r\n    while (\r\n      !currentState.getState().get(0).equals(goalStateStack)\r\n      || noStateFound) {\r\n        noStateFound = true;\r\n        State nextState = findNextState(currentState, goalStateStack);\r\n        if (nextState != null) {\r\n            noStateFound = false;\r\n            currentState = nextState;\r\n            resultPath.add(new State(nextState));\r\n        }\r\n    }\r\n    return resultPath;\r\n}\r\n```","```\r\npublic State findNextState(State currentState, Stack<String> goalStateStack) {\r\n    List<Stack<String>> listOfStacks = currentState.getState();\r\n    int currentStateHeuristics = currentState.getHeuristics();\r\n\r\n     return listOfStacks.stream()\r\n      .map(stack -> {\r\n          return applyOperationsOnState(\r\n            listOfStacks, stack, currentStateHeuristics, goalStateStack);\r\n      })\r\n      .filter(Objects::nonNull)\r\n      .findFirst()\r\n      .orElse(null);\r\n}\r\n\r\npublic State applyOperationsOnState(\r\n  List<Stack<String>> listOfStacks,\r\n  Stack<String> stack,\r\n  int currentStateHeuristics,\r\n  Stack<String> goalStateStack) {\r\n\r\n    State tempState;\r\n    List<Stack<String>> tempStackList \r\n      = new ArrayList<>(listOfStacks);\r\n    String block = stack.pop();\r\n    if (stack.size() == 0)\r\n      tempStackList.remove(stack);\r\n    tempState = pushElementToNewStack(\r\n      tempStackList, block, currentStateHeuristics, goalStateStack);\r\n    if (tempState == null) {\r\n        tempState = pushElementToExistingStacks(\r\n          stack, tempStackList, block,\r\n          currentStateHeuristics, goalStateStack);\r\n        stack.push(block);\r\n    }\r\n    return tempState;\r\n}\r\n```"]