["```\r\npublic class Node {\r\n    State state;\r\n    Node parent;\r\n    List<Node> childArray;\r\n    // setters and getters\r\n}\r\npublic class Tree {\r\n    Node root;\r\n}\r\n```","```\r\npublic class State {\r\n    Board board;\r\n    int playerNo;\r\n    int visitCount;\r\n    double winScore;\r\n\r\n    // copy constructor, getters, and setters\r\n\r\n    public List<State> getAllPossibleStates() {\r\n        // constructs a list of all possible states from current state\r\n    }\r\n    public void randomPlay() {\r\n        /* get a list of all possible positions on the board and \r\n           play a random move */\r\n    }\r\n}\r\n```","```\r\npublic class MonteCarloTreeSearch {\r\n    static final int WIN_SCORE = 10;\r\n    int level;\r\n    int opponent;\r\n\r\n    public Board findNextMove(Board board, int playerNo) {\r\n        // define an end time which will act as a terminating condition\r\n\r\n        opponent = 3 - playerNo;\r\n        Tree tree = new Tree();\r\n        Node rootNode = tree.getRoot();\r\n        rootNode.getState().setBoard(board);\r\n        rootNode.getState().setPlayerNo(opponent);\r\n\r\n        while (System.currentTimeMillis() < end) {\r\n            Node promisingNode = selectPromisingNode(rootNode);\r\n            if (promisingNode.getState().getBoard().checkStatus() \r\n              == Board.IN_PROGRESS) {\r\n                expandNode(promisingNode);\r\n            }\r\n            Node nodeToExplore = promisingNode;\r\n            if (promisingNode.getChildArray().size() > 0) {\r\n                nodeToExplore = promisingNode.getRandomChildNode();\r\n            }\r\n            int playoutResult = simulateRandomPlayout(nodeToExplore);\r\n            backPropogation(nodeToExplore, playoutResult);\r\n        }\r\n\r\n        Node winnerNode = rootNode.getChildWithMaxScore();\r\n        tree.setRoot(winnerNode);\r\n        return winnerNode.getState().getBoard();\r\n    }\r\n}\r\n```","```\r\nprivate Node selectPromisingNode(Node rootNode) {\r\n    Node node = rootNode;\r\n    while (node.getChildArray().size() != 0) {\r\n        node = UCT.findBestNodeWithUCT(node);\r\n    }\r\n    return node;\r\n}\r\n```","```\r\npublic class UCT {\r\n    public static double uctValue(\r\n      int totalVisit, double nodeWinScore, int nodeVisit) {\r\n        if (nodeVisit == 0) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n        return ((double) nodeWinScore / (double) nodeVisit) \r\n          + 1.41 * Math.sqrt(Math.log(totalVisit) / (double) nodeVisit);\r\n    }\r\n\r\n    public static Node findBestNodeWithUCT(Node node) {\r\n        int parentVisit = node.getState().getVisitCount();\r\n        return Collections.max(\r\n          node.getChildArray(),\r\n          Comparator.comparing(c -> uctValue(parentVisit, \r\n            c.getState().getWinScore(), c.getState().getVisitCount())));\r\n    }\r\n}\r\n```","```\r\nprivate void expandNode(Node node) {\r\n    List<State> possibleStates = node.getState().getAllPossibleStates();\r\n    possibleStates.forEach(state -> {\r\n        Node newNode = new Node(state);\r\n        newNode.setParent(node);\r\n        newNode.getState().setPlayerNo(node.getState().getOpponent());\r\n        node.getChildArray().add(newNode);\r\n    });\r\n}\r\n```","```\r\nprivate void backPropogation(Node nodeToExplore, int playerNo) {\r\n    Node tempNode = nodeToExplore;\r\n    while (tempNode != null) {\r\n        tempNode.getState().incrementVisit();\r\n        if (tempNode.getState().getPlayerNo() == playerNo) {\r\n            tempNode.getState().addScore(WIN_SCORE);\r\n        }\r\n        tempNode = tempNode.getParent();\r\n    }\r\n}\r\nprivate int simulateRandomPlayout(Node node) {\r\n    Node tempNode = new Node(node);\r\n    State tempState = tempNode.getState();\r\n    int boardStatus = tempState.getBoard().checkStatus();\r\n    if (boardStatus == opponent) {\r\n        tempNode.getParent().getState().setWinScore(Integer.MIN_VALUE);\r\n        return boardStatus;\r\n    }\r\n    while (boardStatus == Board.IN_PROGRESS) {\r\n        tempState.togglePlayer();\r\n        tempState.randomPlay();\r\n        boardStatus = tempState.getBoard().checkStatus();\r\n    }\r\n    return boardStatus;\r\n}\r\n```","```\r\npublic class Board {\r\n    int[][] boardValues;\r\n    public static final int DEFAULT_BOARD_SIZE = 3;\r\n    public static final int IN_PROGRESS = -1;\r\n    public static final int DRAW = 0;\r\n    public static final int P1 = 1;\r\n    public static final int P2 = 2;\r\n\r\n    // getters and setters\r\n    public void performMove(int player, Position p) {\r\n        this.totalMoves++;\r\n        boardValues[p.getX()][p.getY()] = player;\r\n    }\r\n\r\n    public int checkStatus() {\r\n        /* Evaluate whether the game is won and return winner.\r\n           If it is draw return 0 else return -1 */         \r\n    }\r\n\r\n    public List<Position> getEmptyPositions() {\r\n        int size = this.boardValues.length;\r\n        List<Position> emptyPositions = new ArrayList<>();\r\n        for (int i = 0; i < size; i++) {\r\n            for (int j = 0; j < size; j++) {\r\n                if (boardValues[i][j] == 0)\r\n                    emptyPositions.add(new Position(i, j));\r\n            }\r\n        }\r\n        return emptyPositions;\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenEmptyBoard_whenSimulateInterAIPlay_thenGameDraw() {\r\n    Board board = new Board();\r\n    int player = Board.P1;\r\n    int totalMoves = Board.DEFAULT_BOARD_SIZE * Board.DEFAULT_BOARD_SIZE;\r\n    for (int i = 0; i < totalMoves; i++) {\r\n        board = mcts.findNextMove(board, player);\r\n        if (board.checkStatus() != -1) {\r\n            break;\r\n        }\r\n        player = 3 - player;\r\n    }\r\n    int winStatus = board.checkStatus();\r\n\r\n    assertEquals(winStatus, Board.DRAW);\r\n}\r\n```"]