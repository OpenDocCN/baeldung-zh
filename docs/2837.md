# 在 Spring JDBC 中获取自动生成的密钥

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-jdbc-autogenerated-keys>

## 1。简介

在这个快速教程中，我们将探索在使用`Spring JDBC`插入实体后获得自动生成的密钥的可能性。

## 2。Maven 依赖关系

首先，我们需要在我们的`pom.xml`中定义`spring-boot-starter-jdbc `和`H2`依赖关系:

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

我们可以在 Maven Central 上查看这两个依赖项的最新版本: [`spring-boot-starter-jdbc`](https://web.archive.org/web/20220523232946/https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.springframework.boot%22%20AND%20a%3A%22spring-boot-starter-jdbc%22) 和`[h2](https://web.archive.org/web/20220523232946/https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22com.h2database%22%20AND%20a%3A%22h2%22)`。

## 3。获取自动生成的密钥

### 3.1.场景

让我们定义一个`sys_message`表，它有两列:`id`(自动生成的键)和`message`:

```
CREATE TABLE IF NOT EXISTS sys_message (
    id bigint(20) NOT NULL AUTO_INCREMENT,
    message varchar(100) NOT NULL,
    PRIMARY KEY (id)
); 
```

### 3.2。使用`JdbcTemplate`

现在，让我们实现一个使用`JDBCTemplate`插入新记录并返回自动生成的`id. `的方法

因此，**我们将使用`JDBCTemplate` `update()`** 方法，该方法支持检索数据库生成的主键。该方法将`PrepareStatementCreator`接口的实例作为第一个参数，另一个参数是`KeyHolder. `

由于`PrepareStatementCreator` 接口是一个`FunctionalInterface `，其中它的方法接受一个`java.sql.Connection`实例并返回一个`java.sql.PreparedStatement` 对象，为了简单起见，我们可以使用一个 lambda 表达式:

```
String INSERT_MESSAGE_SQL 
  = "insert into sys_message (message) values(?) ";

public long insertMessage(String message) {    
    KeyHolder keyHolder = new GeneratedKeyHolder();

    jdbcTemplate.update(connection -> {
        PreparedStatement ps = connection
          .prepareStatement(INSERT_MESSAGE_SQL);
          ps.setString(1, message);
          return ps;
        }, keyHolder);

        return (long) keyHolder.getKey();
    }
} 
```

**值得注意的是，`keyHolder`对象将包含从`JDBCTemplate update()` 方法**自动生成的键返回。

我们可以通过调用`keyHolder.getKey().`来检索那个密钥

此外，我们可以验证方法:

```
@Test
public void 
  insertJDBC_whenLoadMessageByKey_thenGetTheSameMessage() {
    long key = messageRepositoryJDBCTemplate.insert(MESSAGE_CONTENT);
    String loadedMessage = messageRepositoryJDBCTemplate
      .getMessageById(key);

    assertEquals(MESSAGE_CONTENT, loadedMessage);
}
```

### 3.3。 **利用`SimpleJdbcInsert`**

除了`JDBCTemplate`，我们还可以使用`SimpleJdbcInsert`来达到同样的结果。

因此，我们需要初始化`SimpleJdbcInsert`的一个实例:

```
@Repository
public class MessageRepositorySimpleJDBCInsert {

    SimpleJdbcInsert simpleJdbcInsert;

    @Autowired
    public MessageRepositorySimpleJDBCInsert(DataSource dataSource) {
        simpleJdbcInsert = new SimpleJdbcInsert(dataSource)
          .withTableName("sys_message").usingGeneratedKeyColumns("id");
    }

    //...
} 
```

因此，**我们可以调用`SimpleJdbcInsert`的`executeAndReturnKey`方法向`sys_message`表中插入一条新记录，并取回自动生成的关键字**:

```
public long insert(String message) {
    Map<String, Object> parameters = new HashMap<>(1);
    parameters.put("message", message);
    Number newId = simpleJdbcInsert.executeAndReturnKey(parameters);
    return (long) newId;
} 
```

此外，我们可以非常简单地验证该方法:

```
@Test
public void 
  insertSimpleInsert_whenLoadMessageKey_thenGetTheSameMessage() {
    long key = messageRepositorySimpleJDBCInsert.insert(MESSAGE_CONTENT);
    String loadedMessage = messageRepositoryJDBCTemplate.getMessageById(key);

    assertEquals(MESSAGE_CONTENT, loadedMessage);
}
```

## 4。结论

我们已经探索了使用`JDBCTemplate`和`SimpleJdbcInsert`插入新记录并取回自动生成的密钥的可能性。

一如既往，我们可以在 Github 上找到本文[的实现。](https://web.archive.org/web/20220523232946/https://github.com/eugenp/tutorials/tree/master/persistence-modules/spring-jdbc)