["```\r\npublic interface Cache<K, V> {\r\n    boolean set(K key, V value);\r\n    Optional<V> get(K key);\r\n    int size();\r\n    boolean isEmpty();\r\n    void clear();\r\n}\r\n```","```\r\npublic class LRUCache<K, V> implements Cache<K, V> {\r\n    private int size;\r\n    private Map<K, LinkedListNode<CacheElement<K,V>>> linkedListNodeMap;\r\n    private DoublyLinkedList<CacheElement<K,V>> doublyLinkedList;\r\n\r\n    public LRUCache(int size) {\r\n        this.size = size;\r\n        this.linkedListNodeMap = new HashMap<>(maxSize);\r\n        this.doublyLinkedList = new DoublyLinkedList<>();\r\n    }\r\n   // rest of the implementation\r\n}\r\n```","```\r\npublic boolean put(K key, V value) {\r\n    CacheElement<K, V> item = new CacheElement<K, V>(key, value);\r\n    LinkedListNode<CacheElement<K, V>> newNode;\r\n    if (this.linkedListNodeMap.containsKey(key)) {\r\n        LinkedListNode<CacheElement<K, V>> node = this.linkedListNodeMap.get(key);\r\n        newNode = doublyLinkedList.updateAndMoveToFront(node, item);\r\n    } else {\r\n        if (this.size() >= this.size) {\r\n            this.evictElement();\r\n        }\r\n        newNode = this.doublyLinkedList.add(item);\r\n    }\r\n    if(newNode.isEmpty()) {\r\n        return false;\r\n    }\r\n    this.linkedListNodeMap.put(key, newNode);\r\n    return true;\r\n }\r\n```","```\r\npublic LinkedListNode<T> updateAndMoveToFront(LinkedListNode<T> node, T newValue) {\r\n    if (node.isEmpty() || (this != (node.getListReference()))) {\r\n        return dummyNode;\r\n    }\r\n    detach(node);\r\n    add(newValue);\r\n    return head;\r\n}\r\n```","```\r\npublic Optional<V> get(K key) {\r\n   LinkedListNode<CacheElement<K, V>> linkedListNode = this.linkedListNodeMap.get(key);\r\n   if(linkedListNode != null && !linkedListNode.isEmpty()) {\r\n       linkedListNodeMap.put(key, this.doublyLinkedList.moveToFront(linkedListNode));\r\n       return Optional.of(linkedListNode.getElement().getValue());\r\n   }\r\n   return Optional.empty();\r\n }\r\n```","```\r\npublic LinkedListNode<T> moveToFront(LinkedListNode<T> node) {\r\n    return node.isEmpty() ? dummyNode : updateAndMoveToFront(node, node.getElement());\r\n}\r\n```","```\r\n@Test\r\npublic void addSomeDataToCache_WhenGetData_ThenIsEqualWithCacheElement(){\r\n    LRUCache<String,String> lruCache = new LRUCache<>(3);\r\n    lruCache.put(\"1\",\"test1\");\r\n    lruCache.put(\"2\",\"test2\");\r\n    lruCache.put(\"3\",\"test3\");\r\n    assertEquals(\"test1\",lruCache.get(\"1\").get());\r\n    assertEquals(\"test2\",lruCache.get(\"2\").get());\r\n    assertEquals(\"test3\",lruCache.get(\"3\").get());\r\n} \r\n```","```\r\n@Test\r\npublic void addDataToCacheToTheNumberOfSize_WhenAddOneMoreData_ThenLeastRecentlyDataWillEvict(){\r\n    LRUCache<String,String> lruCache = new LRUCache<>(3);\r\n    lruCache.put(\"1\",\"test1\");\r\n    lruCache.put(\"2\",\"test2\");\r\n    lruCache.put(\"3\",\"test3\");\r\n    lruCache.put(\"4\",\"test4\");\r\n    assertFalse(lruCache.get(\"1\").isPresent());\r\n }\r\n```","```\r\npublic class LRUCache<K, V> implements Cache<K, V> {\r\n    private int size;\r\n    private final Map<K, LinkedListNode<CacheElement<K,V>>> linkedListNodeMap;\r\n    private final DoublyLinkedList<CacheElement<K,V>> doublyLinkedList;\r\n    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\r\n\r\n    public LRUCache(int size) {\r\n        this.size = size;\r\n        this.linkedListNodeMap = new ConcurrentHashMap<>(size);\r\n        this.doublyLinkedList = new DoublyLinkedList<>();\r\n    }\r\n// ...\r\n}\r\n```","```\r\npublic boolean put(K key, V value) {\r\n  this.lock.writeLock().lock();\r\n   try {\r\n       //..\r\n   } finally {\r\n       this.lock.writeLock().unlock();\r\n   }\r\n}\r\n```","```\r\nprivate boolean evictElement() {\r\n    this.lock.writeLock().lock();\r\n    try {\r\n        //...\r\n    } finally {\r\n        this.lock.writeLock().unlock();\r\n    }\r\n}\r\n```","```\r\npublic Optional<V> get(K key) {\r\n    this.lock.readLock().lock();\r\n    try {\r\n        //...\r\n    } finally {\r\n        this.lock.readLock().unlock();\r\n    }\r\n} \r\n```","```\r\n@Test\r\npublic void runMultiThreadTask_WhenPutDataInConcurrentToCache_ThenNoDataLost() throws Exception {\r\n    final int size = 50;\r\n    final ExecutorService executorService = Executors.newFixedThreadPool(5);\r\n    Cache<Integer, String> cache = new LRUCache<>(size);\r\n    CountDownLatch countDownLatch = new CountDownLatch(size);\r\n    try {\r\n        IntStream.range(0, size).<Runnable>mapToObj(key -> () -> {\r\n            cache.put(key, \"value\" + key);\r\n            countDownLatch.countDown();\r\n       }).forEach(executorService::submit);\r\n       countDownLatch.await();\r\n    } finally {\r\n        executorService.shutdown();\r\n    }\r\n    assertEquals(cache.size(), size);\r\n    IntStream.range(0, size).forEach(i -> assertEquals(\"value\" + i,cache.get(i).get()));\r\n}\r\n```"]