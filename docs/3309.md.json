["```\r\n<dependency>\r\n    <groupId>org.glassfish.jersey.core</groupId>\r\n    <artifactId>jersey-client</artifactId>\r\n    <version>2.27</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.glassfish.jersey.inject</groupId>\r\n    <artifactId>jersey-hk2</artifactId>\r\n    <version>2.27</version>\r\n</dependency> \r\n```","```\r\n<dependency>\r\n    <groupId>org.glassfish.jersey.ext.rx</groupId>\r\n    <artifactId>jersey-rx-client-rxjava</artifactId>\r\n    <version>2.27</version>\r\n</dependency> \r\n```","```\r\n<dependency>\r\n    <groupId>org.glassfish.jersey.ext.rx</groupId>\r\n    <artifactId>jersey-rx-client-rxjava2</artifactId>\r\n    <version>2.27</version>\r\n</dependency>\r\n```","```\r\nClient client = ClientBuilder.newClient();\r\nWebTarget userIdService = client.target(\"http://localhost:8080/id-service/ids\");\r\nWebTarget nameService \r\n  = client.target(\"http://localhost:8080/name-service/users/{userId}/name\");\r\nWebTarget hashService = client.target(\"http://localhost:8080/hash-service/{rawValue}\");\r\n```","```\r\n// used to keep track of the progress of the subsequent calls\r\nCountDownLatch completionTracker = new CountDownLatch(expectedHashValues.size()); \r\n\r\nuserIdService.request()\r\n  .accept(MediaType.APPLICATION_JSON)\r\n  .async()\r\n  .get(new InvocationCallback<List<Long>>() {\r\n    @Override\r\n    public void completed(List<Long> employeeIds) {\r\n        employeeIds.forEach((id) -> {\r\n        // for each employee ID, get the name\r\n        nameService.resolveTemplate(\"userId\", id).request()\r\n          .async()\r\n          .get(new InvocationCallback<String>() {\r\n              @Override\r\n              public void completed(String response) {\r\n                     hashService.resolveTemplate(\"rawValue\", response + id).request()\r\n                    .async()\r\n                    .get(new InvocationCallback<String>() {\r\n                        @Override\r\n                        public void completed(String response) {\r\n                            //complete the business logic\r\n                        }\r\n                        // ommitted implementation of the failed() method\r\n                    });\r\n              }\r\n              // omitted implementation of the failed() method\r\n          });\r\n        });\r\n    }\r\n    // omitted implementation of the failed() method\r\n});\r\n\r\n// wait for inner requests to complete in 10 seconds\r\nif (!completionTracker.await(10, TimeUnit.SECONDS)) {\r\n    logger.warn(\"Some requests didn't complete within the timeout\");\r\n}\r\n```","```\r\nCompletionStage<List<Long>> userIdStage = userIdService.request()\r\n  .accept(MediaType.APPLICATION_JSON)\r\n  .rx()\r\n  .get(new GenericType<List<Long>>() {\r\n}).exceptionally((throwable) -> {\r\n    logger.warn(\"An error has occurred\");\r\n    return null;\r\n});\r\n```","```\r\nList<String> expectedHashValues = ...;\r\nList<String> receivedHashValues = new ArrayList<>(); \r\n\r\n// used to keep track of the progress of the subsequent calls \r\nCountDownLatch completionTracker = new CountDownLatch(expectedHashValues.size()); \r\n\r\nuserIdStage.thenAcceptAsync(employeeIds -> {\r\n  logger.info(\"id-service result: {}\", employeeIds);\r\n  employeeIds.forEach((Long id) -> {\r\n    CompletableFuture completable = nameService.resolveTemplate(\"userId\", id).request()\r\n      .rx()\r\n      .get(String.class)\r\n      .toCompletableFuture();\r\n\r\n    completable.thenAccept((String userName) -> {\r\n        logger.info(\"name-service result: {}\", userName);\r\n        hashService.resolveTemplate(\"rawValue\", userName + id).request()\r\n          .rx()\r\n          .get(String.class)\r\n          .toCompletableFuture()\r\n          .thenAcceptAsync(hashValue -> {\r\n              logger.info(\"hash-service result: {}\", hashValue);\r\n              receivedHashValues.add(hashValue);\r\n              completionTracker.countDown();\r\n          }).exceptionally((throwable) -> {\r\n              logger.warn(\"Hash computation failed for {}\", id);\r\n              return null;\r\n         });\r\n    });\r\n  });\r\n});\r\n\r\nif (!completionTracker.await(10, TimeUnit.SECONDS)) {\r\n    logger.warn(\"Some requests didn't complete within the timeout\");\r\n}\r\n\r\nassertThat(receivedHashValues).containsAll(expectedHashValues); \r\n```","```\r\nClient client = client.register(RxObservableInvokerProvider.class); \r\n```","```\r\nObservable<List<Long>> userIdObservable = userIdService\r\n  .request()\r\n  .rx(RxObservableInvoker.class)\r\n  .get(new GenericType<List<Long>>(){});\r\n```","```\r\nuserIdObservable.subscribe((List<Long> listOfIds)-> { \r\n  /** define processing flow for each ID */\r\n});\r\n```","```\r\nclient.register(RxFlowableInvokerProvider.class);\r\n```","```\r\nFlowable<List<Long>> userIdFlowable = userIdService\r\n  .request()\r\n  .rx(RxFlowableInvoker.class)\r\n  .get(new GenericType<List<Long>>(){});\r\n```"]