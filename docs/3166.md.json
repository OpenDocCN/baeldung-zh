["```\r\n// @ any collection mapping annotation\r\nprivate List<T> collection;\r\n```","```\r\n// @ any collection mapping annotation\r\n@OrderColumn(name = \"position\")\r\nprivate List<T> collection;\r\n```","```\r\n@Entity\r\nclass Artist {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.AUTO)\r\n    private Long id;\r\n\r\n    private String name;\r\n\r\n    @OneToMany(mappedBy = \"artist\", fetch = FetchType.EAGER)\r\n    private List<Song> songs;\r\n\r\n    @OneToMany(mappedBy = \"artist\", fetch = FetchType.EAGER)\r\n    private List<Offer> offers;\r\n\r\n    // constructor, equals, hashCode\r\n}\r\n```","```\r\n@OneToMany(mappedBy = \"artist\")\r\nprivate List<Song> songs;\r\n\r\n@OneToMany(mappedBy = \"artist\")\r\nprivate List<Offer> offers;\r\n```","```\r\n@Test\r\npublic void whenFetchingMoreThanOneBag_thenThrowAnException() {\r\n    IllegalArgumentException exception =\r\n      assertThrows(IllegalArgumentException.class, () -> {\r\n        String jpql = \"SELECT artist FROM Artist artist \"\r\n          + \"JOIN FETCH artist.songs \"\r\n          + \"JOIN FETCH artist.offers \";\r\n\r\n        entityManager.createQuery(jpql);\r\n    });\r\n\r\n    final String expectedMessagePart = \"MultipleBagFetchException\";\r\n    final String actualMessage = exception.getMessage();\r\n\r\n    assertTrue(actualMessage.contains(expectedMessagePart));\r\n}\r\n```","```\r\n@Entity\r\nclass Album {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.AUTO)\r\n    private Long id;\r\n\r\n    private String name;\r\n\r\n    @OneToMany(mappedBy = \"album\")\r\n    private List<Song> songs;\r\n\r\n    @ManyToMany(mappedBy = \"followingAlbums\")\r\n    private Set<Follower> followers;\r\n\r\n    // constructor, equals, hashCode\r\n\r\n}\r\n```","```\r\n@Entity\r\nclass User {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.AUTO)\r\n    private Long id;\r\n\r\n    private String name;\r\n\r\n    @OneToMany(mappedBy = \"createdBy\", cascade = CascadeType.PERSIST)\r\n    private List<Playlist> playlists;\r\n\r\n    @OneToMany(mappedBy = \"user\", cascade = CascadeType.PERSIST)\r\n    @OrderColumn(name = \"arrangement_index\")\r\n    private List<FavoriteSong> favoriteSongs;\r\n\r\n    // constructor, equals, hashCode\r\n}\r\n```","```\r\n@Test\r\npublic void whenFetchingOneBagAndSet_thenRetrieveSuccess() {\r\n    String jpql = \"SELECT DISTINCT album FROM Album album \"\r\n      + \"LEFT JOIN FETCH album.songs \"\r\n      + \"LEFT JOIN FETCH album.followers \"\r\n      + \"WHERE album.id = 1\";\r\n\r\n    Query query = entityManager.createQuery(jpql)\r\n      .setHint(QueryHints.HINT_PASS_DISTINCT_THROUGH, false);\r\n\r\n    assertEquals(1, query.getResultList().size());\r\n}\r\n```","```\r\n@Test\r\npublic void whenFetchingOneBagAndOneList_thenRetrieveSuccess() {\r\n    String jpql = \"SELECT DISTINCT user FROM User user \"\r\n      + \"LEFT JOIN FETCH user.playlists \"\r\n      + \"LEFT JOIN FETCH user.favoriteSongs \";\r\n\r\n    List<User> users = entityManager.createQuery(jpql, User.class)\r\n      .setHint(QueryHints.HINT_PASS_DISTINCT_THROUGH, false)\r\n      .getResultList();\r\n\r\n    assertEquals(3, users.size());\r\n}\r\n```","```\r\n@Test\r\npublic void whenUsingMultipleQueries_thenRetrieveSuccess() {\r\n    String jpql = \"SELECT DISTINCT artist FROM Artist artist \"\r\n      + \"LEFT JOIN FETCH artist.songs \";\r\n\r\n    List<Artist> artists = entityManager.createQuery(jpql, Artist.class)\r\n      .setHint(QueryHints.HINT_PASS_DISTINCT_THROUGH, false)\r\n      .getResultList();\r\n\r\n    jpql = \"SELECT DISTINCT artist FROM Artist artist \"\r\n      + \"LEFT JOIN FETCH artist.offers \"\r\n      + \"WHERE artist IN :artists \";\r\n\r\n    artists = entityManager.createQuery(jpql, Artist.class)\r\n      .setParameter(\"artists\", artists)\r\n      .setHint(QueryHints.HINT_PASS_DISTINCT_THROUGH, false)\r\n      .getResultList();\r\n\r\n    assertEquals(2, artists.size());\r\n}\r\n```"]