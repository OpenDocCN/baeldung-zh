# JVM 内部函数介绍

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jvm-intrinsics>

## **1。简介**

在本文中，我们将学习什么是内部函数，以及它们在 Java 和其他基于 JVM 的语言中是如何工作的。

## **2。什么是内部函数？**

一个[内部函数](https://web.archive.org/web/20220914050006/https://en.wikipedia.org/wiki/Intrinsic_function)是一个由我们的编程语言的编译器或解释器进行特殊处理的函数。更具体地说，这是一种特殊情况，编译器或解释器可以出于各种原因用替代实现替换该函数。

编程语言通常通过理解特定的方法调用是特殊的来处理这一点，并且每当我们调用该方法时，产生的行为是不同的。这使得我们的代码看起来与正常代码没有什么不同，但是编程语言的实现可以在特殊情况下进行干预，以提供额外的好处。

它的确切工作方式因编程语言以及操作系统和硬件而异。然而，因为这些是为我们处理的，我们通常不需要知道这些细节。

内部函数可以带来各种好处。用本机代码替换特定的算法可以使它们性能更好，甚至可以利用操作系统的特定功能或底层硬件。

## **3。JVM 上的内部函数**

JVM 通过用替代版本替换精确类上的精确方法调用来实现内部函数。JVM 自己处理这个问题，所以它只适用于核心类和特定的架构。它还允许只交换某些方法，而不是整个类。

JVM 之间的具体工作方式会有所不同。这不仅包括不同版本的 JVM——例如 Java 8 和 Java 11。这也包括不同的 JVM 目标——例如 Linux 与 Windows——尤其是 JVM 供应商——Oracle 与 IBM。在某些情况下，传递给 JVM 的某些命令行标志会影响它们。

这种多样性意味着没有办法仅仅根据应用程序来决定哪些方法会被 intrinsic 替代，哪些不会。基于运行应用程序的 JVM，它会有所不同。但是这在某些情况下会导致令人惊讶的结果—**包括简单地通过改变所使用的 JVM 而获得的显著的性能优势**。

## **4。性能优势**

**内部函数通常用于实现同一代码**的更高效版本，例如，通过利用正在运行的操作系统或 CPU 的实现细节。有时这是因为它可以使用更有效的实现，而其他时候它甚至可以使用特定于硬件的功能。

例如，HotSpot JDK 为`java.lang.Math`中的许多方法提供了一个内在的实现。根据具体的 JVM，这些可能使用 CPU 指令来执行所需的精确计算。

一个简单的测试将证明这一点。比如拿`java.lang.Math.sqrt()`来说。我们可以写一个测试:

```
for (int a = 0; a < 100000; ++a) {
    double result = Math.sqrt(a);
} 
```

该测试执行 100，000 次平方根运算，大约需要 123 毫秒。然而，如果我们用`Math.sqrt()`实现的副本来替换这段代码:

```
double result = StrictMath.sqrt(a);
```

这段代码做同样的事情，但是执行时间是 166 毫秒。通过复制实现，而不是允许 JVM 用内部版本替换它，这增加了 35%。

## **5。不可能的实现**

在其他情况下，内部函数用于代码不能用 Java 实现的情况。这些通常是为非常低级的情况保留的。

例如，让我们看看`java.lang.Thread` 类中的方法`onSpinWait()`。此方法指示该线程当前不执行任何工作，CPU 时间可以给另一个线程。要实现这一点，它需要在尽可能低的层次上工作。

**x86 架构的 HotSpot JDK 使用`PAUSE`操作码直接在 CPU 上实现这一点。**实现这一点的唯一其他方法是使用一个 [JNI](/web/20220914050006/https://www.baeldung.com/jni) 调用本地代码，这涉及的开销会抵消调用的好处。

## **6。识别 Java 中的内部函数**

不幸的是，没有一种确定的方法可以被内部版本所取代。这是因为不同的 JVM 甚至不同平台上的同一个 JVM 对于不同的方法都会这样做。

然而，当从 Java 9 开始使用 Hotspot JVM 时，`@HotSpotIntrinsicCandidate`注释被用在所有可能被替换的方法上。添加这个注释不会自动导致方法被替换。实际上，这发生在底层 JVM 中。相反，JVM 开发人员知道这些方法是特殊的，要小心使用。

其他 JVM 可能会以不同的方式处理这个问题，如果它们被识别出来的话。这包括 Java 8 或更早版本中的 Hotspot JVM。

## **7。总结**

我们不能编写依赖于内部函数的程序，因为没有办法知道它们在运行时 JVM 上是否可用。然而，它们是一种令人信服的方法，JVM 可以用它来改进程序的工作方式。

这些内部特性可以——而且经常——添加到 JVM 的新版本中。然后，这允许简单地通过升级我们正在运行的 JVM 来改进我们已经运行的代码，所以这是确保我们保持依赖项和运行时最新的另一个原因。