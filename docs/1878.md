# 用 Jackson 实现 XML 序列化和反序列化

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jackson-xml-serialization-and-deserialization>

## **1。概述**

在本教程中，我们将学习**如何使用 Jackson 2.x 将 Java 对象序列化为 XML 数据，并将它们反序列化回 POJO** 。

我们将关注不需要太多复杂性或定制的基本操作。

## **2。`XmlMapper`对象**

`XmlMapper` 是 Jackson 2.x 中帮助我们序列化的主类，所以我们需要创建它的一个实例:

[PRE0]

这个 `mapper` 在`jackson-dataformat-xml` jar 中是可用的，所以我们必须将它作为一个依赖项添加到我们的`pom.xml`中:

[PRE1]

请在 Maven 仓库中检查最新版本的 jackson-dataformat-xml 依赖关系。

## **3。将 Java 序列化为 XML**

`XmlMapper`是`ObjectMapper,`的子类，用于 JSON 序列化；但是，它向父类添加了一些特定于 XML 的调整。

让我们看看如何使用它来进行实际的序列化。让我们首先创建一个 Java 类:

[PRE2]

### **3.1。`String`序列化为 XML**

我们可以将 Java 对象序列化成 XML `String`:

[PRE3]

结果，我们会得到:

[PRE4]

### **3.2。序列化为 XML 文件**

我们还可以将 Java 对象序列化为 XML 文件:

[PRE5]

下面我们可以看到名为`simple_bean.xml`的结果文件的内容:

[PRE6]

## **4。将 XML 反序列化为 Java**

在这一节中，我们将研究如何从 XML 中获取 Java 对象。

### **4.1。从 XML 字符串**反序列化

与序列化一样，我们也可以将 XML 字符串反序列化为 Java 对象:

[PRE7]

### **4.2。从 XML 文件**反序列化

同样，如果我们有一个 XML 文件，我们可以将其转换回 Java 对象。

[PRE8]

## **5。处理资本化元素**

在这一节中，我们将讨论如何处理这样的场景:要么我们有要反序列化的带有大写元素的 XML，要么我们需要将 Java 对象序列化为带有一个或多个大写元素的 XML。

### **5.1。从 XML 中反序列化`String`**

假设我们有一个字段大写的 XML:

[PRE9]

为了正确处理大写的元素，我们需要用`@JsonProperty`注释来注释“x”字段:

[PRE10]

我们现在可以正确地将 XML `String`反序列化回 Java 对象:

[PRE11]

### 5.2。序列化为 XML 字符串

通过用`@JsonProperty,`注释必需的字段，我们可以正确地将一个 Java 对象序列化为一个 XML `String`,其中包含一个或多个大写的元素:

[PRE12]

## 6.**将`List`序列化为 XML**

`XmlMapper`能够将整个 Java bean 序列化为一个文档。为了将 Java 对象转换成 XML，我们举一个简单的例子，它包含一个嵌套的对象和数组。

我们的目的是将一个`Person`对象及其组合的`Address`对象序列化为 XML。

我们最终的 XML 看起来会像这样:

[PRE13]

**注意，我们的电话号码被封装在一个`phoneNumbers`包装器中，而我们的地址没有。**

我们可以通过`Person`类中的`@JacksonXMLElementWrapper`注释来表达这种细微差别:

[PRE14]

事实上，我们可以用`@JacksonXmlElementWrapper(localName = ‘phoneNumbers').` 改变包装元素的名称，或者，如果我们不想包装我们的元素，我们可以用`@JacksonXmlElementWrapper(useWrapping = false)`禁用映射。

然后我们将定义我们的`Address` 类型:

[PRE15]

**杰克逊为我们处理剩下的事情。**像以前一样，我们可以简单地再叫`writeValue`:

[PRE16]

## **7。将 XML 反序列化到`List`**

Jackson 也可以读取包含对象列表的 XML。

如果我们像以前一样使用相同的 XML，`readValue` 方法就很好:

[PRE17]

## **8。结论**

这篇简短的文章演示了如何将简单的 POJO 序列化为 XML，并从基本的 XML 数据中获取 POJO。

我们还探索了如何序列化和反序列化包含集合的复杂 beans。

本文附带的源代码可以在 [GitHub](https://web.archive.org/web/20220727020632/https://github.com/eugenp/tutorials/tree/master/jackson-modules/jackson-conversions) 上获得。