["```\r\npublic IntStream getPseudoInts(String algorithm, int streamSize) {\r\n    // returns an IntStream with size @streamSize of random numbers generated using the @algorithm\r\n    // where the lower bound is 0 and the upper is 100 (exclusive)\r\n    return RandomGeneratorFactory.of(algorithm)\r\n            .create()\r\n            .ints(streamSize, 0,100);\r\n}\r\n```","```\r\n static record Human (String name, int age, String profession) {}\r\n\r\npublic String checkObject(Object obj) {\r\n    return switch (obj) {\r\n        case Human h -> \"Name: %s, age: %s and profession: %s\".formatted(h.name(), h.age(), h.profession());\r\n        case Circle c -> \"This is a circle\";\r\n        case Shape s -> \"It is just a shape\";\r\n        case null -> \"It is null\";\r\n        default -> \"It is an object\";\r\n    };\r\n}\r\n\r\npublic String checkShape(Shape shape) {\r\n    return switch (shape) {\r\n        case Triangle t && (t.getNumberOfSides() != 3) -> \"This is a weird triangle\";\r\n        case Circle c && (c.getNumberOfSides() != 0) -> \"This is a weird circle\";\r\n        default -> \"Just a normal shape\";\r\n    };\r\n} \r\n```","```\r\n int getNumberOfSides(Shape shape) {\r\n    return switch (shape) {\r\n        case WeirdTriangle t -> t.getNumberOfSides();\r\n        case Circle c -> c.getNumberOfSides();\r\n        case Triangle t -> t.getNumberOfSides();\r\n        case Rectangle r -> r.getNumberOfSides();\r\n        case Square s -> s.getNumberOfSides();\r\n    };\r\n} \r\n```","```\r\n private static final SymbolLookup libLookup;\r\n\r\nstatic {\r\n    // loads a particular C library\r\n    var path = JEP412.class.getResource(\"/print_name.so\").getPath();\r\n    System.load(path);\r\n    libLookup = SymbolLookup.loaderLookup();\r\n} \r\n```","```\r\n public String getPrintNameFormat(String name) {\r\n\r\n    var printMethod = libLookup.lookup(\"printName\");\r\n\r\n    if (printMethod.isPresent()) {\r\n        var methodReference = CLinker.getInstance()\r\n            .downcallHandle(\r\n                printMethod.get(),\r\n                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\r\n                FunctionDescriptor.of(CLinker.C_POINTER, CLinker.C_POINTER)\r\n            );\r\n\r\n        try {\r\n            var nativeString = CLinker.toCString(name, newImplicitScope());\r\n            var invokeReturn = methodReference.invoke(nativeString.address());\r\n            var memoryAddress = (MemoryAddress) invokeReturn;\r\n            return CLinker.toJavaString(memoryAddress);\r\n        } catch (Throwable throwable) {\r\n            throw new RuntimeException(throwable);\r\n        }\r\n    }\r\n    throw new RuntimeException(\"printName function not found.\");\r\n} \r\n```","```\r\n public void newVectorComputation(float[] a, float[] b, float[] c) {\r\n    for (var i = 0; i < a.length; i += SPECIES.length()) {\r\n        var m = SPECIES.indexInRange(i, a.length);\r\n        var va = FloatVector.fromArray(SPECIES, a, i, m);\r\n        var vb = FloatVector.fromArray(SPECIES, b, i, m);\r\n        var vc = va.mul(vb);\r\n        vc.intoArray(c, i, m);\r\n    }\r\n}\r\n\r\npublic void commonVectorComputation(float[] a, float[] b, float[] c) {\r\n    for (var i = 0; i < a.length; i ++) {\r\n        c[i] = a[i] * b[i];\r\n    }\r\n} \r\n```"]