["```\r\n<dependency>\r\n    <groupId>org.apache.kafka</groupId>\r\n    <artifactId>kafka-clients</artifactId>\r\n    <version>2.8.0</version>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>org.apache.kafka</groupId>\r\n    <artifactId>kafka-streams</artifactId>\r\n    <version>2.8.0</version>\r\n </dependency>\r\n```","```\r\nStreamsBuilder builder = new StreamsBuilder();\r\nKStream<String, String> textLines = \r\n  builder.stream(inputTopic, Consumed.with(Serdes.String(), Serdes.String()));\r\n```","```\r\nKTable<String, String> textLinesTable = \r\n  builder.table(inputTopic, Consumed.with(Serdes.String(), Serdes.String()));\r\n```","```\r\nGlobalKTable<String, String> textLinesGlobalTable = \r\n  builder.globalTable(inputTopic, Consumed.with(Serdes.String(), Serdes.String()));\r\n```","```\r\nKStream<String, String> textLinesUpperCase =\r\n  textLines\r\n    .map((key, value) -> KeyValue.pair(value, value.toUpperCase()))\r\n    .filter((key, value) -> value.contains(\"FILTER\"));\r\n```","```\r\nKTable<String, Long> wordCounts = textLines\r\n  .flatMapValues(value -> Arrays.asList(value\r\n    .toLowerCase(Locale.getDefault()).split(\"\\\\W+\")))\r\n  .groupBy((key, word) -> word)\r\n    .count(Materialized.<String, Long, KeyValueStore<Bytes, byte[]>> as(\"counts-store\"));\r\n```","```\r\nString TEXT_EXAMPLE_1 = \"test test and test\";\r\nString TEXT_EXAMPLE_2 = \"test filter filter this sentence\"; \r\n```","```\r\nWord: and -> 1\r\nWord: test -> 4\r\nWord: filter -> 2\r\nWord: this -> 1\r\nWord: sentence -> 1\r\n```","```\r\nKStream<String, String> leftRightSource = leftSource.outerJoin(rightSource,\r\n  (leftValue, rightValue) -> \"left=\" + leftValue + \", right=\" + rightValue,\r\n    JoinWindows.of(Duration.ofSeconds(5))).groupByKey()\r\n      .reduce(((key, lastValue) -> lastValue))\r\n  .toStream();\r\n```","```\r\n(key= 1) -> (left=left, right=null)\r\n(key= 2) -> (left=null, right=right)\r\n```","```\r\nKTable<String, Long> aggregated = input\r\n  .groupBy((key, value) -> (value != null && value.length() > 0)\r\n    ? value.substring(0, 2).toLowerCase() : \"\",\r\n    Grouped.with(Serdes.String(), Serdes.String()))\r\n  .aggregate(() -> 0L, (aggKey, newValue, aggValue) -> aggValue + newValue.length(),\r\n    Materialized.with(Serdes.String(), Serdes.Long()));\r\n```","```\r\n\"one\", \"two\", \"three\", \"four\", \"five\" \r\n```","```\r\nWord: on -> 3\r\nWord: tw -> 3\r\nWord: th -> 5\r\nWord: fo -> 4\r\nWord: fi -> 4\r\n```","```\r\nstreamsConfiguration.put(StreamsConfig.PROCESSING_GUARANTEE_CONFIG,\r\n  StreamsConfig.EXACTLY_ONCE);\r\n```","```\r\nKStream<String, String> textLines = \r\n  builder.stream(TEXT_LINES_TOPIC, Consumed.with(Serdes.String(), Serdes.String()));\r\n\r\nfinal KGroupedStream<String, String> groupedByWord = textLines\r\n  .flatMapValues(value -> Arrays.asList(value.toLowerCase().split(\"\\\\W+\")))\r\n  .groupBy((key, word) -> word, Grouped.with(stringSerde, stringSerde));\r\n```","```\r\ngroupedByWord\r\n  .count(Materialized.<String, Long, KeyValueStore<Bytes, byte[]>>as(\"WordCountsStore\")\r\n  .withValueSerde(Serdes.Long()));\r\n```","```\r\nReadOnlyKeyValueStore<String, Long> keyValueStore =\r\n  streams.store(StoreQueryParameters.fromNameAndType(\r\n    \"WordCountsStore\", QueryableStoreTypes.keyValueStore()));\r\n\r\nKeyValueIterator<String, Long> range = keyValueStore.all();\r\nwhile (range.hasNext()) {\r\n    KeyValue<String, Long> next = range.next();\r\n    System.out.println(\"count for \" + next.key + \": \" + next.value);\r\n}\r\n```","```\r\nCount for and: 1\r\nCount for filter: 2\r\nCount for sentence: 1\r\nCount for test: 4\r\nCount for this: 1\r\n```"]