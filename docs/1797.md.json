["```\r\nclass Book {\r\n    private String name;\r\n    private int releaseYear;\r\n    private String isbn;\r\n\r\n    // getters and setters\r\n}\r\n```","```\r\nList<Book> bookList = new ArrayList<>();\r\nbookList.add(new Book(\"The Fellowship of the Ring\", 1954, \"0395489318\"));\r\nbookList.add(new Book(\"The Two Towers\", 1954, \"0345339711\"));\r\nbookList.add(new Book(\"The Return of the King\", 1955, \"0618129111\"));\r\n```","```\r\nCollector<T, ?, Map<K,U>> toMap(Function<? super T, ? extends K> keyMapper,\r\n  Function<? super T, ? extends U> valueMapper)\r\n```","```\r\npublic Map<String, String> listToMap(List<Book> books) {\r\n    return books.stream().collect(Collectors.toMap(Book::getIsbn, Book::getName));\r\n}\r\n```","```\r\n@Test\r\npublic void whenConvertFromListToMap() {\r\n    assertTrue(convertToMap.listToMap(bookList).size() == 3);\r\n}\r\n```","```\r\npublic Map<Integer, Book> listToMapWithDupKeyError(List<Book> books) {\r\n    return books.stream().collect(\r\n      Collectors.toMap(Book::getReleaseYear, Function.identity()));\r\n}\r\n```","```\r\n@Test(expected = IllegalStateException.class)\r\npublic void whenMapHasDuplicateKey_without_merge_function_then_runtime_exception() {\r\n    convertToMap.listToMapWithDupKeyError(bookList);\r\n}\r\n```","```\r\nCollector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper,\r\n  Function<? super T, ? extends U> valueMapper,\r\n  BinaryOperator<U> mergeFunction) \r\n```","```\r\npublic Map<Integer, Book> listToMapWithDupKey(List<Book> books) {\r\n    return books.stream().collect(Collectors.toMap(Book::getReleaseYear, Function.identity(),\r\n      (existing, replacement) -> existing));\r\n}\r\n```","```\r\n@Test\r\npublic void whenMapHasDuplicateKeyThenMergeFunctionHandlesCollision() {\r\n    Map<Integer, Book> booksByYear = convertToMap.listToMapWithDupKey(bookList);\r\n    assertEquals(2, booksByYear.size());\r\n    assertEquals(\"0395489318\", booksByYear.get(1954).getIsbn());\r\n}\r\n```","```\r\nCollector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper,\r\n  Function<? super T, ? extends U> valueMapper,\r\n  BinaryOperator<U> mergeFunction,\r\n  Supplier<M> mapSupplier)\r\n```","```\r\npublic Map<Integer, Book> listToConcurrentMap(List<Book> books) {\r\n    return books.stream().collect(Collectors.toMap(Book::getReleaseYear, Function.identity(),\r\n      (o1, o2) -> o1, ConcurrentHashMap::new));\r\n}\r\n```","```\r\n@Test\r\npublic void whenCreateConcurrentHashMap() {\r\n    assertTrue(convertToMap.listToConcurrentMap(bookList) instanceof ConcurrentHashMap);\r\n}\r\n```","```\r\npublic TreeMap<String, Book> listToSortedMap(List<Book> books) {\r\n    return books.stream() \r\n      .collect(\r\n        Collectors.toMap(Book::getName, Function.identity(), (o1, o2) -> o1, TreeMap::new));\r\n}\r\n```","```\r\n@Test\r\npublic void whenMapisSorted() {\r\n    assertTrue(convertToMap.listToSortedMap(bookList).firstKey().equals(\r\n      \"The Fellowship of the Ring\"));\r\n}\r\n```"]