# Java 面试问题

> 原文:[https://web . archive . org/web/20220930061024/https://www . bael dung . com/Java-interview-questions](https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-interview-questions)

**目录**

*   [简介](#introduction)
*   【Java 核心问题**初学者**
    *   [Q1。Java 中数据是按引用传递还是按值传递？](#beginner-q1)
    *   [Q2。导入和静态导入有什么区别？](#beginner-q2)
    *   [Q3。Java 中有哪些访问修饰符，它们的用途是什么？](#beginner-q3)
    *   [Q4。Java 中还有哪些修饰符，它们的用途是什么？](#beginner-q4)
    *   [Q5。JDK、JRE 和 JVM 之间有什么区别？](#beginner-q5)
    *   [Q6。栈和堆的区别是什么？](#beginner-q6)
    *   [Q7。可比接口和比较器接口有什么区别？](#beginner-q7)
    *   [Q8。什么是空类型，我们什么时候使用它？](#beginner-q8)
    *   [Q9。Object 类的方法是什么，它们是做什么的？](#beginner-q9)
    *   [Q10。什么是枚举以及我们如何使用它？](#beginner-q10)
    *   [Q11。什么是罐子？](#beginner-q11)
    *   [Q12。什么是 NullPointerException？](#beginner-q12)
    *   [Q13。Java 中有哪两种类型的强制转换？强制转换时可能会抛出哪个异常？怎么才能避免呢？](#beginner-q13)

*   [面向**高级**程序员的核心 Java 问题](#advanced-questions)
    *   [Q1。为什么 String 是不可变类？](#advanced-q1)
    *   [Q2。动态绑定和静态绑定有什么区别？](#advanced-q2)
    *   [Q3。什么是 JIT？](#advanced-q3)
    *   [Q4。Java 中的反射是什么？](#advanced-q4)
    *   [Q5。什么是类加载器？](#advanced-q5)
    *   [Q6。静态类加载和动态类加载有什么区别？](#advanced-q6)
    *   [Q7。可序列化接口的用途是什么？](#advanced-q7)
    *   [Q8。Java 里有析构函数吗？](#advanced-q8)

## 1.介绍

这篇文章包含了关于核心 Java 的一些最重要的工作面试问题的答案。其中一些问题的答案可能并不明显，因此本文将有助于澄清这些问题。

## 2.面向初学者的核心 Java 问题

### Q1。Java 中数据是按引用传递还是按值传递？

虽然这个问题的答案相当简单，但这个问题可能会让初学者感到困惑。首先，让我们弄清楚这个问题是关于什么的:

1.  **通过值传递-**意味着我们将对象的副本作为参数传递给**一个方法。**
2.  **通过引用传递-**意味着我们将对对象的引用作为参数传递给**一个方法。**

要回答这个问题，我们必须分析两个案例。它们表示我们可以传递给方法的两种类型的数据:原语和对象。

当我们将原语传递给一个方法时，它的值被复制到一个新的变量中。对于对象，引用的值被复制到一个新的变量中。**所以我们可以说 Java 是一门严格意义上的`pass-by-value`语言。**

我们可以在我们的一篇文章中了解到更多信息:[在 Java 中作为参数传递机制的传值传递](/web/20220626110738/https://www.baeldung.com/java-pass-by-value-or-pass-by-reference)。

### Q2。导入和静态导入有什么区别？

我们可以使用常规导入来导入在不同包中定义的特定类或所有类:

```
import java.util.ArrayList; //specific class
import java.util.*; //all classes in util package
```

我们还可以使用它们来导入封闭类的公共嵌套类:

```
import com.baeldung.A.*
```

然而，我们应该知道上面的导入并没有导入类`A`本身。

**也有静态导入，使我们能够导入静态成员或嵌套类:**

```
import static java.util.Collections.EMPTY_LIST;
```

其效果是我们可以使用静态变量 EMPTY_LIST，而不用预先考虑完全限定的类名，也就是说，好像它是在当前类中声明的一样。

### Q3。Java 中有哪些访问修饰符，它们的用途是什么？

在`Java`中有四个访问修饰符:

1.  `private`
2.  `default`(包)
3.  `protected`
4.  `public`

**`private`修饰符确保类成员在类之外是不可访问的。**可以应用于方法、属性、构造函数、嵌套类，但不能应用于顶级类本身。

与`private`修饰符不同，我们可以将`default`修饰符应用于所有类型的类成员和类本身。我们可以通过不添加任何访问修饰符来应用`default`可见性。**如果我们使用`default`可见性，我们的类或者它的成员将只能在我们的类的包里面被访问。我们应该记住，默认访问修饰符和`default`关键字没有任何共同之处。**

类似于`default`修饰符，一个包中的所有类都可以访问`protected`成员。**此外，`protected`修饰符允许子类访问超类的受保护成员，即使它们不在同一个包中。**我们不能将这个访问修饰符应用于类，只能应用于类成员。

`public`修饰符可以和`class`关键字以及所有的类成员一起使用。**它使得类和类成员可以被所有的包和所有的类访问。**

我们可以在 [Java 访问修饰符](/web/20220626110738/https://www.baeldung.com/java-access-modifiers)文章中了解更多。

### Q4。Java 中还有哪些修饰符，它们的用途是什么？

Java 中还有五种其他可用的修饰符:

*   `static`
*   `final`
*   `abstract`
*   `synchronized`
*   `volatile`

这些不控制可见性。

首先，我们可以将`static`关键字应用于字段和方法。**静态字段或方法是类成员，而非静态字段或方法是对象成员**。类成员不需要实例来调用。它们是用类名而不是对象引用名调用的。[这篇文章](/web/20220626110738/https://www.baeldung.com/java-static)更详细地介绍了`static`关键字。

然后，我们有了`final`关键字。我们可以将它用于字段、方法和类。**当`final`用于字段时，表示字段引用不可更改。**因此它不能被重新分配给另一个对象。当`final`被应用到一个类或方法时，它向我们保证这个类或方法不能被扩展或覆盖。`final`关键字在[这篇文章](/web/20220626110738/https://www.baeldung.com/java-final)中有更详细的解释。

下一个关键词是`abstract`。这个可以描述类和方法。**类为`abstract`时，不能实例化。**相反，它们意味着被子类化。当方法被`abstract`时，它们没有实现，可以在子类中被覆盖。

`synchronized`关键字可能是最高级的。我们可以将它用于实例以及静态方法和代码块。**当我们使用这个关键字时，我们让 Java 使用一个监控锁来提供给定代码片段的同步。**更多关于`synchronized`的信息可以在[这篇文章](/web/20220626110738/https://www.baeldung.com/java-synchronized)中找到。

我们要讨论的最后一个关键词是`volatile`。我们只能将它与实例字段一起使用。**它声明字段值必须从主存储器读取和写入，绕过 CPU 缓存。**所有对可变变量的读写都是原子的。volatile 关键字在[这篇文章](/web/20220626110738/https://www.baeldung.com/java-volatile)中有详细解释。

### Q5。JDK、JRE 和 JVM 之间有什么区别？

`JDK`代表`Java Development Kit`，是开发者用 Java 编写应用所必需的一套工具。有三种类型的 JDK 环境:

*   标准版–用于创建便携式桌面或服务器应用程序的开发套件
*   企业版–标准版的扩展，支持分布式计算或 web 服务
*   微型版–嵌入式和移动应用的开发平台

JDK 中有很多工具**帮助程序员编写、调试或维护应用**。最流行的是编译器(`javac`)、解释器(`java`)、归档器(`jar`)和文档生成器(`javadoc`)。

`JRE`是一个`Java Runtime Environment`。它是 JDK 的一部分，但是**它包含了运行 Java 应用**的最小功能。它由一个`Java Virtual Machine`、核心类和支持文件组成。例如，它没有任何编译器。

`JVM`是`Java Virtual Machine`的首字母缩写，是一个能够运行编译成字节码的程序的虚拟机。它由 JVM 规范描述，因为确保不同实现之间的互操作性很重要。**JVM 最重要的功能是让用户能够将同一个 Java 应用程序部署到不同的操作系统和环境中，而不用担心底层是什么。**

要了解更多信息，让我们来看看 JVM、JRE 和 JDK 文章之间的[差异。](/web/20220626110738/https://www.baeldung.com/jvm-vs-jre-vs-jdk)

### Q6。栈和堆的区别是什么？

JVM 在内存的两个部分存储所有的变量和对象。第一个是`stack`，第二个是`heap`。

**`stack`是 JVM 为局部变量和附加数据**保留块的地方。堆栈是一个`LIFO`(后进先出)结构。这意味着无论何时调用一个方法，都会为局部变量和对象引用保留一个新的块。每次新方法调用都会保留下一个块。当方法完成它们的执行时，块以与它们开始时相反的方式被释放。

每个新线程都有自己的堆栈。

我们应该知道，堆栈的内存空间比堆小得多。当栈满时，JVM 会抛出一个`StackOverflowError`。当有一个错误的递归调用并且递归太深时，很可能会发生这种情况。

**每个新对象都在 Java `h` `eap`上创建，用于动态分配**。有一个`g` `arbage collector`负责擦除未使用的对象，分为年轻(托儿所)和旧空间。内存访问堆比访问堆栈慢。当堆满时，JVM 抛出一个`OutOfMemoryError`。

我们可以在 Java 中的堆栈内存和堆空间的文章中找到更多的细节。

### Q7。`Comparable `和`Comparator`接口有什么区别？

有时当我们编写一个新类时，我们希望能够比较该类的对象。当我们想要使用排序的集合时，它特别有用。有两种方法可以做到这一点:使用`Comparable`接口或者使用`Comparator`接口。

首先，我们来看一下`Comparable`界面:

```
public interface Comparable<T> {
    int compareTo(T var1);
}
```

我们应该通过我们想要对其对象进行排序的类来实现这个接口。

它有`compareTo()`方法并返回一个整数。它可以返回三个值:-1、0 和 1，这意味着该对象小于、等于或大于被比较的对象。

**值得一提的是，被覆盖的`compareT0()`方法应该与`equals()`方法保持一致。**

另一方面，我们可以使用`Comparator`接口。它可以传递给`Collection`接口的`sort()`方法，或者在实例化排序后的集合时传递。这就是为什么它主要用于创建一次性排序策略。

**更重要的是，当我们使用没有实现 Comparable 接口的第三方类时，它也很有用。**

像`compareTo()`方法一样，被覆盖的`compare()`方法应该与`equals()`方法一致，但是它们可以选择允许与空值进行比较。

让我们访问 Java 中的 [Comparator 和 Comparable](/web/20220626110738/https://www.baeldung.com/java-comparator-comparable)文章以获得更多信息。

### Q8。什么是`void`型，我们什么时候用？

每次我们用 Java 写一个方法，它都必须有一个返回类型。如果我们想让方法不返回值，我们可以使用`void`关键字。

我们也要知道还有一个`Void`类。它是一个占位符类，例如，在处理泛型时可能会用到。`Void`类既不能实例化也不能扩展。

### Q9。Object 类的方法是什么，它们是做什么的？

了解`Object`类包含什么方法以及它们如何工作是很重要的。当我们想要覆盖这些方法时，它也非常有用:

*   `clone()`–返回该对象的副本
*   `equals()`–当该对象等于作为参数传递的对象时，返回`true`
*   垃圾收集器在清理内存时调用这个方法
*   `getClass()`–返回该对象的运行时类
*   `hashCode()`–返回该对象的散列码。**我们应该知道，它应该与`equals()`方法**一致
*   `notify()`–向等待对象监视器的单个线程发送通知
*   `notifyAll()`–向等待对象监视器的所有线程发送通知
*   `toString()`–返回该对象的字符串表示
*   这个方法有三个重载版本。它强制当前线程等待指定的时间，直到另一个线程在这个对象上调用`notify()`或`notifyAll()`。

### Q10。什么是枚举以及我们如何使用它？

`Enum`是一种允许开发者指定一组预定义常量值的类。要创建这样一个类，我们必须使用`enum`关键字。让我们想象一周中的几天:

```
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY 
}
```

为了迭代所有常量，我们可以使用静态的`values()`方法。更重要的是，枚举使我们能够像常规类一样定义属性和方法等成员。

虽然它是一个特殊类型的类，但是我们不能对它进行子类化。然而，一个枚举可以实现一个接口。

`Enums`的另一个有趣的优点是它们是线程安全的，因此它们被普遍用作单例。

我们可以在我们的指南之一中找到更多关于枚举的信息。

### Q11。什么是**一个**罐子？

`JAR `是`Java archive`的快捷方式。这是一个使用 ZIP 文件格式打包的存档文件。我们可以用它来包含应用程序所必需的类文件和辅助资源。它有许多特点:

*   **安全性–**我们可以对 JAR 文件进行数字签名
*   **压缩—**在使用 JAR 时，我们可以压缩文件以提高存储效率
*   **可移植性—**我们可以在多个平台上使用同一个 JAR 文件
*   **版本化–**JAR 文件可以保存关于它们所包含的文件的元数据
*   **密封—**我们可以在 JAR 文件中密封一个包。这意味着一个包中的所有类都必须包含在同一个 JAR 文件中
*   **扩展–**我们可以使用 JAR 文件格式来打包现有软件的模块或扩展

### Q12。什么是**一** `NullPointerException`？

`NullPointerException`可能是 Java 世界中最常见的异常。这是一个未检查的异常，因此扩展了`RuntimeException`。我们不应该试图处理它。

当我们试图访问一个变量或者调用一个空引用的方法时，就会抛出这个异常，比如:

*   调用空引用的方法
*   设置或获取空引用的字段
*   检查空数组引用的长度
*   设置或获取空数组引用的项
*   投掷`null`

### Q13。Java 中有哪两种类型的强制转换？强制转换时可能会抛出哪个异常？怎么才能避免呢？

我们可以区分 Java 中的两种类型的造型。我们可以进行向上转换，将一个对象转换为父类型，或者向下转换，将一个对象转换为子类型。

很简单，因为我们总能做到。例如，我们可以将一个`String`实例向上转换为`Object`类型:

```
Object str = "string";
```

或者，我们可以`downcast`一个变量。它不像向上转换那样安全，因为它涉及类型检查。如果我们错误地转换了一个对象，JVM 将在运行时抛出一个`ClassCastExcpetion`。**幸运的是，我们可以使用`instanceof`关键字来防止无效的铸造:**

```
Object o = "string";
String str = (String) o; // it's ok

Object o2 = new Object();
String str2 = (String) o2; // ClassCastException will be thrown

if (o2 instanceof String) { // returns false
    String str3 = (String) o2;
}
```

我们可以在这篇文章中了解更多关于类型转换的信息。

## 3.面向高级程序员的核心 Java 问题

### Q1。为什么 String 是不可变类？

我们应该知道，`JVM`对`String`对象的处理不同于其他对象。一个区别是`String`对象是不可变的。**这意味着一旦我们创建了它们，就无法更改。**他们这样做有几个原因:

1.  它们存储在`string pool`中，这是堆内存的一个特殊部分。它负责节省大量空间。
2.  `String`类的不变性保证了它的哈希代码不会改变。**由于这个事实，`Strings`可以有效地用作散列集合中的键。**我们可以确定，我们不会因为哈希码的变化而覆盖任何数据。
3.  它们可以安全地跨多个线程使用。**没有线程可以改变一个`String`对象的值，所以我们免费获得线程安全。**
4.  字符串是不可变的，以避免严重的安全问题。密码等敏感数据可能会被不可靠的来源或另一个线程更改。

我们可以在本文中了解更多关于字符串[的不变性。](/web/20220626110738/https://www.baeldung.com/java-string-immutable)

### Q2。动态绑定和静态绑定有什么区别？

Java 中的绑定是将方法调用与适当的方法体关联起来的过程。我们可以区分 Java 中的两种绑定类型:静态和动态。

静态绑定和动态绑定的主要区别在于静态绑定发生在编译时，而动态绑定发生在运行时。

`Static binding`使用类信息进行绑定。它负责解析是`private` 或`static`和`final`方法和变量的类成员。此外，静态绑定绑定重载的方法。

另一方面，`Dynamic binding`使用对象信息来解析绑定。这就是它负责解析虚方法和重写方法的原因。

### Q3。什么是 JIT？

`JIT`代表“刚好及时”。它是 JRE 的一个组件，在运行时运行并提高应用程序的性能。**具体来说，它是一个在程序启动后运行的编译器。**

这不同于常规的 Java 编译器，后者在应用程序启动之前很久就编译了代码。JIT 可以以不同的方式加速应用程序。

例如，JIT 编译器负责动态地将字节码编译成本机指令，以提高性能。此外，它还可以针对目标 CPU 和操作系统优化代码。

此外，它可以访问许多运行时统计信息，这些信息可用于重新编译以获得最佳性能。这样，它还可以进行一些全局代码优化或重新排列代码，以提高缓存利用率。

### Q4。Java 中的反射是什么？

反射是 Java 中非常强大的机制。反射是 Java 语言的一种机制，它使程序员能够检查或修改程序的内部状态(属性、方法、类等)。)在运行时。java.lang.reflect 包提供了使用反射所需的所有组件。

当使用这个特性时，我们可以访问类定义中包含的所有可能的字段、方法和构造函数。我们可以访问它们，而不管它们的访问修饰符。这意味着，例如，我们能够访问私人成员。为此，我们不需要知道他们的名字。我们要做的就是使用`Class`的一些静态方法。

值得一提的是，有可能通过反射来限制访问。为此，我们可以使用 Java 安全管理器和 Java 安全策略文件。它们允许我们向类授予权限。

当使用 Java 9 以后的模块时，我们应该知道，默认情况下，我们不能对从另一个模块导入的类使用反射。为了允许其他类使用反射来访问包的私有成员，我们必须授予“反射”权限。

[这篇文章](/web/20220626110738/https://www.baeldung.com/java-reflection)深入探讨了 Java 反射。

### Q5。什么是**一个**类加载器？

`classloader`是 Java 中最重要的组件之一。这是 JRE 的一部分。

简单地说，` classloader`负责将类加载到 JVM 中。我们可以区分三种类型的类装入器:

*   **Bootstrap class loader—**它加载核心 Java 类。它们位于`<JAVA_HOME>/jre/lib`目录中
*   **扩展类加载器—**它加载位于`<JAVA_HOME>/jre/lib/ext`或由`java.ext.dirs`属性定义的路径中的类
*   **系统类加载器—**它将类加载到应用程序的类路径中

类加载器“按需”加载类。这意味着类在被程序调用后被加载。此外，一个类装入器只能装入一个给定名称的类一次。但是，如果同一个类由两个不同的类装入器装入，那么这些类在相等性检查中就会失败。

Java 中的[类加载器一文中有更多关于类加载器的信息。](/web/20220626110738/https://www.baeldung.com/java-classloaders)

### Q6。静态类加载和动态类加载有什么区别？

当我们在编译时有可用的源类时，静态类加载就发生了。我们可以通过用关键字`new`创建对象实例来利用它。

动态类加载指的是在编译时我们不能提供类定义的情况。然而，我们可以在运行时这样做。要创建一个类的实例，我们必须使用`Class.forName()`方法:

```
Class.forName("oracle.jdbc.driver.OracleDriver") 
```

### Q7。`Serializable`接口的用途是什么？

**我们可以使用`Serializable`接口来启用类的可序列化性，使用 Java 的序列化 API。**序列化是一种将对象状态保存为字节序列的机制，而反序列化是一种从字节序列恢复对象状态的机制。序列化的输出包含对象的状态和一些关于对象类型及其字段类型的元数据。

我们应该知道可序列化类的子类型也是可序列化的。然而，如果我们想使一个类可序列化，但它的超类型是不可序列化的，我们必须做两件事:

*   实现`Serializable`接口
*   确保超类中存在无参数构造函数

我们可以在我们的文章的[中读到更多关于序列化的内容。](/web/20220626110738/https://www.baeldung.com/java-serialization)

### Q8。Java 里有析构函数吗？

在 Java 中，垃圾收集器自动删除不用的对象来释放内存。开发人员不需要将对象标记为删除，这很容易出错。所以明智的 Java 没有可用的析构函数。

在对象持有打开的套接字、打开的文件或数据库连接的情况下，**垃圾收集器不能回收那些资源**。我们可以释放`close `方法中的资源，然后在 Java 7 之前使用`try-finally `语法调用该方法，比如 I/O 类`FileInputStream`和`FileOutputStream`。**从 Java 7 开始，我们可以实现接口`AutoCloseable `，使用 [`try-with-resources `语句](/web/20220626110738/https://www.baeldung.com/java-try-with-resources)编写更短更干净的代码**。但是 API 用户可能忘记调用`close `方法，所以`finalize `方法和`Cleaner `类作为安全网出现了。但是请注意，它们并不等同于析构函数。

**不能保证`the finalize `方法和`Cleaner `类都能迅速运行。在 JVM 退出之前，它们甚至没有机会运行。尽管我们可以调用`System.runFinalization `来建议 JVM 运行任何等待终结的对象的`finalize `方法，但这仍然是不确定的。**

此外，`finalize`方法会导致性能问题、死锁等。我们可以通过查看我们的一篇文章找到更多信息:[Java 中 finalize 方法的指南](/web/20220626110738/https://www.baeldung.com/java-finalize)。

**从 Java 9** 开始，添加了 **`Cleaner `类来代替`finalize` 方法**，因为它有缺点。因此，我们可以更好地控制执行清理操作的线程。

但是 java 规范指出，清理器在`System.exit `期间的行为是特定于实现的，Java 不保证清理动作是否会被调用。