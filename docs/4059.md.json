["```\r\njavax.validation.UnexpectedTypeException: HV000030: No validator could be found for constraint \r\n 'javax.validation.constraints.Pattern' validating type 'com.baeldung.javaxval.enums.demo.CustomerType'. \r\n Check configuration for 'customerTypeMatchesPattern' \r\n```","```\r\n@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})\r\n@Retention(RUNTIME)\r\n@Documented\r\n@Constraint(validatedBy = EnumNamePatternValidator.class)\r\npublic @interface EnumNamePattern {\r\n    String regexp();\r\n    String message() default \"must match \\\"{regexp}\\\"\";\r\n    Class<?>[] groups() default {};\r\n    Class<? extends Payload>[] payload() default {};\r\n}\r\n```","```\r\n@EnumNamePattern(regexp = \"NEW|DEFAULT\")\r\nprivate CustomerType customerType;\r\n```","```\r\npublic class EnumNamePatternValidator implements ConstraintValidator<EnumNamePattern, Enum<?>> {\r\n    private Pattern pattern;\r\n\r\n    @Override\r\n    public void initialize(EnumNamePattern annotation) {\r\n        try {\r\n            pattern = Pattern.compile(annotation.regexp());\r\n        } catch (PatternSyntaxException e) {\r\n            throw new IllegalArgumentException(\"Given regex is invalid\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean isValid(Enum<?> value, ConstraintValidatorContext context) {\r\n        if (value == null) {\r\n            return true;\r\n        }\r\n\r\n        Matcher m = pattern.matcher(value.name());\r\n        return m.matches();\r\n    }\r\n}\r\n```","```\r\n@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})\r\n@Retention(RUNTIME)\r\n@Documented\r\n@Constraint(validatedBy = CustomerTypeSubSetValidator.class)\r\npublic @interface CustomerTypeSubset {\r\n    CustomerType[] anyOf();\r\n    String message() default \"must be any of {anyOf}\";\r\n    Class<?>[] groups() default {};\r\n    Class<? extends Payload>[] payload() default {};\r\n}\r\n```","```\r\n@CustomerTypeSubset(anyOf = {CustomerType.NEW, CustomerType.OLD})\r\nprivate CustomerType customerType;\r\n```","```\r\npublic class CustomerTypeSubSetValidator implements ConstraintValidator<CustomerTypeSubset, CustomerType> {\r\n    private CustomerType[] subset;\r\n\r\n    @Override\r\n    public void initialize(CustomerTypeSubset constraint) {\r\n        this.subset = constraint.anyOf();\r\n    }\r\n\r\n    @Override\r\n    public boolean isValid(CustomerType value, ConstraintValidatorContext context) {\r\n        return value == null || Arrays.asList(subset).contains(value);\r\n    }\r\n}\r\n```","```\r\n@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})\r\n@Retention(RUNTIME)\r\n@Documented\r\n@Constraint(validatedBy = ValueOfEnumValidator.class)\r\npublic @interface ValueOfEnum {\r\n    Class<? extends Enum<?>> enumClass();\r\n    String message() default \"must be any of enum {enumClass}\";\r\n    Class<?>[] groups() default {};\r\n    Class<? extends Payload>[] payload() default {};\r\n}\r\n```","```\r\n@ValueOfEnum(enumClass = CustomerType.class)\r\nprivate String customerTypeString;\r\n```","```\r\npublic class ValueOfEnumValidator implements ConstraintValidator<ValueOfEnum, CharSequence> {\r\n    private List<String> acceptedValues;\r\n\r\n    @Override\r\n    public void initialize(ValueOfEnum annotation) {\r\n        acceptedValues = Stream.of(annotation.enumClass().getEnumConstants())\r\n                .map(Enum::name)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    @Override\r\n    public boolean isValid(CharSequence value, ConstraintValidatorContext context) {\r\n        if (value == null) {\r\n            return true;\r\n        }\r\n\r\n        return acceptedValues.contains(value.toString());\r\n    }\r\n}\r\n```","```\r\nCannot deserialize value of type CustomerType from String value 'UNDEFINED': value not one\r\n of declared Enum instance names: [...]\r\n```","```\r\npublic class Customer {\r\n    @ValueOfEnum(enumClass = CustomerType.class)\r\n    private String customerTypeString;\r\n\r\n    @NotNull\r\n    @CustomerTypeSubset(anyOf = {CustomerType.NEW, CustomerType.OLD})\r\n    private CustomerType customerTypeOfSubset;\r\n\r\n    @EnumNamePattern(regexp = \"NEW|DEFAULT\")\r\n    private CustomerType customerTypeMatchesPattern;\r\n\r\n    // constructor, getters etc.\r\n}\r\n```","```\r\n@Test \r\npublic void whenAllAcceptable_thenShouldNotGiveConstraintViolations() { \r\n    Customer customer = new Customer(); \r\n    customer.setCustomerTypeOfSubset(CustomerType.NEW); \r\n    Set violations = validator.validate(customer); \r\n    assertThat(violations).isEmpty(); \r\n}\r\n```","```\r\n@Test\r\npublic void whenAllNull_thenOnlyNotNullShouldGiveConstraintViolations() {\r\n    Customer customer = new Customer();\r\n    Set<ConstraintViolation> violations = validator.validate(customer);\r\n    assertThat(violations.size()).isEqualTo(1);\r\n\r\n    assertThat(violations)\r\n      .anyMatch(havingPropertyPath(\"customerTypeOfSubset\")\r\n      .and(havingMessage(\"must not be null\")));\r\n}\r\n```","```\r\n@Test\r\npublic void whenAllInvalid_thenViolationsShouldBeReported() {\r\n    Customer customer = new Customer();\r\n    customer.setCustomerTypeString(\"invalid\");\r\n    customer.setCustomerTypeOfSubset(CustomerType.DEFAULT);\r\n    customer.setCustomerTypeMatchesPattern(CustomerType.OLD);\r\n\r\n    Set<ConstraintViolation> violations = validator.validate(customer);\r\n    assertThat(violations.size()).isEqualTo(3);\r\n\r\n    assertThat(violations)\r\n      .anyMatch(havingPropertyPath(\"customerTypeString\")\r\n      .and(havingMessage(\"must be any of enum class com.baeldung.javaxval.enums.demo.CustomerType\")));\r\n    assertThat(violations)\r\n      .anyMatch(havingPropertyPath(\"customerTypeOfSubset\")\r\n      .and(havingMessage(\"must be any of [NEW, OLD]\")));\r\n    assertThat(violations)\r\n      .anyMatch(havingPropertyPath(\"customerTypeMatchesPattern\")\r\n      .and(havingMessage(\"must match \\\"NEW|DEFAULT\\\"\")));\r\n}\r\n```"]