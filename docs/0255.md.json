["```\r\n@EnableWebSecurity\r\n@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)\r\n@Configuration\r\npublic class SecurityConfig {\r\n    // security beans\r\n}\r\n```","```\r\n@Override\r\npublic int vote(Authentication authentication, Object object, Collection<ConfigAttribute> definition) {\r\n    boolean jsr250AttributeFound = false;\r\n    for (ConfigAttribute attribute : definition) {\r\n        if (Jsr250SecurityConfig.PERMIT_ALL_ATTRIBUTE.equals(attribute)) {\r\n            return ACCESS_GRANTED;\r\n        }\r\n        if (Jsr250SecurityConfig.DENY_ALL_ATTRIBUTE.equals(attribute)) {\r\n            return ACCESS_DENIED;\r\n        }\r\n        if (supports(attribute)) {\r\n            jsr250AttributeFound = true;\r\n            // Attempt to find a matching granted authority\r\n            for (GrantedAuthority authority : authentication.getAuthorities()) {\r\n                if (attribute.getAttribute().equals(authority.getAuthority())) {\r\n                    return ACCESS_GRANTED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return jsr250AttributeFound ? ACCESS_DENIED : ACCESS_ABSTAIN;\r\n}\r\n```","```\r\nfor (AccessDecisionVoter voter : getDecisionVoters()) {\r\n    int result = voter.vote(authentication, object, configAttributes);\r\n    switch (result) {\r\n        case AccessDecisionVoter.ACCESS_GRANTED:\r\n            return;\r\n        case AccessDecisionVoter.ACCESS_DENIED:\r\n            deny++;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}\r\nif (deny > 0) {\r\n    throw new AccessDeniedException(this.messages.getMessage(\"AbstractAccessDecisionManager.accessDenied\", \"Access is denied\"));\r\n}\r\n```","```\r\n@Configuration(proxyBeanMethods = false)\r\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\r\nclass Jsr250MethodSecurityConfiguration {\r\n    // ...\r\n    @Bean\r\n    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)\r\n    Advisor jsr250AuthorizationMethodInterceptor() {\r\n        return AuthorizationManagerBeforeMethodInterceptor.jsr250(this.jsr250AuthorizationManager);\r\n    }\r\n\r\n    @Autowired(required = false)\r\n    void setGrantedAuthorityDefaults(GrantedAuthorityDefaults grantedAuthorityDefaults) {\r\n        this.jsr250AuthorizationManager.setRolePrefix(grantedAuthorityDefaults.getRolePrefix());\r\n    }\r\n}\r\n```","```\r\n@Override\r\npublic AuthorizationDecision check(Supplier<Authentication> authentication, T object) {\r\n    boolean granted = isGranted(authentication.get());\r\n    return new AuthorityAuthorizationDecision(granted, this.authorities);\r\n}\r\n\r\nprivate boolean isGranted(Authentication authentication) {\r\n    return authentication != null && authentication.isAuthenticated() && isAuthorized(authentication);\r\n}\r\n\r\nprivate boolean isAuthorized(Authentication authentication) {\r\n    Set<String> authorities = AuthorityUtils.authorityListToSet(this.authorities);\r\n    for (GrantedAuthority grantedAuthority : authentication.getAuthorities()) {\r\n        if (authorities.contains(grantedAuthority.getAuthority())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n} \r\n```","```\r\nAuthorizationDecision decision = this.authorizationManager.check(AUTHENTICATION_SUPPLIER, mi);\r\nif (decision != null && !decision.isGranted()) {\r\n    // ...\r\n    throw new AccessDeniedException(\"Access Denied\");\r\n}\r\n```","```\r\n@EnableMethodSecurity(securedEnabled = true, jsr250Enabled = true) \r\n```","```\r\nAuthorizationDecision check(Supplier<Authentication> authentication, T object); \r\n```","```\r\npublic final class AspectJMethodSecurityInterceptor extends MethodSecurityInterceptor {\r\n    public Object invoke(JoinPoint jp) throws Throwable {\r\n        return super.invoke(new MethodInvocationAdapter(jp));\r\n    }\r\n    // ...\r\n}\r\n```","```\r\npublic final class AuthorizationManagerBeforeMethodInterceptor\r\n  implements Ordered, MethodInterceptor, PointcutAdvisor, AopInfrastructureBean {\r\n    // ...\r\n    public AuthorizationManagerBeforeMethodInterceptor(\r\n      Pointcut pointcut, AuthorizationManager<MethodInvocation> authorizationManager) {\r\n        Assert.notNull(pointcut, \"pointcut cannot be null\");\r\n        Assert.notNull(authorizationManager, \"authorizationManager cannot be null\");\r\n        this.pointcut = pointcut;\r\n        this.authorizationManager = authorizationManager;\r\n    }\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation mi) throws Throwable {\r\n        attemptAuthorization(mi);\r\n        return mi.proceed();\r\n    }\r\n}\r\n```","```\r\npublic class SecurityUser implements UserDetails {\r\n    private String userName;\r\n    private String password;\r\n    private List<GrantedAuthority> grantedAuthorityList;\r\n    private boolean accessToRestrictedPolicy;\r\n\r\n    // getters and setters\r\n}\r\n```","```\r\npublic class CustomUserDetailService implements UserDetailsService {\r\n    private final Map<String, SecurityUser> userMap = new HashMap<>();\r\n\r\n    public CustomUserDetailService(BCryptPasswordEncoder bCryptPasswordEncoder) {\r\n        userMap.put(\"user\", createUser(\"user\", bCryptPasswordEncoder.encode(\"userPass\"), false, \"USER\"));\r\n        userMap.put(\"admin\", createUser(\"admin\", bCryptPasswordEncoder.encode(\"adminPass\"), true, \"ADMIN\", \"USER\"));\r\n    }\r\n\r\n    @Override\r\n    public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException {\r\n        return Optional.ofNullable(map.get(username))\r\n          .orElseThrow(() -> new UsernameNotFoundException(\"User \" + username + \" does not exists\"));\r\n    }\r\n\r\n    private SecurityUser createUser(String userName, String password, boolean withRestrictedPolicy, String... role) {\r\n        return SecurityUser.builder().withUserName(userName)\r\n          .withPassword(password)\r\n          .withGrantedAuthorityList(Arrays.stream(role)\r\n            .map(SimpleGrantedAuthority::new)\r\n            .collect(Collectors.toList()))\r\n          .withAccessToRestrictedPolicy(withRestrictedPolicy);\r\n    }\r\n}\r\n```","```\r\n@Target(METHOD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface Policy {\r\n    PolicyEnum value();\r\n}\r\n```","```\r\npublic enum PolicyEnum {\r\n    RESTRICTED, OPEN\r\n}\r\n```","```\r\n@Service\r\npublic class PolicyService {\r\n    @Policy(PolicyEnum.OPEN)\r\n    public String openPolicy() {\r\n        return \"Open Policy Service\";\r\n    }\r\n\r\n    @Policy(PolicyEnum.RESTRICTED)\r\n    public String restrictedPolicy() {\r\n        return \"Restricted Policy Service\";\r\n    }\r\n}\r\n```","```\r\npublic class CustomAuthorizationManager<T> implements AuthorizationManager<MethodInvocation> {\r\n    ...\r\n    @Override\r\n    public AuthorizationDecision check(Supplier<Authentication> authentication, MethodInvocation methodInvocation) {\r\n        if (hasAuthentication(authentication.get())) {\r\n            Policy policyAnnotation = AnnotationUtils.findAnnotation(methodInvocation.getMethod(), Policy.class);\r\n            SecurityUser user = (SecurityUser) authentication.get().getPrincipal();\r\n            return new AuthorizationDecision(Optional.ofNullable(policyAnnotation)\r\n              .map(Policy::value).filter(policy -> policy == PolicyEnum.OPEN \r\n                || (policy == PolicyEnum.RESTRICTED && user.hasAccessToRestrictedPolicy())).isPresent());\r\n        }\r\n        return new AuthorizationDecision(false);\r\n    }\r\n\r\n    private boolean hasAuthentication(Authentication authentication) {\r\n        return authentication != null && isNotAnonymous(authentication) && authentication.isAuthenticated();\r\n    }\r\n\r\n    private boolean isNotAnonymous(Authentication authentication) {\r\n        return !this.trustResolver.isAnonymous(authentication);\r\n    }\r\n}\r\n```","```\r\n@EnableWebSecurity\r\n@EnableMethodSecurity\r\n@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(\r\n      HttpSecurity httpSecurity, UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder) throws Exception {\r\n        AuthenticationManagerBuilder authenticationManagerBuilder = httpSecurity.getSharedObject(AuthenticationManagerBuilder.class);\r\n        authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder);\r\n        return authenticationManagerBuilder.build();\r\n    }\r\n\r\n    @Bean\r\n    public UserDetailsService userDetailsService(BCryptPasswordEncoder bCryptPasswordEncoder) {\r\n        return new CustomUserDetailService(bCryptPasswordEncoder);\r\n    }\r\n\r\n    @Bean\r\n    public AuthorizationManager<MethodInvocation> authorizationManager() {\r\n        return new CustomAuthorizationManager<>();\r\n    }\r\n\r\n    @Bean\r\n    @Role(ROLE_INFRASTRUCTURE)\r\n    public Advisor authorizationManagerBeforeMethodInterception(AuthorizationManager<MethodInvocation> authorizationManager) {\r\n        JdkRegexpMethodPointcut pattern = new JdkRegexpMethodPointcut();\r\n        pattern.setPattern(\"com.baeldung.enablemethodsecurity.services.*\");\r\n        return new AuthorizationManagerBeforeMethodInterceptor(pattern, authorizationManager);\r\n    }\r\n\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf()\r\n          .disable()\r\n          .authorizeRequests()\r\n          .anyRequest()\r\n          .authenticated()\r\n          .and()\r\n          .sessionManagement()\r\n          .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\r\n\r\n        return http.build();\r\n    }\r\n\r\n    @Bean\r\n    public BCryptPasswordEncoder bCryptPasswordEncoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n}\r\n```","```\r\n@RestController\r\npublic class ResourceController {\r\n    // ...\r\n    @GetMapping(\"/openPolicy\")\r\n    public String openPolicy() {\r\n        return policyService.openPolicy();\r\n    }\r\n\r\n    @GetMapping(\"/restrictedPolicy\")\r\n    public String restrictedPolicy() {\r\n        return policyService.restrictedPolicy();\r\n    }\r\n}\r\n```","```\r\n@SpringBootTest(classes = EnableMethodSecurityApplication.class)\r\npublic class EnableMethodSecurityTest {\r\n    @Autowired\r\n    private WebApplicationContext context;\r\n\r\n    private MockMvc mvc;\r\n\r\n    @BeforeEach\r\n    public void setup() {\r\n        mvc = MockMvcBuilders.webAppContextSetup(context)\r\n          .apply(springSecurity())\r\n          .build();\r\n    }\r\n\r\n    @Test\r\n    @WithUserDetails(value = \"admin\")\r\n    public void whenAdminAccessOpenEndpoint_thenOk() throws Exception {\r\n        mvc.perform(get(\"/openPolicy\"))\r\n          .andExpect(status().isOk());\r\n    }\r\n\r\n    @Test\r\n    @WithUserDetails(value = \"admin\")\r\n    public void whenAdminAccessRestrictedEndpoint_thenOk() throws Exception {\r\n        mvc.perform(get(\"/restrictedPolicy\"))\r\n          .andExpect(status().isOk());\r\n    }\r\n\r\n    @Test\r\n    @WithUserDetails()\r\n    public void whenUserAccessOpenEndpoint_thenOk() throws Exception {\r\n        mvc.perform(get(\"/openPolicy\"))\r\n          .andExpect(status().isOk());\r\n    }\r\n\r\n    @Test\r\n    @WithUserDetails()\r\n    public void whenUserAccessRestrictedEndpoint_thenIsForbidden() throws Exception {\r\n        mvc.perform(get(\"/restrictedPolicy\"))\r\n          .andExpect(status().isForbidden());\r\n    }\r\n}\r\n```"]