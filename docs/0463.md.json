["```\r\npublic class Record {\r\n    private final String description;\r\n    private final Map<String, Double> features;\r\n\r\n    // constructor, getter, toString, equals and hashcode\r\n}\r\n```","```\r\npublic interface Distance {\r\n    double calculate(Map<String, Double> f1, Map<String, Double> f2);\r\n}\r\n```","```\r\npublic class EuclideanDistance implements Distance {\r\n\r\n    @Override\r\n    public double calculate(Map<String, Double> f1, Map<String, Double> f2) {\r\n        double sum = 0;\r\n        for (String key : f1.keySet()) {\r\n            Double v1 = f1.get(key);\r\n            Double v2 = f2.get(key);\r\n\r\n            if (v1 != null && v2 != null) {\r\n                sum += Math.pow(v1 - v2, 2);\r\n            }\r\n        }\r\n\r\n        return Math.sqrt(sum);\r\n    }\r\n}\r\n```","```\r\npublic class Centroid {\r\n\r\n    private final Map<String, Double> coordinates;\r\n\r\n    // constructors, getter, toString, equals and hashcode\r\n}\r\n```","```\r\npublic class KMeans {\r\n\r\n    private static final Random random = new Random();\r\n\r\n    public static Map<Centroid, List<Record>> fit(List<Record> records, \r\n      int k, \r\n      Distance distance, \r\n      int maxIterations) { \r\n        // omitted\r\n    }\r\n}\r\n```","```\r\nprivate static List<Centroid> randomCentroids(List<Record> records, int k) {\r\n    List<Centroid> centroids = new ArrayList<>();\r\n    Map<String, Double> maxs = new HashMap<>();\r\n    Map<String, Double> mins = new HashMap<>();\r\n\r\n    for (Record record : records) {\r\n        record.getFeatures().forEach((key, value) -> {\r\n            // compares the value with the current max and choose the bigger value between them\r\n            maxs.compute(key, (k1, max) -> max == null || value > max ? value : max);\r\n\r\n            // compare the value with the current min and choose the smaller value between them\r\n            mins.compute(key, (k1, min) -> min == null || value < min ? value : min);\r\n        });\r\n    }\r\n\r\n    Set<String> attributes = records.stream()\r\n      .flatMap(e -> e.getFeatures().keySet().stream())\r\n      .collect(toSet());\r\n    for (int i = 0; i < k; i++) {\r\n        Map<String, Double> coordinates = new HashMap<>();\r\n        for (String attribute : attributes) {\r\n            double max = maxs.get(attribute);\r\n            double min = mins.get(attribute);\r\n            coordinates.put(attribute, random.nextDouble() * (max - min) + min);\r\n        }\r\n\r\n        centroids.add(new Centroid(coordinates));\r\n    }\r\n\r\n    return centroids;\r\n}\r\n```","```\r\nprivate static Centroid nearestCentroid(Record record, List<Centroid> centroids, Distance distance) {\r\n    double minimumDistance = Double.MAX_VALUE;\r\n    Centroid nearest = null;\r\n\r\n    for (Centroid centroid : centroids) {\r\n        double currentDistance = distance.calculate(record.getFeatures(), centroid.getCoordinates());\r\n\r\n        if (currentDistance < minimumDistance) {\r\n            minimumDistance = currentDistance;\r\n            nearest = centroid;\r\n        }\r\n    }\r\n\r\n    return nearest;\r\n}\r\n```","```\r\nprivate static void assignToCluster(Map<Centroid, List<Record>> clusters,  \r\n  Record record, \r\n  Centroid centroid) {\r\n    clusters.compute(centroid, (key, list) -> {\r\n        if (list == null) {\r\n            list = new ArrayList<>();\r\n        }\r\n\r\n        list.add(record);\r\n        return list;\r\n    });\r\n}\r\n```","```\r\nprivate static Centroid average(Centroid centroid, List<Record> records) {\r\n    if (records == null || records.isEmpty()) { \r\n        return centroid;\r\n    }\r\n\r\n    Map<String, Double> average = centroid.getCoordinates();\r\n    records.stream().flatMap(e -> e.getFeatures().keySet().stream())\r\n      .forEach(k -> average.put(k, 0.0));\r\n\r\n    for (Record record : records) {\r\n        record.getFeatures().forEach(\r\n          (k, v) -> average.compute(k, (k1, currentValue) -> v + currentValue)\r\n        );\r\n    }\r\n\r\n    average.forEach((k, v) -> average.put(k, v / records.size()));\r\n\r\n    return new Centroid(average);\r\n}\r\n```","```\r\nprivate static List<Centroid> relocateCentroids(Map<Centroid, List<Record>> clusters) {\r\n    return clusters.entrySet().stream().map(e -> average(e.getKey(), e.getValue())).collect(toList());\r\n}\r\n```","```\r\npublic static Map<Centroid, List<Record>> fit(List<Record> records, \r\n  int k, \r\n  Distance distance, \r\n  int maxIterations) {\r\n\r\n    List<Centroid> centroids = randomCentroids(records, k);\r\n    Map<Centroid, List<Record>> clusters = new HashMap<>();\r\n    Map<Centroid, List<Record>> lastState = new HashMap<>();\r\n\r\n    // iterate for a pre-defined number of times\r\n    for (int i = 0; i < maxIterations; i++) {\r\n        boolean isLastIteration = i == maxIterations - 1;\r\n\r\n        // in each iteration we should find the nearest centroid for each record\r\n        for (Record record : records) {\r\n            Centroid centroid = nearestCentroid(record, centroids, distance);\r\n            assignToCluster(clusters, record, centroid);\r\n        }\r\n\r\n        // if the assignments do not change, then the algorithm terminates\r\n        boolean shouldTerminate = isLastIteration || clusters.equals(lastState);\r\n        lastState = clusters;\r\n        if (shouldTerminate) { \r\n            break; \r\n        }\r\n\r\n        // at the end of each iteration we should relocate the centroids\r\n        centroids = relocateCentroids(clusters);\r\n        clusters = new HashMap<>();\r\n    }\r\n\r\n    return lastState;\r\n}\r\n```","```\r\npublic interface LastFmService {\r\n\r\n    @GET(\"/2.0/?method=chart.gettopartists&format;=json&limit;=50\")\r\n    Call<Artists> topArtists(@Query(\"page\") int page);\r\n\r\n    @GET(\"/2.0/?method=artist.gettoptags&format;=json&limit;=20&autocorrect;=1\")\r\n    Call<Tags> topTagsFor(@Query(\"artist\") String artist);\r\n\r\n    @GET(\"/2.0/?method=chart.gettoptags&format;=json&limit;=100\")\r\n    Call<TopTags> topTags();\r\n\r\n    // A few DTOs and one interceptor\r\n}\r\n```","```\r\n// setting up the Retrofit service\r\n\r\nprivate static List<String> getTop100Artists() throws IOException {\r\n    List<String> artists = new ArrayList<>();\r\n    // Fetching the first two pages, each containing 50 records.\r\n    for (int i = 1; i <= 2; i++) {\r\n        artists.addAll(lastFm.topArtists(i).execute().body().all());\r\n    }\r\n\r\n    return artists;\r\n}\r\n```","```\r\nprivate static Set<String> getTop100Tags() throws IOException {\r\n    return lastFm.topTags().execute().body().all();\r\n}\r\n```","```\r\nprivate static List<Record> datasetWithTaggedArtists(List<String> artists, \r\n  Set<String> topTags) throws IOException {\r\n    List<Record> records = new ArrayList<>();\r\n    for (String artist : artists) {\r\n        Map<String, Double> tags = lastFm.topTagsFor(artist).execute().body().all();\r\n\r\n        // Only keep popular tags.\r\n        tags.entrySet().removeIf(e -> !topTags.contains(e.getKey()));\r\n\r\n        records.add(new Record(artist, tags));\r\n    }\r\n\r\n    return records;\r\n}\r\n```","```\r\nList<String> artists = getTop100Artists();\r\nSet<String> topTags = getTop100Tags();\r\nList<Record> records = datasetWithTaggedArtists(artists, topTags);\r\n\r\nMap<Centroid, List<Record>> clusters = KMeans.fit(records, 7, new EuclideanDistance(), 1000);\r\n// Printing the cluster configuration\r\nclusters.forEach((key, value) -> {\r\n    System.out.println(\"-------------------------- CLUSTER ----------------------------\");\r\n\r\n    // Sorting the coordinates to see the most significant tags first.\r\n    System.out.println(sortedCentroid(key)); \r\n    String members = String.join(\", \", value.stream().map(Record::getDescription).collect(toSet()));\r\n    System.out.print(members);\r\n\r\n    System.out.println();\r\n    System.out.println();\r\n});\r\n```","```\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {classic rock=65.58333333333333, rock=64.41666666666667, british=20.333333333333332, ... }\r\nDavid Bowie, Led Zeppelin, Pink Floyd, System of a Down, Queen, blink-182, The Rolling Stones, Metallica, \r\nFleetwood Mac, The Beatles, Elton John, The Clash\r\n\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {Hip-Hop=97.21428571428571, rap=64.85714285714286, hip hop=29.285714285714285, ... }\r\nKanye West, Post Malone, Childish Gambino, Lil Nas X, A$AP Rocky, Lizzo, xxxtentacion, \r\nTravi$ Scott, Tyler, the Creator, Eminem, Frank Ocean, Kendrick Lamar, Nicki Minaj, Drake\r\n\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {indie rock=54.0, rock=52.0, Psychedelic Rock=51.0, psychedelic=47.0, ... }\r\nTame Impala, The Black Keys\r\n\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {pop=81.96428571428571, female vocalists=41.285714285714285, indie=22.785714285714285, ... }\r\nEd Sheeran, Taylor Swift, Rihanna, Miley Cyrus, Billie Eilish, Lorde, Ellie Goulding, Bruno Mars, \r\nKaty Perry, Khalid, Ariana Grande, Bon Iver, Dua Lipa, Beyonc√©, Sia, P!nk, Sam Smith, Shawn Mendes, \r\nMark Ronson, Michael Jackson, Halsey, Lana Del Rey, Carly Rae Jepsen, Britney Spears, Madonna, \r\nAdele, Lady Gaga, Jonas Brothers\r\n\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {indie=95.23076923076923, alternative=70.61538461538461, indie rock=64.46153846153847, ... }\r\nTwenty One Pilots, The Smiths, Florence + the Machine, Two Door Cinema Club, The 1975, Imagine Dragons, \r\nThe Killers, Vampire Weekend, Foster the People, The Strokes, Cage the Elephant, Arcade Fire, \r\nArctic Monkeys\r\n\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {electronic=91.6923076923077, House=39.46153846153846, dance=38.0, ... }\r\nCharli XCX, The Weeknd, Daft Punk, Calvin Harris, MGMT, Martin Garrix, Depeche Mode, The Chainsmokers, \r\nAvicii, Kygo, Marshmello, David Guetta, Major Lazer\r\n\r\n------------------------------ CLUSTER -----------------------------------\r\nCentroid {rock=87.38888888888889, alternative=72.11111111111111, alternative rock=49.16666666, ... }\r\nWeezer, The White Stripes, Nirvana, Foo Fighters, Maroon 5, Oasis, Panic! at the Disco, Gorillaz, \r\nGreen Day, The Cure, Fall Out Boy, OneRepublic, Paramore, Coldplay, Radiohead, Linkin Park, \r\nRed Hot Chili Peppers, Muse\r\n```","```\r\npublic static double sse(Map<Centroid, List<Record>> clustered, Distance distance) {\r\n    double sum = 0;\r\n    for (Map.Entry<Centroid, List<Record>> entry : clustered.entrySet()) {\r\n        Centroid centroid = entry.getKey();\r\n        for (Record record : entry.getValue()) {\r\n            double d = distance.calculate(centroid.getCoordinates(), record.getFeatures());\r\n            sum += Math.pow(d, 2);\r\n        }\r\n    }\r\n\r\n    return sum;\r\n}\r\n```","```\r\nList<Record> records = // the dataset;\r\nDistance distance = new EuclideanDistance();\r\nList<Double> sumOfSquaredErrors = new ArrayList<>();\r\nfor (int k = 2; k <= 16; k++) {\r\n    Map<Centroid, List<Record>> clusters = KMeans.fit(records, k, distance, 1000);\r\n    double sse = Errors.sse(clusters, distance);\r\n    sumOfSquaredErrors.add(sse);\r\n}\r\n```"]