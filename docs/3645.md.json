["```\r\n<dependency>\r\n    <groupId>io.mantisrx</groupId>\r\n    <artifactId>mantis-runtime</artifactId>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n</dependency>\r\n```","```\r\npublic class RandomLogSource implements Source<String> {\r\n\r\n    @Override\r\n    public Observable<Observable<String>> call(Context context, Index index) {\r\n        return Observable.just(\r\n          Observable\r\n            .interval(250, TimeUnit.MILLISECONDS)\r\n            .map(this::createRandomLogEvent));\r\n    }\r\n\r\n    private String createRandomLogEvent(Long tick) {\r\n        // generate a random log entry string\r\n        ...\r\n    }\r\n\r\n}\r\n```","```\r\npublic class LogEvent implements JsonType {\r\n    private Long index;\r\n    private String level;\r\n    private String message;\r\n\r\n    // ...\r\n}\r\n```","```\r\npublic class TransformLogStage implements ScalarComputation<String, LogEvent> {\r\n\r\n    @Override\r\n    public Observable<LogEvent> call(Context context, Observable<String> logEntry) {\r\n        return logEntry\r\n          .map(log -> log.split(\"#\"))\r\n          .filter(parts -> parts.length == 3)\r\n          .map(LogEvent::new);\r\n    }\r\n\r\n}\r\n```","```\r\npublic class LogCollectingJob extends MantisJobProvider<LogEvent> {\r\n\r\n    @Override\r\n    public Job<LogEvent> getJobInstance() {\r\n        return MantisJob\r\n          .source(new RandomLogSource())\r\n          .stage(new TransformLogStage(), new ScalarToScalar.Config<>())\r\n          .sink(Sinks.eagerSubscribe(Sinks.sse(LogEvent::toJsonString)))\r\n          .metadata(new Metadata.Builder().build())\r\n          .create();\r\n    }\r\n\r\n}\r\n```","```\r\n@SpringBootApplication\r\npublic class MantisApplication implements CommandLineRunner {\r\n\r\n    // ...\r\n\r\n    @Override\r\n    public void run(String... args) {\r\n        LocalJobExecutorNetworked.execute(new LogCollectingJob().getJobInstance());\r\n    }\r\n}\r\n```","```\r\n...\r\nServing modern HTTP SSE server sink on port: 86XX\r\n```","```\r\n$ curl localhost:86XX\r\ndata: {\"index\":86,\"level\":\"WARN\",\"message\":\"login attempt\"}\r\ndata: {\"index\":87,\"level\":\"ERROR\",\"message\":\"user created\"}\r\ndata: {\"index\":88,\"level\":\"INFO\",\"message\":\"user created\"}\r\ndata: {\"index\":89,\"level\":\"INFO\",\"message\":\"login attempt\"}\r\ndata: {\"index\":90,\"level\":\"INFO\",\"message\":\"user created\"}\r\ndata: {\"index\":91,\"level\":\"ERROR\",\"message\":\"user created\"}\r\ndata: {\"index\":92,\"level\":\"WARN\",\"message\":\"login attempt\"}\r\ndata: {\"index\":93,\"level\":\"INFO\",\"message\":\"user created\"}\r\n...\r\n```","```\r\npublic class LogSink implements Sink<LogEvent> {\r\n    @Override\r\n    public void call(Context context, PortRequest portRequest, Observable<LogEvent> logEventObservable) {\r\n        SelfDocumentingSink<LogEvent> sink = new ServerSentEventsSink.Builder<LogEvent>()\r\n          .withEncoder(LogEvent::toJsonString)\r\n          .withPredicate(filterByLogMessage())\r\n          .build();\r\n        logEventObservable.subscribe();\r\n        sink.call(context, portRequest, logEventObservable);\r\n    }\r\n    private Predicate<LogEvent> filterByLogMessage() {\r\n        return new Predicate<>(\"filter by message\",\r\n          parameters -> {\r\n            if (parameters != null && parameters.containsKey(\"filter\")) {\r\n                return logEvent -> logEvent.getMessage().contains(parameters.get(\"filter\").get(0));\r\n            }\r\n            return logEvent -> true;\r\n        });\r\n    }\r\n}\r\n```","```\r\n$ curl localhost:8874?filter=login\r\ndata: {\"index\":93,\"level\":\"ERROR\",\"message\":\"login attempt\"}\r\ndata: {\"index\":95,\"level\":\"INFO\",\"message\":\"login attempt\"}\r\ndata: {\"index\":97,\"level\":\"ERROR\",\"message\":\"login attempt\"}\r\n...\r\n```","```\r\npublic class GroupLogStage implements ToGroupComputation<LogEvent, String, LogEvent> {\r\n\r\n    @Override\r\n    public Observable<MantisGroup<String, LogEvent>> call(Context context, Observable<LogEvent> logEvent) {\r\n        return logEvent.map(log -> new MantisGroup<>(log.getLevel(), log));\r\n    }\r\n\r\n    public static ScalarToGroup.Config<LogEvent, String, LogEvent> config(){\r\n        return new ScalarToGroup.Config<LogEvent, String, LogEvent>()\r\n          .description(\"Group event data by level\")\r\n          .codec(JacksonCodecs.pojo(LogEvent.class))\r\n          .concurrentInput();\r\n    }\r\n\r\n}\r\n```","```\r\npublic class LogAggregate implements JsonType {\r\n\r\n    private final Integer count;\r\n    private final String level;\r\n\r\n}\r\n```","```\r\npublic class CountLogStage implements GroupToScalarComputation<String, LogEvent, LogAggregate> {\r\n\r\n    private int duration;\r\n\r\n    @Override\r\n    public void init(Context context) {\r\n        duration = (int)context.getParameters().get(\"LogAggregationDuration\", 1000);\r\n    }\r\n\r\n    @Override\r\n    public Observable<LogAggregate> call(Context context, Observable<MantisGroup<String, LogEvent>> mantisGroup) {\r\n        return mantisGroup\r\n          .window(duration, TimeUnit.MILLISECONDS)\r\n          .flatMap(o -> o.groupBy(MantisGroup::getKeyValue)\r\n            .flatMap(group -> group.reduce(0, (count, value) ->  count = count + 1)\r\n              .map((count) -> new LogAggregate(count, group.getKey()))\r\n            ));\r\n    }\r\n\r\n    public static GroupToScalar.Config<String, LogEvent, LogAggregate> config(){\r\n        return new GroupToScalar.Config<String, LogEvent, LogAggregate>()\r\n          .description(\"sum events for a log level\")\r\n          .codec(JacksonCodecs.pojo(LogAggregate.class))\r\n          .withParameters(getParameters());\r\n    }\r\n\r\n    public static List<ParameterDefinition<?>> getParameters() {\r\n        List<ParameterDefinition<?>> params = new ArrayList<>();\r\n\r\n        params.add(new IntParameter()\r\n          .name(\"LogAggregationDuration\")\r\n          .description(\"window size for aggregation in milliseconds\")\r\n          .validator(Validators.range(100, 10000))\r\n          .defaultValue(5000)\r\n          .build());\r\n\r\n        return params;\r\n    }\r\n\r\n}\r\n```","```\r\npublic class LogAggregationJob extends MantisJobProvider<LogAggregate> {\r\n\r\n    @Override\r\n    public Job<LogAggregate> getJobInstance() {\r\n\r\n        return MantisJob\r\n          .source(new RandomLogSource())\r\n          .stage(new TransformLogStage(), TransformLogStage.stageConfig())\r\n          .stage(new GroupLogStage(), GroupLogStage.config())\r\n          .stage(new CountLogStage(), CountLogStage.config())\r\n          .sink(Sinks.eagerSubscribe(Sinks.sse(LogAggregate::toJsonString)))\r\n          .metadata(new Metadata.Builder().build())\r\n          .create();\r\n    }\r\n}\r\n```","```\r\n$ curl localhost:8133\r\ndata: {\"count\":3,\"level\":\"ERROR\"}\r\ndata: {\"count\":13,\"level\":\"INFO\"}\r\ndata: {\"count\":4,\"level\":\"WARN\"}\r\n\r\ndata: {\"count\":8,\"level\":\"ERROR\"}\r\ndata: {\"count\":5,\"level\":\"INFO\"}\r\ndata: {\"count\":7,\"level\":\"WARN\"}\r\n...\r\n```"]