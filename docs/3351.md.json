["```\r\n<dependency>\r\n    <groupId>com.sun</groupId>\r\n    <artifactId>tools</artifactId>\r\n    <version>1.8.0</version>\r\n    <scope>system</scope>\r\n    <systemPath>${java.home}/../lib/tools.jar</systemPath>\r\n</dependency>\r\n```","```\r\npublic class SampleJavacPlugin implements Plugin {\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"MyPlugin\";\r\n    }\r\n\r\n    @Override\r\n    public void init(JavacTask task, String... args) {\r\n        Context context = ((BasicJavacTask) task).getContext();\r\n        Log.instance(context)\r\n          .printRawLines(Log.WriterKind.NOTICE, \"Hello from \" + getName());\r\n    }\r\n}\r\n```","```\r\nbaeldung/tutorials$ javac -cp ./core-java/target/classes -Xplugin:MyPlugin ./core-java/src/main/java/com/baeldung/javac/TestClass.java\r\nHello from MyPlugin\r\n```","```\r\npublic void init(JavacTask task, String... args) {\r\n    task.addTaskListener(new TaskListener() {\r\n        public void started(TaskEvent e) {\r\n        }\r\n\r\n        public void finished(TaskEvent e) {\r\n            if (e.getKind() != TaskEvent.Kind.PARSE) {\r\n                return;\r\n            }\r\n            // Perform instrumentation\r\n        }\r\n    });\r\n}\r\n```","```\r\npublic void finished(TaskEvent e) {\r\n    if (e.getKind() != TaskEvent.Kind.PARSE) {\r\n        return;\r\n    }\r\n    e.getCompilationUnit().accept(new TreeScanner<Void, Void>() {\r\n        @Override\r\n        public Void visitClass(ClassTree node, Void aVoid) {\r\n            return super.visitClass(node, aVoid);\r\n        }\r\n\r\n        @Override\r\n        public Void visitMethod(MethodTree node, Void aVoid) {\r\n            return super.visitMethod(node, aVoid);\r\n        }\r\n    }, null);\r\n}\r\n```","```\r\n@Documented\r\n@Retention(RetentionPolicy.CLASS)\r\n@Target({ElementType.PARAMETER})\r\npublic @interface Positive { }\r\n```","```\r\npublic void service(@Positive int i) { }\r\n```","```\r\npublic void service(@Positive int i) {\r\n    if (i <= 0) {\r\n        throw new IllegalArgumentException(\"A non-positive argument (\"\r\n          + i + \") is given as a @Positive parameter 'i'\");\r\n    }\r\n}\r\n```","```\r\nprivate static Set<String> TARGET_TYPES = Stream.of(\r\n  byte.class, short.class, char.class, \r\n  int.class, long.class, float.class, double.class)\r\n .map(Class::getName)\r\n .collect(Collectors.toSet()); \r\n```","```\r\nprivate boolean shouldInstrument(VariableTree parameter) {\r\n    return TARGET_TYPES.contains(parameter.getType().toString())\r\n      && parameter.getModifiers().getAnnotations().stream()\r\n      .anyMatch(a -> Positive.class.getSimpleName()\r\n        .equals(a.getAnnotationType().toString()));\r\n}\r\n```","```\r\npublic void finished(TaskEvent e) {\r\n    if (e.getKind() != TaskEvent.Kind.PARSE) {\r\n        return;\r\n    }\r\n    e.getCompilationUnit().accept(new TreeScanner<Void, Void>() {\r\n        @Override\r\n        public Void visitMethod(MethodTree method, Void v) {\r\n            List<VariableTree> parametersToInstrument\r\n              = method.getParameters().stream()\r\n              .filter(SampleJavacPlugin.this::shouldInstrument)\r\n              .collect(Collectors.toList());\r\n\r\n              if (!parametersToInstrument.isEmpty()) {\r\n                Collections.reverse(parametersToInstrument);\r\n                parametersToInstrument.forEach(p -> addCheck(method, p, context));\r\n            }\r\n            return super.visitMethod(method, v);\r\n        }\r\n    }, null); \r\n```","```\r\n@Override\r\npublic void init(JavacTask task, String... args) {\r\n    Context context = ((BasicJavacTask) task).getContext();\r\n    // ...\r\n}\r\n```","```\r\nprivate static JCTree.JCIf createCheck(VariableTree parameter, Context context) {\r\n    TreeMaker factory = TreeMaker.instance(context);\r\n    Names symbolsTable = Names.instance(context);\r\n\r\n    return factory.at(((JCTree) parameter).pos)\r\n      .If(factory.Parens(createIfCondition(factory, symbolsTable, parameter)),\r\n        createIfBlock(factory, symbolsTable, parameter), \r\n        null);\r\n}\r\n```","```\r\nprivate static JCTree.JCBinary createIfCondition(TreeMaker factory, \r\n  Names symbolsTable, VariableTree parameter) {\r\n    Name parameterId = symbolsTable.fromString(parameter.getName().toString());\r\n    return factory.Binary(JCTree.Tag.LE, \r\n      factory.Ident(parameterId), \r\n      factory.Literal(TypeTag.INT, 0));\r\n}\r\n```","```\r\nprivate static JCTree.JCBlock createIfBlock(TreeMaker factory, \r\n  Names symbolsTable, VariableTree parameter) {\r\n    String parameterName = parameter.getName().toString();\r\n    Name parameterId = symbolsTable.fromString(parameterName);\r\n\r\n    String errorMessagePrefix = String.format(\r\n      \"Argument '%s' of type %s is marked by @%s but got '\", \r\n      parameterName, parameter.getType(), Positive.class.getSimpleName());\r\n    String errorMessageSuffix = \"' for it\";\r\n\r\n    return factory.Block(0, com.sun.tools.javac.util.List.of(\r\n      factory.Throw(\r\n        factory.NewClass(null, nil(), \r\n          factory.Ident(symbolsTable.fromString(\r\n            IllegalArgumentException.class.getSimpleName())),\r\n            com.sun.tools.javac.util.List.of(factory.Binary(JCTree.Tag.PLUS, \r\n            factory.Binary(JCTree.Tag.PLUS, \r\n              factory.Literal(TypeTag.CLASS, errorMessagePrefix), \r\n              factory.Ident(parameterId)), \r\n              factory.Literal(TypeTag.CLASS, errorMessageSuffix))), null))));\r\n}\r\n```","```\r\nprivate void addCheck(MethodTree method, VariableTree parameter, Context context) {\r\n    JCTree.JCIf check = createCheck(parameter, context);\r\n    JCTree.JCBlock body = (JCTree.JCBlock) method.getBody();\r\n    body.stats = body.stats.prepend(check);\r\n}\r\n```","```\r\npublic class SimpleSourceFile extends SimpleJavaFileObject {\r\n    private String content;\r\n\r\n    public SimpleSourceFile(String qualifiedClassName, String testSource) {\r\n        super(URI.create(String.format(\r\n          \"file://%s%s\", qualifiedClassName.replaceAll(\"\\\\.\", \"/\"),\r\n          Kind.SOURCE.extension)), Kind.SOURCE);\r\n        content = testSource;\r\n    }\r\n\r\n    @Override\r\n    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\r\n        return content;\r\n    }\r\n}\r\n```","```\r\npublic class SimpleClassFile extends SimpleJavaFileObject {\r\n\r\n    private ByteArrayOutputStream out;\r\n\r\n    public SimpleClassFile(URI uri) {\r\n        super(uri, Kind.CLASS);\r\n    }\r\n\r\n    @Override\r\n    public OutputStream openOutputStream() throws IOException {\r\n        return out = new ByteArrayOutputStream();\r\n    }\r\n\r\n    public byte[] getCompiledBinaries() {\r\n        return out.toByteArray();\r\n    }\r\n\r\n    // getters\r\n}\r\n```","```\r\npublic class SimpleFileManager\r\n  extends ForwardingJavaFileManager<StandardJavaFileManager> {\r\n\r\n    private List<SimpleClassFile> compiled = new ArrayList<>();\r\n\r\n    // standard constructors/getters\r\n\r\n    @Override\r\n    public JavaFileObject getJavaFileForOutput(Location location,\r\n      String className, JavaFileObject.Kind kind, FileObject sibling) {\r\n        SimpleClassFile result = new SimpleClassFile(\r\n          URI.create(\"string://\" + className));\r\n        compiled.add(result);\r\n        return result;\r\n    }\r\n\r\n    public List<SimpleClassFile> getCompiled() {\r\n        return compiled;\r\n    }\r\n}\r\n```","```\r\npublic class TestCompiler {\r\n    public byte[] compile(String qualifiedClassName, String testSource) {\r\n        StringWriter output = new StringWriter();\r\n\r\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\r\n        SimpleFileManager fileManager = new SimpleFileManager(\r\n          compiler.getStandardFileManager(null, null, null));\r\n        List<SimpleSourceFile> compilationUnits \r\n          = singletonList(new SimpleSourceFile(qualifiedClassName, testSource));\r\n        List<String> arguments = new ArrayList<>();\r\n        arguments.addAll(asList(\"-classpath\", System.getProperty(\"java.class.path\"),\r\n          \"-Xplugin:\" + SampleJavacPlugin.NAME));\r\n        JavaCompiler.CompilationTask task \r\n          = compiler.getTask(output, fileManager, null, arguments, null,\r\n          compilationUnits);\r\n\r\n        task.call();\r\n        return fileManager.getCompiled().iterator().next().getCompiledBinaries();\r\n    }\r\n}\r\n```","```\r\npublic class TestRunner {\r\n\r\n    public Object run(byte[] byteCode, String qualifiedClassName, String methodName,\r\n      Class<?>[] argumentTypes, Object... args) throws Throwable {\r\n        ClassLoader classLoader = new ClassLoader() {\r\n            @Override\r\n            protected Class<?> findClass(String name) throws ClassNotFoundException {\r\n                return defineClass(name, byteCode, 0, byteCode.length);\r\n            }\r\n        };\r\n        Class<?> clazz;\r\n        try {\r\n            clazz = classLoader.loadClass(qualifiedClassName);\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"Can't load compiled test class\", e);\r\n        }\r\n\r\n        Method method;\r\n        try {\r\n            method = clazz.getMethod(methodName, argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            throw new RuntimeException(\r\n              \"Can't find the 'main()' method in the compiled test class\", e);\r\n        }\r\n\r\n        try {\r\n            return method.invoke(null, args);\r\n        } catch (InvocationTargetException e) {\r\n            throw e.getCause();\r\n        }\r\n    }\r\n}\r\n```","```\r\npublic class SampleJavacPluginTest {\r\n\r\n    private static final String CLASS_TEMPLATE\r\n      = \"package com.baeldung.javac;\\n\\n\" +\r\n        \"public class Test {\\n\" +\r\n        \"    public static %1$s service(@Positive %1$s i) {\\n\" +\r\n        \"        return i;\\n\" +\r\n        \"    }\\n\" +\r\n        \"}\\n\" +\r\n        \"\";\r\n\r\n    private TestCompiler compiler = new TestCompiler();\r\n    private TestRunner runner = new TestRunner();\r\n\r\n    @Test(expected = IllegalArgumentException.class)\r\n    public void givenInt_whenNegative_thenThrowsException() throws Throwable {\r\n        compileAndRun(double.class,-1);\r\n    }\r\n\r\n    private Object compileAndRun(Class<?> argumentType, Object argument) \r\n      throws Throwable {\r\n        String qualifiedClassName = \"com.baeldung.javac.Test\";\r\n        byte[] byteCode = compiler.compile(qualifiedClassName, \r\n          String.format(CLASS_TEMPLATE, argumentType.getName()));\r\n        return runner.run(byteCode, qualifiedClassName, \r\n        \"service\", new Class[] {argumentType}, argument);\r\n    }\r\n}\r\n```"]