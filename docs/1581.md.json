["```\r\nadd 5         // sorted-set = { 5 }, size = 1\r\nget median -> 5\r\n\r\nadd 7         // sorted-set = { 5, 7 }, size = 2 \r\nget median -> (5 + 7) / 2 = 6\r\n\r\nadd 10        // sorted-set = { 5, 7, 10 }, size = 3 \r\nget median -> 7\r\n\r\nadd 8         // sorted-set = { 5, 7, 8, 10 }, size = 4 \r\nget median -> (7 + 8) / 2 = 7.5\r\n.. \r\n```","```\r\nvoid add(int num);\r\n\r\ndouble getMedian(); \r\n```","```\r\nif element is smaller than min. element of larger half:\r\n    insert into smaller half at appropriate index\r\n    if smaller half is much bigger than larger half:\r\n        remove max. element of smaller half and insert at the beginning of larger half (rebalance)\r\nelse\r\n    insert into larger half at appropriate index:\r\n    if larger half is much bigger than smaller half:\r\n        remove min. element of larger half and insert at the beginning of smaller half (rebalance) \r\n```","```\r\nif lists contain equal number of elements:\r\n    median = (max. element of smaller half + min. element of larger half) / 2\r\nelse if smaller half contains more elements:\r\n    median = max. element of smaller half\r\nelse if larger half contains more elements:\r\n    median = min. element of larger half\r\n```","```\r\nif size(minHeap) > size(maxHeap) + 1:\r\n    remove root element of minHeap, insert into maxHeap\r\nif size(maxHeap) > size(minHeap) + 1:\r\n    remove root element of maxHeap, insert into minHeap\r\n```","```\r\nclass MedianOfIntegerStream {\r\n\r\n    private Queue<Integer> minHeap, maxHeap;\r\n\r\n    MedianOfIntegerStream() {\r\n        minHeap = new PriorityQueue<>();\r\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\r\n    }\r\n\r\n    void add(int num) {\r\n        if (!minHeap.isEmpty() && num < minHeap.peek()) {\r\n            maxHeap.offer(num);\r\n            if (maxHeap.size() > minHeap.size() + 1) {\r\n                minHeap.offer(maxHeap.poll());\r\n            }\r\n        } else {\r\n            minHeap.offer(num);\r\n            if (minHeap.size() > maxHeap.size() + 1) {\r\n                maxHeap.offer(minHeap.poll());\r\n            }\r\n        }\r\n    }\r\n\r\n    double getMedian() {\r\n        int median;\r\n        if (minHeap.size() < maxHeap.size()) {\r\n            median = maxHeap.peek();\r\n        } else if (minHeap.size() > maxHeap.size()) {\r\n            median = minHeap.peek();\r\n        } else {\r\n            median = (minHeap.peek() + maxHeap.peek()) / 2; \r\n        }\r\n        return median;\r\n    }\r\n}\r\n```","```\r\nfind-min/find-max        O(1)    \r\n\r\ndelete-min/delete-max    O(log n)\r\n\r\ninsert                   O(log n) \r\n```","```\r\n1\\. Total no. of existing elements is even\r\n   size(min-heap) == size(max-heap) == (n / 2)\r\n\r\n2\\. Total no. of existing elements is odd\r\n   size(max-heap) == (n / 2)\r\n   size(min-heap) == (n / 2) + 1 \r\n```","```\r\nclass MedianOfIntegerStream {\r\n\r\n    private Queue<Integer> minHeap, maxHeap;\r\n\r\n    MedianOfIntegerStream() {\r\n        minHeap = new PriorityQueue<>();\r\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\r\n    }\r\n\r\n    void add(int num) {\r\n        if (minHeap.size() == maxHeap.size()) {\r\n            maxHeap.offer(num);\r\n            minHeap.offer(maxHeap.poll());\r\n        } else {\r\n            minHeap.offer(num);\r\n            maxHeap.offer(minHeap.poll());\r\n        }\r\n    }\r\n\r\n    double getMedian() {\r\n        int median;\r\n        if (minHeap.size() > maxHeap.size()) {\r\n            median = minHeap.peek();\r\n        } else {\r\n            median = (minHeap.peek() + maxHeap.peek()) / 2;\r\n        }\r\n        return median;\r\n    }\r\n}\r\n```"]