["```\r\nList<String> mapped = Stream.of(\"hello\", \"world\")\r\n  .map(word -> word + \"!\")\r\n  .collect(Collectors.toList());\r\n\r\nassertThat(mapped).containsExactly(\"hello!\", \"world!\");\r\n```","```\r\nString result = Stream.of(\"hello\", \"world\")\r\n  .reduce(\"\", (a, b) -> b + \"-\" + a);\r\n\r\nassertThat(result).isEqualTo(\"world-hello-\");\r\n```","```\r\nString result = Stream.of(\"hello\", \"world\")\r\n  .reduce(\"\", (String a, String b) -> b + \"-\" + a);\r\n```","```\r\nprivate String combineWithoutTrailingDash(String a, String b) {\r\n    if (a.isEmpty()) {\r\n        return b;\r\n    }\r\n    return b + \"-\" + a;\r\n}\r\n```","```\r\nString result = Stream.of(\"hello\", \"world\") \r\n  .reduce(\"\", (a, b) -> combineWithoutTrailingDash(a, b)); \r\n\r\nassertThat(result).isEqualTo(\"world-hello\");\r\n```","```\r\nString result = Stream.of(\"hello\", \"world\")\r\n  .reduce(\"\", this::combineWithoutTrailingDash);\r\n\r\nassertThat(result).isEqualTo(\"world-hello\");\r\n```","```\r\nList<String> list1 = Arrays.asList(\"a\", \"b\", \"c\");\r\nList<Integer> list2 = Arrays.asList(1, 2, 3);\r\n\r\nList<String> result = new ArrayList<>();\r\nfor (int i=0; i < list1.size(); i++) {\r\n    result.add(list1.get(i) + list2.get(i));\r\n}\r\n\r\nassertThat(result).containsExactly(\"a1\", \"b2\", \"c3\");\r\n```","```\r\nprivate static <T, U, R> List<R> listCombiner(\r\n  List<T> list1, List<U> list2, BiFunction<T, U, R> combiner) {\r\n    List<R> result = new ArrayList<>();\r\n    for (int i = 0; i < list1.size(); i++) {\r\n        result.add(combiner.apply(list1.get(i), list2.get(i)));\r\n    }\r\n    return result;\r\n}\r\n```","```\r\nList<String> list1 = Arrays.asList(\"a\", \"b\", \"c\");\r\nList<Integer> list2 = Arrays.asList(1, 2, 3);\r\n\r\nList<String> result = listCombiner(list1, list2, (a, b) -> a + b);\r\n\r\nassertThat(result).containsExactly(\"a1\", \"b2\", \"c3\");\r\n```","```\r\nList<Double> list1 = Arrays.asList(1.0d, 2.1d, 3.3d);\r\nList<Float> list2 = Arrays.asList(0.1f, 0.2f, 4f);\r\n\r\nList<Boolean> result = listCombiner(list1, list2, (a, b) -> a > b);\r\n\r\nassertThat(result).containsExactly(true, true, false);\r\n```","```\r\nList<Double> list1 = Arrays.asList(1.0d, 2.1d, 3.3d);\r\nList<Float> list2 = Arrays.asList(0.1f, 0.2f, 4f);\r\n\r\nList<Boolean> result = listCombiner(list1, list2, this::firstIsGreaterThanSecond);\r\n\r\nassertThat(result).containsExactly(true, true, false);\r\n\r\nprivate boolean firstIsGreaterThanSecond(Double a, Float b) {\r\n    return a > b;\r\n}\r\n```","```\r\nList<Float> list1 = Arrays.asList(0.1f, 0.2f, 4f);\r\nList<Float> list2 = Arrays.asList(0.1f, 0.2f, 4f);\r\n\r\nList<Boolean> result = listCombiner(list1, list2, (a, b) -> a.equals(b));\r\n\r\nassertThat(result).containsExactly(true, true, true);\r\n```","```\r\nList<Boolean> result = listCombiner(list1, list2, Float::equals);\r\n```","```\r\nList<Double> list1 = Arrays.asList(1.0d, 2.1d, 3.3d);\r\nList<Double> list2 = Arrays.asList(0.1d, 0.2d, 4d);\r\n\r\nList<Integer> result = listCombiner(list1, list2, Double::compareTo);\r\n\r\nassertThat(result).containsExactly(1, 1, -1);\r\n```","```\r\nprivate static <T, U, R> BiFunction<T, U, R> asBiFunction(BiFunction<T, U, R> function) {\r\n    return function;\r\n}\r\n```","```\r\nList<Double> list1 = Arrays.asList(1.0d, 2.1d, 3.3d);\r\nList<Double> list2 = Arrays.asList(0.1d, 0.2d, 4d);\r\n\r\nList<Boolean> result = listCombiner(list1, list2,\r\n  asBiFunction(Double::compareTo).andThen(i -> i > 0));\r\n\r\nassertThat(result).containsExactly(true, true, false);\r\n```"]