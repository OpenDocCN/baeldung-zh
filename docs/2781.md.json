["```\r\npublic ConcurrentHashMap(\r\n```","```\r\npublic ConcurrentHashMap(\r\n int initialCapacity, float loadFactor, int concurrencyLevel)\r\n```","```\r\n@Test\r\npublic void givenHashMap_whenSumParallel_thenError() throws Exception {\r\n    Map<String, Integer> map = new HashMap<>();\r\n    List<Integer> sumList = parallelSum100(map, 100);\r\n\r\n    assertNotEquals(1, sumList\r\n      .stream()\r\n      .distinct()\r\n      .count());\r\n    long wrongResultCount = sumList\r\n      .stream()\r\n      .filter(num -> num != 100)\r\n      .count();\r\n\r\n    assertTrue(wrongResultCount > 0);\r\n}\r\n\r\nprivate List<Integer> parallelSum100(Map<String, Integer> map, \r\n  int executionTimes) throws InterruptedException {\r\n    List<Integer> sumList = new ArrayList<>(1000);\r\n    for (int i = 0; i < executionTimes; i++) {\r\n        map.put(\"test\", 0);\r\n        ExecutorService executorService = \r\n          Executors.newFixedThreadPool(4);\r\n        for (int j = 0; j < 10; j++) {\r\n            executorService.execute(() -> {\r\n                for (int k = 0; k < 10; k++)\r\n                    map.computeIfPresent(\r\n                      \"test\", \r\n                      (key, value) -> value + 1\r\n                    );\r\n            });\r\n        }\r\n        executorService.shutdown();\r\n        executorService.awaitTermination(5, TimeUnit.SECONDS);\r\n        sumList.add(map.get(\"test\"));\r\n    }\r\n    return sumList;\r\n}\r\n```","```\r\n@Test\r\npublic void givenConcurrentMap_whenSumParallel_thenCorrect() \r\n  throws Exception {\r\n    Map<String, Integer> map = new ConcurrentHashMap<>();\r\n    List<Integer> sumList = parallelSum100(map, 1000);\r\n\r\n    assertEquals(1, sumList\r\n      .stream()\r\n      .distinct()\r\n      .count());\r\n    long wrongResultCount = sumList\r\n      .stream()\r\n      .filter(num -> num != 100)\r\n      .count();\r\n\r\n    assertEquals(0, wrongResultCount);\r\n}\r\n```","```\r\n@Test(expected = NullPointerException.class)\r\npublic void givenConcurrentHashMap_whenPutWithNullKey_thenThrowsNPE() {\r\n    concurrentMap.put(null, new Object());\r\n}\r\n\r\n@Test(expected = NullPointerException.class)\r\npublic void givenConcurrentHashMap_whenPutNullValue_thenThrowsNPE() {\r\n    concurrentMap.put(\"test\", null);\r\n}\r\n```","```\r\n@Test\r\npublic void givenKeyPresent_whenComputeRemappingNull_thenMappingRemoved() {\r\n    Object oldValue = new Object();\r\n    concurrentMap.put(\"test\", oldValue);\r\n    concurrentMap.compute(\"test\", (s, o) -> null);\r\n\r\n    assertNull(concurrentMap.get(\"test\"));\r\n}\r\n```","```\r\n@Test\r\npublic void givenMaps_whenGetPut500KTimes_thenConcurrentMapFaster() \r\n  throws Exception {\r\n    Map<String, Object> hashtable = new Hashtable<>();\r\n    Map<String, Object> synchronizedHashMap = \r\n      Collections.synchronizedMap(new HashMap<>());\r\n    Map<String, Object> concurrentHashMap = new ConcurrentHashMap<>();\r\n\r\n    long hashtableAvgRuntime = timeElapseForGetPut(hashtable);\r\n    long syncHashMapAvgRuntime = \r\n      timeElapseForGetPut(synchronizedHashMap);\r\n    long concurrentHashMapAvgRuntime = \r\n      timeElapseForGetPut(concurrentHashMap);\r\n\r\n    assertTrue(hashtableAvgRuntime > concurrentHashMapAvgRuntime);\r\n    assertTrue(syncHashMapAvgRuntime > concurrentHashMapAvgRuntime);\r\n}\r\n\r\nprivate long timeElapseForGetPut(Map<String, Object> map) \r\n  throws InterruptedException {\r\n    ExecutorService executorService = \r\n      Executors.newFixedThreadPool(4);\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < 4; i++) {\r\n        executorService.execute(() -> {\r\n            for (int j = 0; j < 500_000; j++) {\r\n                int value = ThreadLocalRandom\r\n                  .current()\r\n                  .nextInt(10000);\r\n                String key = String.valueOf(value);\r\n                map.put(key, value);\r\n                map.get(key);\r\n            }\r\n        });\r\n    }\r\n    executorService.shutdown();\r\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\r\n    return (System.nanoTime() - startTime) / 500_000;\r\n}\r\n```","```\r\nHashtable: 1142.45\r\nSynchronizedHashMap: 1273.89\r\nConcurrentHashMap: 230.2\r\n```","```\r\n@Test\r\npublic void givenConcurrentMap_whenUpdatingAndGetSize_thenError() \r\n  throws InterruptedException {\r\n    Runnable collectMapSizes = () -> {\r\n        for (int i = 0; i < MAX_SIZE; i++) {\r\n            mapSizes.add(concurrentMap.size());\r\n        }\r\n    };\r\n    Runnable updateMapData = () -> {\r\n        for (int i = 0; i < MAX_SIZE; i++) {\r\n            concurrentMap.put(String.valueOf(i), i);\r\n        }\r\n    };\r\n    executorService.execute(updateMapData);\r\n    executorService.execute(collectMapSizes);\r\n    executorService.shutdown();\r\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\r\n\r\n    assertNotEquals(MAX_SIZE, mapSizes.get(MAX_SIZE - 1).intValue());\r\n    assertEquals(MAX_SIZE, concurrentMap.size());\r\n}\r\n```","```\r\npublic ConcurrentHashMap(\r\n  int initialCapacity, float loadFactor, int concurrencyLevel) {\r\n\r\n    //...\r\n    if (initialCapacity < concurrencyLevel) {\r\n        initialCapacity = concurrencyLevel;\r\n    }\r\n    //...\r\n}\r\n```","```\r\n@Test\r\npublic void givenSkipListMap_whenNavConcurrently_thenCountCorrect() \r\n  throws InterruptedException {\r\n    NavigableMap<Integer, Integer> skipListMap\r\n      = new ConcurrentSkipListMap<>();\r\n    int count = countMapElementByPollingFirstEntry(skipListMap, 10000, 4);\r\n\r\n    assertEquals(10000 * 4, count);\r\n}\r\n\r\n@Test\r\npublic void givenTreeMap_whenNavConcurrently_thenCountError() \r\n  throws InterruptedException {\r\n    NavigableMap<Integer, Integer> treeMap = new TreeMap<>();\r\n    int count = countMapElementByPollingFirstEntry(treeMap, 10000, 4);\r\n\r\n    assertNotEquals(10000 * 4, count);\r\n}\r\n\r\nprivate int countMapElementByPollingFirstEntry(\r\n  NavigableMap<Integer, Integer> navigableMap, \r\n  int elementCount, \r\n  int concurrencyLevel) throws InterruptedException {\r\n\r\n    for (int i = 0; i < elementCount * concurrencyLevel; i++) {\r\n        navigableMap.put(i, i);\r\n    }\r\n\r\n    AtomicInteger counter = new AtomicInteger(0);\r\n    ExecutorService executorService\r\n      = Executors.newFixedThreadPool(concurrencyLevel);\r\n    for (int j = 0; j < concurrencyLevel; j++) {\r\n        executorService.execute(() -> {\r\n            for (int i = 0; i < elementCount; i++) {\r\n                if (navigableMap.pollFirstEntry() != null) {\r\n                    counter.incrementAndGet();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    executorService.shutdown();\r\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\r\n    return counter.get();\r\n}\r\n```"]