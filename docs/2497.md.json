["```\r\n@Test\r\npublic void givenThreads_whenMessageExchanged_thenCorrect() {\r\n    Exchanger<String> exchanger = new Exchanger<>();\r\n\r\n    Runnable taskA = () -> {\r\n        try {\r\n            String message = exchanger.exchange(\"from A\");\r\n            assertEquals(\"from B\", message);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread.interrupt();\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n\r\n    Runnable taskB = () -> {\r\n        try {\r\n            String message = exchanger.exchange(\"from B\");\r\n            assertEquals(\"from A\", message);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread.interrupt();\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n    CompletableFuture.allOf(\r\n      runAsync(taskA), runAsync(taskB)).join();\r\n}\r\n```","```\r\n@Test\r\npublic void givenThread_WhenExchangedMessage_thenCorrect() throws InterruptedException {\r\n    Exchanger<String> exchanger = new Exchanger<>();\r\n\r\n    Runnable runner = () -> {\r\n        try {\r\n            String message = exchanger.exchange(\"from runner\");\r\n            assertEquals(\"to runner\", message);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread.interrupt();\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n    CompletableFuture<Void> result \r\n      = CompletableFuture.runAsync(runner);\r\n    String msg = exchanger.exchange(\"to runner\");\r\n    assertEquals(\"from runner\", msg);\r\n    result.join();\r\n}\r\n```","```\r\n@Test\r\npublic void givenData_whenPassedThrough_thenCorrect() throws InterruptedException {\r\n\r\n    Exchanger<Queue<String>> readerExchanger = new Exchanger<>();\r\n    Exchanger<Queue<String>> writerExchanger = new Exchanger<>();\r\n\r\n    Runnable reader = () -> {\r\n        Queue<String> readerBuffer = new ConcurrentLinkedQueue<>();\r\n        while (true) {\r\n            readerBuffer.add(UUID.randomUUID().toString());\r\n            if (readerBuffer.size() >= BUFFER_SIZE) {\r\n                readerBuffer = readerExchanger.exchange(readerBuffer);\r\n            }\r\n        }\r\n    };\r\n\r\n    Runnable processor = () -> {\r\n        Queue<String> processorBuffer = new ConcurrentLinkedQueue<>();\r\n        Queue<String> writerBuffer = new ConcurrentLinkedQueue<>();\r\n        processorBuffer = readerExchanger.exchange(processorBuffer);\r\n        while (true) {\r\n            writerBuffer.add(processorBuffer.poll());\r\n            if (processorBuffer.isEmpty()) {\r\n                processorBuffer = readerExchanger.exchange(processorBuffer);\r\n                writerBuffer = writerExchanger.exchange(writerBuffer);\r\n            }\r\n        }\r\n    };\r\n\r\n    Runnable writer = () -> {\r\n        Queue<String> writerBuffer = new ConcurrentLinkedQueue<>();\r\n        writerBuffer = writerExchanger.exchange(writerBuffer);\r\n        while (true) {\r\n            System.out.println(writerBuffer.poll());\r\n            if (writerBuffer.isEmpty()) {\r\n                writerBuffer = writerExchanger.exchange(writerBuffer);\r\n            }\r\n        }\r\n    };\r\n    CompletableFuture.allOf(\r\n      runAsync(reader), \r\n      runAsync(processor),\r\n      runAsync(writer)).join();\r\n}\r\n```"]