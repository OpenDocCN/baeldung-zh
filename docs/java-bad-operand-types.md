# Java 错误“二元运算符的操作数类型不正确”

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-bad-operand-types>

## 1.概观

Java 提供了一组[位操作符](/web/20221208143917/https://www.baeldung.com/java-bitwise-operators)。这些运算符允许我们方便地处理一个数的各个位。

然而，当我们比较按位运算的结果时，我们可能会陷入一个常见的陷阱。

在这个快速教程中，我们将讨论为什么会遇到 Java 编译时错误“二元运算符的操作数类型不正确”，以及如何解决这个问题。

## 2.问题简介

像往常一样，我们通过一个例子来理解这个问题。但是，首先，让我们来看看一个简单的方法:

```
public void checkNumber() {
    List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
    intList.forEach(i -> {
        if (i & 1 == 1) {
            System.out.println(i + " is odd.");
        } else {
            System.out.println(i + " is even.");
        }
    });
} 
```

我们可以看到，`checkNumber`方法遍历`intList`，检查并输出每个数字是偶数还是奇数。

我们要注意的是，方法中的奇校验逻辑并不是以一种常见的方式实现的:`i % 2 == 1`。相反，**我们对一个`Integer`数(`i`和 1 执行逐位 AND ( &)运算。**如果结果是 1，我们知道整数`i`是奇数:`i & 1 ==1`。

然而，当我们尝试测试上面的方法时，代码令人惊讶地无法编译:

```
java: bad operand types for binary operator '&'
  first type:  java.lang.Integer
  second type: boolean
```

接下来我们来了解一下问题的原因是什么，如何解决。

## 3.理解 Java 运算符优先级

首先，错误消息非常简单。它说我们试图对一个`boolean`类型和一个`Integer`类型进行按位 AND 运算。

然而，这很奇怪，因为我们在代码中逐字写了“`i & 1`”。为什么编译器会认为一个`boolean`类型参与了按位 AND 运算？

这是因为"`==`"运算符的优先级高于"`&`"运算符。也就是说“`i & 1 == 1`”这个表达和“`i & (1 == 1)`”是一样的。由此，我们有了“T4”。

现在，我们可能会问:“好的，==的优先级高于`&`。但是为什么'`i % 2 == 1`'会按预期工作呢？”

要回答这个问题，我们需要仔细研究一下 Java 操作符的优先规则。

Java 提供了相当多的[操作符](/web/20221208143917/https://www.baeldung.com/java-operators)。在实践中，我们经常一起使用不同的运算符。因此，理解 Java 操作符的优先级是至关重要的。否则，我们可能会有意想不到的结果。

接下来，让我们看一下 Java 运算符优先级规则(运算符在表中出现的位置越高，优先级越高):

| 经营者 | 优先 |
| 后缀 | ``expr` ++ `expr` —` |
| 一元的 | `++`expr`—`expr`+`expr`—`expr`~！` |
| 增加的 | `* / %` |
| 添加剂 | `+ –` |
| 变化 | `<< >> >>>` |
| 有关系的 | `< > <= >= instanceof` |
| 平等 | `== !=` |
| 按位 AND | `&` |
| 按位异或 | `^` |
| 按位异或 | `&#124;` |
| 逻辑与 | `&&` |
| 逻辑或 | `&#124;&#124;` |
| 第三的 | `? :` |
| 作业 | `= += -= *= /= %= &= ^= &#124;= <<= >>= >>>=` |

从上面的列表中我们可以看到，**模运算符(%)的优先级高于等式运算符(`==` )** 。另一方面，**按位 and 运算符(&)位于表中等式运算符(==)** 的下方。

这就是为什么"`i % 2 == 1`"能按预期工作，而"`i & 1 == 1`"不能。

在我们的例子中，我们遇到了一个编译时错误。因此，我们可以相对较早地发现问题。然而，想象一下，一些带有操作优先 bug 的实现编译时产生了错误的结果。找到问题的真正原因可能会花费我们很多不必要的时间。

因此，记住 Java 操作符优先规则是值得的。

## 4.修复问题

既然我们了解了问题的原因，解决问题就不是一件困难的工作。我们只需要给按位 AND 运算加上括号:

```
if (i & 1 == 1)  -->  if ((i & 1) == 1)
```

修复后，如果我们再次运行该方法，我们会看到编译器不再抱怨，并且我们会收到预期的输出:

```
1 is odd.
2 is even.
3 is odd.
4 is even.
5 is odd.
6 is even.
7 is odd.
```

## 5.结论

在这篇简短的文章中，我们通过一个按位 and 运算示例分析了编译错误“二元运算符的操作数类型不正确”。

此外，我们已经讨论了 Java 操作符的优先规则。

最后，我们已经解决了这个问题。