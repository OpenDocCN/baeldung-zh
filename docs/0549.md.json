["```\r\nSelfSignedCertificate ssc = new SelfSignedCertificate();\r\nSslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\r\n  .sslProvider(SslProvider.JDK)\r\n  .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)\r\n  .applicationProtocolConfig(\r\n    new ApplicationProtocolConfig(Protocol.ALPN, SelectorFailureBehavior.NO_ADVERTISE,\r\n      SelectedListenerFailureBehavior.ACCEPT, ApplicationProtocolNames.HTTP_2))\r\n  .build();\r\n```","```\r\npublic final class Http2Server {\r\n\r\n    static final int PORT = 8443;\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SslContext sslCtx = // create sslContext as described above\r\n        EventLoopGroup group = new NioEventLoopGroup();\r\n        try {\r\n            ServerBootstrap b = new ServerBootstrap();\r\n            b.option(ChannelOption.SO_BACKLOG, 1024);\r\n            b.group(group)\r\n              .channel(NioServerSocketChannel.class)\r\n              .handler(new LoggingHandler(LogLevel.INFO))\r\n              .childHandler(new ChannelInitializer() {\r\n                  @Override\r\n                  protected void initChannel(SocketChannel ch) throws Exception {\r\n                      if (sslCtx != null) {\r\n                          ch.pipeline()\r\n                            .addLast(sslCtx.newHandler(ch.alloc()), Http2Util.getServerAPNHandler());\r\n                      }\r\n                  }\r\n            });\r\n            Channel ch = b.bind(PORT).sync().channel();\r\n\r\n            logger.info(\"HTTP/2 Server is listening on https://127.0.0.1:\" + PORT + '/');\r\n\r\n            ch.closeFuture().sync();\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n}\r\n```","```\r\npublic static ApplicationProtocolNegotiationHandler getServerAPNHandler() {\r\n    ApplicationProtocolNegotiationHandler serverAPNHandler = \r\n      new ApplicationProtocolNegotiationHandler(ApplicationProtocolNames.HTTP_2) {\r\n\r\n        @Override\r\n        protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {\r\n            if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {\r\n                ctx.pipeline().addLast(\r\n                  Http2FrameCodecBuilder.forServer().build(), new Http2ServerResponseHandler());\r\n                return;\r\n            }\r\n            throw new IllegalStateException(\"Protocol: \" + protocol + \" not supported\");\r\n        }\r\n    };\r\n    return serverAPNHandler;\r\n}\r\n```","```\r\nstatic final ByteBuf RESPONSE_BYTES = Unpooled.unreleasableBuffer(\r\n  Unpooled.copiedBuffer(\"Hello World\", CharsetUtil.UTF_8));\r\n```","```\r\n@Override\r\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\r\n    if (msg instanceof Http2HeadersFrame) {\r\n        Http2HeadersFrame msgHeader = (Http2HeadersFrame) msg;\r\n        if (msgHeader.isEndStream()) {\r\n            ByteBuf content = ctx.alloc().buffer();\r\n            content.writeBytes(RESPONSE_BYTES.duplicate());\r\n\r\n            Http2Headers headers = new DefaultHttp2Headers().status(HttpResponseStatus.OK.codeAsText());\r\n            ctx.write(new DefaultHttp2HeadersFrame(headers).stream(msgHeader.stream()));\r\n            ctx.write(new DefaultHttp2DataFrame(content, true).stream(msgHeader.stream()));\r\n        }\r\n    } else {\r\n        super.channelRead(ctx, msg);\r\n    }\r\n} \r\n```","```\r\ncurl -k -v --http2 https://127.0.0.1:8443\r\n```","```\r\n> GET / HTTP/2\r\n> Host: 127.0.0.1:8443\r\n> User-Agent: curl/7.64.1\r\n> Accept: */*\r\n> \r\n* Connection state changed (MAX_CONCURRENT_STREAMS == 4294967295)!\r\n< HTTP/2 200 \r\n< \r\n* Connection #0 to host 127.0.0.1 left intact\r\nHello World* Closing connection 0\r\n```","```\r\n@Before\r\npublic void setup() throws Exception {\r\n    SslContext sslCtx = SslContextBuilder.forClient()\r\n      .sslProvider(SslProvider.JDK)\r\n      .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)\r\n      .trustManager(InsecureTrustManagerFactory.INSTANCE)\r\n      .applicationProtocolConfig(\r\n        new ApplicationProtocolConfig(Protocol.ALPN, SelectorFailureBehavior.NO_ADVERTISE,\r\n          SelectedListenerFailureBehavior.ACCEPT, ApplicationProtocolNames.HTTP_2))\r\n      .build();\r\n}\r\n```","```\r\npublic class Http2SettingsHandler extends SimpleChannelInboundHandler<Http2Settings> {\r\n    private final ChannelPromise promise;\r\n\r\n    // constructor\r\n\r\n    @Override\r\n    protected void channelRead0(ChannelHandlerContext ctx, Http2Settings msg) throws Exception {\r\n        promise.setSuccess();\r\n        ctx.pipeline().remove(this);\r\n    }\r\n}\r\n```","```\r\npublic void awaitSettings(long timeout, TimeUnit unit) throws Exception {\r\n    if (!promise.awaitUninterruptibly(timeout, unit)) {\r\n        throw new IllegalStateException(\"Timed out waiting for settings\");\r\n    }\r\n}\r\n```","```\r\npublic class Http2ClientResponseHandler extends SimpleChannelInboundHandler {\r\n\r\n    private final Map<Integer, MapValues> streamidMap;\r\n\r\n    // constructor\r\n}\r\n```","```\r\npublic static class MapValues {\r\n    ChannelFuture writeFuture;\r\n    ChannelPromise promise;\r\n\r\n    // constructor and getters\r\n} \r\n```","```\r\npublic MapValues put(int streamId, ChannelFuture writeFuture, ChannelPromise promise) {\r\n    return streamidMap.put(streamId, new MapValues(writeFuture, promise));\r\n} \r\n```","```\r\n@Override\r\nprotected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\r\n    Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\r\n    if (streamId == null) {\r\n        logger.error(\"HttpResponseHandler unexpected message received: \" + msg);\r\n        return;\r\n    }\r\n\r\n    MapValues value = streamidMap.get(streamId);\r\n\r\n    if (value == null) {\r\n        logger.error(\"Message received for unknown stream id \" + streamId);\r\n    } else {\r\n        ByteBuf content = msg.content();\r\n        if (content.isReadable()) {\r\n            int contentLength = content.readableBytes();\r\n            byte[] arr = new byte[contentLength];\r\n            content.readBytes(arr);\r\n            logger.info(new String(arr, 0, contentLength, CharsetUtil.UTF_8));\r\n        }\r\n\r\n        value.getPromise().setSuccess();\r\n    }\r\n}\r\n```","```\r\npublic String awaitResponses(long timeout, TimeUnit unit) {\r\n    Iterator<Entry<Integer, MapValues>> itr = streamidMap.entrySet().iterator();        \r\n    String response = null;\r\n\r\n    while (itr.hasNext()) {\r\n        Entry<Integer, MapValues> entry = itr.next();\r\n        ChannelFuture writeFuture = entry.getValue().getWriteFuture();\r\n\r\n        if (!writeFuture.awaitUninterruptibly(timeout, unit)) {\r\n            throw new IllegalStateException(\"Timed out waiting to write for stream id \" + entry.getKey());\r\n        }\r\n        if (!writeFuture.isSuccess()) {\r\n            throw new RuntimeException(writeFuture.cause());\r\n        }\r\n        ChannelPromise promise = entry.getValue().getPromise();\r\n\r\n        if (!promise.awaitUninterruptibly(timeout, unit)) {\r\n            throw new IllegalStateException(\"Timed out waiting for response on stream id \"\r\n              + entry.getKey());\r\n        }\r\n        if (!promise.isSuccess()) {\r\n            throw new RuntimeException(promise.cause());\r\n        }\r\n        logger.info(\"---Stream id: \" + entry.getKey() + \" received---\");\r\n        response = entry.getValue().getResponse();\r\n\r\n        itr.remove();\r\n    }        \r\n    return response;\r\n}\r\n```","```\r\npublic class Http2ClientInitializer extends ChannelInitializer {\r\n\r\n    private final SslContext sslCtx;\r\n    private final int maxContentLength;\r\n    private Http2SettingsHandler settingsHandler;\r\n    private Http2ClientResponseHandler responseHandler;\r\n    private String host;\r\n    private int port;\r\n\r\n    // constructor\r\n\r\n    @Override\r\n    public void initChannel(SocketChannel ch) throws Exception {\r\n        settingsHandler = new Http2SettingsHandler(ch.newPromise());\r\n        responseHandler = new Http2ClientResponseHandler();\r\n\r\n        if (sslCtx != null) {\r\n            ChannelPipeline pipeline = ch.pipeline();\r\n            pipeline.addLast(sslCtx.newHandler(ch.alloc(), host, port));\r\n            pipeline.addLast(Http2Util.getClientAPNHandler(maxContentLength, \r\n              settingsHandler, responseHandler));\r\n        }\r\n    }\r\n    // getters\r\n}\r\n```","```\r\npublic static ApplicationProtocolNegotiationHandler getClientAPNHandler(\r\n  int maxContentLength, Http2SettingsHandler settingsHandler, Http2ClientResponseHandler responseHandler) {\r\n    final Http2FrameLogger logger = new Http2FrameLogger(INFO, Http2ClientInitializer.class);\r\n    final Http2Connection connection = new DefaultHttp2Connection(false);\r\n\r\n    HttpToHttp2ConnectionHandler connectionHandler = \r\n      new HttpToHttp2ConnectionHandlerBuilder().frameListener(\r\n        new DelegatingDecompressorFrameListener(connection, \r\n          new InboundHttp2ToHttpAdapterBuilder(connection)\r\n            .maxContentLength(maxContentLength)\r\n            .propagateSettings(true)\r\n            .build()))\r\n          .frameLogger(logger)\r\n          .connection(connection)\r\n          .build();\r\n\r\n    ApplicationProtocolNegotiationHandler clientAPNHandler = \r\n      new ApplicationProtocolNegotiationHandler(ApplicationProtocolNames.HTTP_2) {\r\n        @Override\r\n        protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\r\n            if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {\r\n                ChannelPipeline p = ctx.pipeline();\r\n                p.addLast(connectionHandler);\r\n                p.addLast(settingsHandler, responseHandler);\r\n                return;\r\n            }\r\n            ctx.close();\r\n            throw new IllegalStateException(\"Protocol: \" + protocol + \" not supported\");\r\n        }\r\n    };\r\n    return clientAPNHandler;\r\n} \r\n```","```\r\n@Test\r\npublic void whenRequestSent_thenHelloWorldReceived() throws Exception {\r\n\r\n    EventLoopGroup workerGroup = new NioEventLoopGroup();\r\n    Http2ClientInitializer initializer = new Http2ClientInitializer(sslCtx, Integer.MAX_VALUE, HOST, PORT);\r\n\r\n    try {\r\n        Bootstrap b = new Bootstrap();\r\n        b.group(workerGroup);\r\n        b.channel(NioSocketChannel.class);\r\n        b.option(ChannelOption.SO_KEEPALIVE, true);\r\n        b.remoteAddress(HOST, PORT);\r\n        b.handler(initializer);\r\n\r\n        channel = b.connect().syncUninterruptibly().channel();\r\n\r\n        logger.info(\"Connected to [\" + HOST + ':' + PORT + ']');\r\n\r\n        Http2SettingsHandler http2SettingsHandler = initializer.getSettingsHandler();\r\n        http2SettingsHandler.awaitSettings(60, TimeUnit.SECONDS);\r\n\r\n        logger.info(\"Sending request(s)...\");\r\n\r\n        FullHttpRequest request = Http2Util.createGetRequest(HOST, PORT);\r\n\r\n        Http2ClientResponseHandler responseHandler = initializer.getResponseHandler();\r\n        int streamId = 3;\r\n\r\n        responseHandler.put(streamId, channel.write(request), channel.newPromise());\r\n        channel.flush();\r\n\r\n        String response = responseHandler.awaitResponses(60, TimeUnit.SECONDS);\r\n\r\n        assertEquals(\"Hello World\", response);\r\n\r\n        logger.info(\"Finished HTTP/2 request(s)\");\r\n    } finally {\r\n        workerGroup.shutdownGracefully();\r\n    }\r\n} \r\n```"]