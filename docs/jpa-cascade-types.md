# JPA/Hibernate 级联类型概述

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jpa-cascade-types>

## 1.概观

在本教程中，我们将讨论 JPA/Hibernate 中的级联是什么。然后我们将介绍各种可用的级联类型，以及它们的语义。

## 延伸阅读:

## [Spring Data JPA 简介](/web/20221108213652/https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa)

Introduction to Spring Data JPA with Spring 4 - the Spring config, the DAO, manual and generated queries and transaction management.[Read more](/web/20221108213652/https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa) →

## [用 JPA 将实体类名映射到 SQL 表名](/web/20221108213652/https://www.baeldung.com/jpa-entity-table-names)

Learn how table names are generated by default and how to override that behavior.[Read more](/web/20221108213652/https://www.baeldung.com/jpa-entity-table-names) →

## 2.什么是级联？

实体关系通常依赖于另一个实体的存在，例如`Person`–`Address`关系。没有了`Person`,`Address`实体本身没有任何意义。当我们删除`Person`实体时，我们的`Address`实体也应该被删除。

级联就是实现这一点的方法。当我们在目标实体上执行一些动作时，相同的动作将被应用到相关联的实体上。

### 2.1.JPA 级联型

所有特定于 JPA 的级联操作都由包含条目的`javax.persistence.CascadeType` 枚举表示:

*   `ALL`
*   `PERSIST`
*   `MERGE`
*   `REMOVE`
*   `REFRESH`
*   `DETACH`

### 2.2.休眠级联类型

除了 JPA 指定的级联类型，Hibernate 还支持另外三种级联类型。这些特定于 Hibernate 的级联类型在`org.hibernate.annotations.CascadeType`中可用:

*   `REPLICATE`
*   `SAVE_UPDATE`
*   `LOCK`

## 3.级联类型之间的差异

### 3.1.`CascadeType`。`ALL`

`CascadeType.ALL` **将所有操作——包括 Hibernate 特有的操作——从父实体传播到子实体。**

让我们看一个例子:

```java
@Entity
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String name;
    @OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
    private List<Address> addresses;
}
```

**注意，在`OneToMany`关联中，我们已经在注释中提到了级联类型。**

现在让我们看看关联的实体`Address`:

```java
@Entity
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String street;
    private int houseNumber;
    private String city;
    private int zipCode;
    @ManyToOne(fetch = FetchType.LAZY)
    private Person person;
}
```

### 3.2.`CascadeType`。`PERSIST`

持久化操作使瞬态实例持久化。**级联类型`PERSIST`将持久化操作从父实体传播到子实体。**当我们保存`person`实体时，`address`实体也会被保存。

让我们看看持久化操作的测试用例:

```java
@Test
public void whenParentSavedThenChildSaved() {
    Person person = new Person();
    Address address = new Address();
    address.setPerson(person);
    person.setAddresses(Arrays.asList(address));
    session.persist(person);
    session.flush();
    session.clear();
}
```

当我们运行上面的测试用例时，我们会看到下面的 SQL:

```java
Hibernate: insert into Person (name, id) values (?, ?)
Hibernate: insert into Address (
    city, houseNumber, person_id, street, zipCode, id) values (?, ?, ?, ?, ?, ?)
```

### 3.3.`CascadeType`。`MERGE`

合并操作将给定对象的状态复制到具有相同标识符的持久对象上。 **`CascadeType.MERGE`将合并操作从父实体传播到子实体。**

让我们测试合并操作:

```java
@Test
public void whenParentSavedThenMerged() {
    int addressId;
    Person person = buildPerson("devender");
    Address address = buildAddress(person);
    person.setAddresses(Arrays.asList(address));
    session.persist(person);
    session.flush();
    addressId = address.getId();
    session.clear();

    Address savedAddressEntity = session.find(Address.class, addressId);
    Person savedPersonEntity = savedAddressEntity.getPerson();
    savedPersonEntity.setName("devender kumar");
    savedAddressEntity.setHouseNumber(24);
    session.merge(savedPersonEntity);
    session.flush();
}
```

当我们运行测试用例时，合并操作会生成以下 SQL:

```java
Hibernate: select address0_.id as id1_0_0_, address0_.city as city2_0_0_, address0_.houseNumber as houseNum3_0_0_, address0_.person_id as person_i6_0_0_, address0_.street as street4_0_0_, address0_.zipCode as zipCode5_0_0_ from Address address0_ where address0_.id=?
Hibernate: select person0_.id as id1_1_0_, person0_.name as name2_1_0_ from Person person0_ where person0_.id=?
Hibernate: update Address set city=?, houseNumber=?, person_id=?, street=?, zipCode=? where id=?
Hibernate: update Person set name=? where id=?
```

在这里，我们可以看到合并操作首先加载了`address`和`person`实体，然后作为`CascadeType.MERGE`的结果更新了这两个实体。

### 3.4.`CascadeType.REMOVE`

顾名思义，remove 操作从数据库和持久上下文中删除对应于实体的行。

**`CascadeType.REMOVE`将删除操作从父实体传播到子实体。** **类似于 JPA 的`CascadeType.REMOVE`，我们有`CascadeType.DELETE`，专门针对 Hibernate。**两者没有区别。

现在是测试的时候了`CascadeType.Remove`:

```java
@Test
public void whenParentRemovedThenChildRemoved() {
    int personId;
    Person person = buildPerson("devender");
    Address address = buildAddress(person);
    person.setAddresses(Arrays.asList(address));
    session.persist(person);
    session.flush();
    personId = person.getId();
    session.clear();

    Person savedPersonEntity = session.find(Person.class, personId);
    session.remove(savedPersonEntity);
    session.flush();
}
```

当我们运行测试用例时，我们将看到以下 SQL:

```java
Hibernate: delete from Address where id=?
Hibernate: delete from Person where id=?
```

作为 `CascadeType.REMOVE`的结果，与`person`相关联的`address`也被移除。

### 3.5.`CascadeType.DETACH`

分离操作从持久上下文中删除实体。**当我们使用`CascadeType.DETACH`时，子实体也将从持久上下文中移除。**

让我们来看看它的实际应用:

```java
@Test
public void whenParentDetachedThenChildDetached() {
    Person person = buildPerson("devender");
    Address address = buildAddress(person);
    person.setAddresses(Arrays.asList(address));
    session.persist(person);
    session.flush();

    assertThat(session.contains(person)).isTrue();
    assertThat(session.contains(address)).isTrue();

    session.detach(person);
    assertThat(session.contains(person)).isFalse();
    assertThat(session.contains(address)).isFalse();
}
```

在这里，我们可以看到，在分离了`person`之后，`person`和`address`都不存在于持久上下文中。

### 3.6.`CascadeType`。`LOCK`

**非直观地， `CascadeType.LOCK`再次将实体及其关联的子实体与持久上下文关联。**

让我们看看测试案例来理解`CascadeType.LOCK`:

```java
@Test
public void whenDetachedAndLockedThenBothReattached() {
    Person person = buildPerson("devender");
    Address address = buildAddress(person);
    person.setAddresses(Arrays.asList(address));
    session.persist(person);
    session.flush();

    assertThat(session.contains(person)).isTrue();
    assertThat(session.contains(address)).isTrue();

    session.detach(person);
    assertThat(session.contains(person)).isFalse();
    assertThat(session.contains(address)).isFalse();
    session.unwrap(Session.class)
      .buildLockRequest(new LockOptions(LockMode.NONE))
      .lock(person);

    assertThat(session.contains(person)).isTrue();
    assertThat(session.contains(address)).isTrue();
}
```

正如我们所看到的，当使用`CascadeType.LOCK`时，我们将实体`person`及其关联的`address`附加回持久上下文。

### 3.7.`CascadeType`。`REFRESH`

刷新操作**从数据库中重新读取给定实例的值。**在某些情况下，我们可能会在数据库中保存后更改一个实例，但稍后我们需要撤销这些更改。

在这种情况下，这可能是有用的。**当我们对级联类型`REFRESH`使用该操作时，每当父实体被刷新时，子实体也会从数据库中重新加载。**

为了更好的理解，让我们看一个`CascadeType.REFRESH`的测试用例:

```java
@Test
public void whenParentRefreshedThenChildRefreshed() {
    Person person = buildPerson("devender");
    Address address = buildAddress(person);
    person.setAddresses(Arrays.asList(address));
    session.persist(person);
    session.flush();
    person.setName("Devender Kumar");
    address.setHouseNumber(24);
    session.refresh(person);

    assertThat(person.getName()).isEqualTo("devender");
    assertThat(address.getHouseNumber()).isEqualTo(23);
}
```

这里，我们对保存的实体`person`和`address`做了一些修改。当我们刷新`person`实体时，`address`也被刷新。

### 3.8.`CascadeType.REPLICATE`

**当我们有多个数据源，并且希望数据同步时，就使用复制操作。**使用`CascadeType.REPLICATE`，每当在父实体上执行同步操作时，同步操作也会传播到子实体。

现在我们来测试`CascadeType.` `REPLICATE`:

```java
@Test
public void whenParentReplicatedThenChildReplicated() {
    Person person = buildPerson("devender");
    person.setId(2);
    Address address = buildAddress(person);
    address.setId(2);
    person.setAddresses(Arrays.asList(address));
    session.unwrap(Session.class).replicate(person, ReplicationMode.OVERWRITE);
    session.flush();

    assertThat(person.getId()).isEqualTo(2);
    assertThat(address.getId()).isEqualTo(2);
}
```

因为`CascadeType`。`REPLICATE`，当我们复制`person`实体时，它关联的`address`也用我们设置的标识符复制。

### 3.9.`CascadeType.SAVE_UPDATE`

`CascadeType.SAVE_UPDATE`将相同的操作传播到关联的子实体。当我们使用像`save`、 `update`和`saveOrUpdate`这样的**休眠特有的操作时，这很有用。**

让我们看看`CascadeType.` `SAVE_UPDATE`的作用:

```java
@Test
public void whenParentSavedThenChildSaved() {
    Person person = buildPerson("devender");
    Address address = buildAddress(person);
    person.setAddresses(Arrays.asList(address));
    session.saveOrUpdate(person);
    session.flush();
}
```

因为`CascadeType.SAVE_UPDATE`，当我们运行上面的测试用例时，我们可以看到`person`和`address`都被保存了。

下面是结果 SQL:

```java
Hibernate: insert into Person (name, id) values (?, ?)
Hibernate: insert into Address (
    city, houseNumber, person_id, street, zipCode, id) values (?, ?, ?, ?, ?, ?)
```

## 4.结论

在本文中，我们讨论了级联以及 JPA 和 Hibernate 中可用的不同级联类型选项。

文章的源代码是 GitHub 上的[。](https://web.archive.org/web/20221108213652/https://github.com/eugenp/tutorials/tree/master/persistence-modules/jpa-hibernate-cascade-type)