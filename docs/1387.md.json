["```\r\nprivate static List<String> INPUT_NAMES = Arrays.asList(\"john\", \"mike\", \"usmon\", \"ken\", \"harry\");\r\n```","```\r\n@Test\r\nvoid givenListOfStrings_whenUsingCollections_thenListIsSorted() {\r\n    Collections.sort(INPUT_NAMES);\r\n    assertThat(INPUT_NAMES).isEqualTo(EXPECTED_NATURAL_ORDER);\r\n}\r\n```","```\r\nprivate static List<String> EXPECTED_NATURAL_ORDER = Arrays.asList(\"harry\", \"john\", \"ken\", \"mike\", \"usmon\"); \r\n```","```\r\nComparator<String> reverseComparator = (first, second) -> second.compareTo(first);\r\n```","```\r\nComparator<String> reverseComparator = Comparator.reverseOrder();\r\n```","```\r\n@Test\r\nvoid givenListOfStrings_whenUsingCollections_thenListIsSortedInReverse() {\r\n    Comparator<String> reverseComparator = Comparator.reverseOrder();\r\n    Collections.sort(INPUT_NAMES, reverseComparator); \r\n    assertThat(INPUT_NAMES).isEqualTo(EXPECTED_REVERSE_ORDER); \r\n}\r\n```","```\r\nprivate static List<String> EXPECTED_REVERSE_ORDER = Arrays.asList(\"usmon\", \"mike\", \"ken\", \"john\", \"harry\"); \r\n```","```\r\n@Test\r\nvoid givenListOfStringsWithUpperAndLowerCaseMixed_whenCustomComparator_thenListIsSortedCorrectly() {\r\n    List<String> movieNames = Arrays.asList(\"amazing SpiderMan\", \"Godzilla\", \"Sing\", \"Minions\");\r\n    List<String> naturalSortOrder = Arrays.asList(\"Godzilla\", \"Minions\", \"Sing\", \"amazing SpiderMan\");\r\n    List<String> comparatorSortOrder = Arrays.asList(\"amazing SpiderMan\", \"Godzilla\", \"Minions\", \"Sing\");\r\n\r\n    Collections.sort(movieNames);\r\n    assertThat(movieNames).isEqualTo(naturalSortOrder);\r\n\r\n    Collections.sort(movieNames, Comparator.comparing(s -> s.toLowerCase()));\r\n    assertThat(movieNames).isEqualTo(comparatorSortOrder);\r\n}\r\n```","```\r\n@Test\r\nvoid givenListOfStringsIncludingSomeWithSpecialCharacter_whenCustomComparator_thenListIsSortedWithSpecialCharacterLast() {\r\n    List<String> listWithSpecialCharacters = Arrays.asList(\"@laska\", \"blah\", \"jo\", \"@sk\", \"foo\");\r\n\r\n    List<String> sortedNaturalOrder = Arrays.asList(\"@laska\", \"@sk\", \"blah\", \"foo\", \"jo\");\r\n    List<String> sortedSpecialCharacterLast = Arrays.asList(\"blah\", \"foo\", \"jo\", \"@laska\", \"@sk\");\r\n\r\n    Collections.sort(listWithSpecialCharacters);\r\n    assertThat(listWithSpecialCharacters).isEqualTo(sortedNaturalOrder);\r\n\r\n    Comparator<String> specialSignComparator = Comparator.<String, Boolean>comparing(s -> s.startsWith(\"@\"));\r\n    Comparator<String> specialCharacterComparator = specialSignComparator.thenComparing(Comparator.naturalOrder());\r\n\r\n    listWithSpecialCharacters.sort(specialCharacterComparator);\r\n    assertThat(listWithSpecialCharacters).isEqualTo(sortedSpecialCharacterLast);\r\n}\r\n```","```\r\n@Test\r\nvoid givenListOfStrings_whenSortWithStreams_thenListIsSortedInNaturalOrder() {\r\n    List<String> sortedList = INPUT_NAMES.stream()\r\n      .sorted()\r\n      .collect(Collectors.toList());\r\n\r\n    assertThat(sortedList).isEqualTo(EXPECTED_NATURAL_ORDER);\r\n}\r\n```","```\r\n@Test\r\nvoid givenListOfStrings_whenSortWithStreamsUsingComparator_thenListIsSortedInReverseOrder() {\r\n    List<String> sortedList = INPUT_NAMES.stream()\r\n      .sorted((element1, element2) -> element2.compareTo(element1))\r\n      .collect(Collectors.toList());\r\n    assertThat(sortedList).isEqualTo(EXPECTED_REVERSE_ORDER);\r\n}\r\n```","```\r\nComparator<String> reverseOrderComparator = Comparator.reverseOrder();\r\n```","```\r\nList<String> sortedList = INPUT_NAMES.stream()\r\n  .sorted(reverseOrder)\r\n  .collect(Collectors.toList());\r\n```","```\r\n@Test\r\nvoid givenNames_whenUsingTreeSet_thenListIsSorted() {\r\n    SortedSet<String> sortedSet = new TreeSet<>(INPUT_NAMES);\r\n    List<String> sortedList = new ArrayList<>(sortedSet);\r\n    assertThat(sortedList).isEqualTo(EXPECTED_NATURAL_ORDER);\r\n}\r\n```","```\r\n@Test\r\nvoid givenListOfStrings_whenSortOnList_thenListIsSorted() {\r\n    INPUT_NAMES.sort(Comparator.reverseOrder());\r\n    assertThat(INPUT_NAMES).isEqualTo(EXPECTED_REVERSE_ORDER);\r\n} \r\n```","```\r\n List<String> accentedStrings = Arrays.asList(\"único\", \"árbol\", \"cosas\", \"fútbol\");\r\n```","```\r\n Collections.sort(accentedStrings);\r\n```","```\r\nCollator esCollator = Collator.getInstance(new Locale(\"es\")); \r\n```","```\r\naccentedStrings.sort((s1, s2) -> {\r\n    return esCollator.compare(s1, s2);\r\n});\r\n```","```\r\n@Test\r\nvoid givenListOfStringsWithAccent_whenSortWithTheCollator_thenListIsSorted() {\r\n    List<String> accentedStrings = Arrays.asList(\"único\", \"árbol\", \"cosas\", \"fútbol\");\r\n    List<String> sortedNaturalOrder = Arrays.asList(\"cosas\", \"fútbol\", \"árbol\", \"único\");\r\n    List<String> sortedLocaleSensitive = Arrays.asList(\"árbol\", \"cosas\", \"fútbol\", \"único\");\r\n\r\n    Collections.sort(accentedStrings);\r\n    assertThat(accentedStrings).isEqualTo(sortedNaturalOrder);\r\n\r\n    Collator esCollator = Collator.getInstance(new Locale(\"es\"));\r\n\r\n    accentedStrings.sort((s1, s2) -> {\r\n        return esCollator.compare(s1, s2);\r\n    });\r\n\r\n    assertThat(accentedStrings).isEqualTo(sortedLocaleSensitive);\r\n}\r\n```","```\r\nList<String> accentedStrings = Arrays.asList(\"único\",\"árbol\", \"cosas\", \"fútbol\");\r\n```","```\r\nCollections.sort(accentedStrings, (o1, o2) -> {\r\n    o1 = Normalizer.normalize(o1, Normalizer.Form.NFD);\r\n    o2 = Normalizer.normalize(o2, Normalizer.Form.NFD);\r\n    return o1.compareTo(o2);\r\n});\r\n```","```\r\n@Test\r\nvoid givenListOfStrinsWithAccent_whenComparatorWithNormalizer_thenListIsNormalizedAndSorted() {\r\n    List<String> accentedStrings = Arrays.asList(\"único\", \"árbol\", \"cosas\", \"fútbol\");\r\n\r\n    List<String> naturalOrderSorted = Arrays.asList(\"cosas\", \"fútbol\", \"árbol\", \"único\");\r\n    List<String> stripAccentSorted = Arrays.asList(\"árbol\",\"cosas\", \"fútbol\",\"único\");\r\n\r\n    Collections.sort(accentedStrings);\r\n    assertThat(accentedStrings).isEqualTo(naturalOrderSorted);\r\n    Collections.sort(accentedStrings, Comparator.comparing(input -> StringUtils.stripAccents(input)));\r\n    assertThat(accentedStrings).isEqualTostripAccentSorted); \r\n}\r\n```","```\r\n@Test\r\nvoid givenListofStrings_whenUsingRuleBasedCollator_then ListIsSortedUsingRuleBasedCollator() throws ParseException {\r\n    List<String> movieNames = Arrays.asList(\r\n      \"Godzilla\",\"AmazingSpiderMan\",\"Smurfs\", \"Minions\");\r\n\r\n    List<String> naturalOrderExpected = Arrays.asList(\r\n      \"AmazingSpiderMan\", \"Godzilla\", \"Minions\", \"Smurfs\");\r\n    Collections.sort(movieNames);\r\n\r\n    List<String> rulesBasedExpected = Arrays.asList(\r\n      \"Smurfs\", \"Minions\", \"AmazingSpiderMan\", \"Godzilla\");\r\n\r\n    assertThat(movieNames).isEqualTo(naturalOrderExpected);\r\n\r\n    String rule = \"< s, S < m, M < a, A < g, G\";\r\n\r\n    RuleBasedCollator rulesCollator = new RuleBasedCollator(rule);\r\n    movieNames.sort(rulesCollator);\r\n\r\n    assertThat(movieNames).isEqualTo(rulesBasedExpected); } \r\n```"]