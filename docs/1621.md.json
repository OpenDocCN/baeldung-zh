["```\r\n<dependency>\r\n    <groupId>org.modelmapper</groupId>\r\n    <artifactId>modelmapper</artifactId>\r\n    <version>2.4.4</version>\r\n</dependency>\r\n```","```\r\npublic class Game {\r\n\r\n    private Long id;\r\n    private String name;\r\n    private Long timestamp;\r\n\r\n    private Player creator;\r\n    private List<Player> players = new ArrayList<>();\r\n\r\n    private GameSettings settings;\r\n\r\n    // constructors, getters and setters\r\n}\r\n\r\npublic class GameDTO {\r\n\r\n    private Long id;\r\n    private String name;\r\n\r\n    // constructors, getters and setters\r\n}\r\n```","```\r\n@BeforeEach\r\npublic void setup() {\r\n    this.mapper = new ModelMapper();\r\n}\r\n\r\n@Test\r\npublic void whenMapGameWithExactMatch_thenConvertsToDTO() {\r\n    // when similar source object is provided\r\n    Game game = new Game(1L, \"Game 1\");\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then it maps by default\r\n    assertEquals(game.getId(), gameDTO.getId());\r\n    assertEquals(game.getName(), gameDTO.getName());\r\n}\r\n```","```\r\npublic class GameDTO {\r\n\r\n    private Long id;\r\n    private String name;\r\n    private Long creationTime;\r\n\r\n    // constructors, getters and setters\r\n}\r\n```","```\r\n@Test\r\npublic void whenMapGameWithBasicPropertyMapping_thenConvertsToDTO() {\r\n    // setup\r\n    TypeMap<Game, GameDTO> propertyMapper = this.mapper.createTypeMap(Game.class, GameDTO.class);\r\n    propertyMapper.addMapping(Game::getTimestamp, GameDTO::setCreationTime);\r\n\r\n    // when field names are different\r\n    Game game = new Game(1L, \"Game 1\");\r\n    game.setTimestamp(Instant.now().getEpochSecond());\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then it maps via property mapper\r\n    assertEquals(game.getId(), gameDTO.getId());\r\n    assertEquals(game.getName(), gameDTO.getName());\r\n    assertEquals(game.getTimestamp(), gameDTO.getCreationTime());\r\n}\r\n```","```\r\npublic class Player {\r\n\r\n    private Long id;\r\n    private String name;\r\n\r\n    // constructors, getters and setters\r\n}\r\n\r\npublic class Game {\r\n    // ...\r\n\r\n    private Player creator;\r\n\r\n    // ...\r\n}\r\n\r\npublic class GameDTO {\r\n    // ...\r\n\r\n    private String creator;\r\n\r\n    // ...\r\n}\r\n```","```\r\n@Test\r\npublic void whenMapGameWithDeepMapping_thenConvertsToDTO() {\r\n    // setup\r\n    TypeMap<Game, GameDTO> propertyMapper = this.mapper.createTypeMap(Game.class, GameDTO.class);\r\n    // add deep mapping to flatten source's Player object into a single field in destination\r\n    propertyMapper.addMappings(\r\n      mapper -> mapper.map(src -> src.getCreator().getName(), GameDTO::setCreator)\r\n    );\r\n\r\n    // when map between different hierarchies\r\n    Game game = new Game(1L, \"Game 1\");\r\n    game.setCreator(new Player(1L, \"John\"));\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then\r\n    assertEquals(game.getCreator().getName(), gameDTO.getCreator());\r\n}\r\n```","```\r\n@Test\r\npublic void whenMapGameWithSkipIdProperty_thenConvertsToDTO() {\r\n    // setup\r\n    TypeMap<Game, GameDTO> propertyMapper = this.mapper.createTypeMap(Game.class, GameDTO.class);\r\n    propertyMapper.addMappings(mapper -> mapper.skip(GameDTO::setId));\r\n\r\n    // when id is skipped\r\n    Game game = new Game(1L, \"Game 1\");\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then destination id is null\r\n    assertNull(gameDTO.getId());\r\n    assertEquals(game.getName(), gameDTO.getName());\r\n}\r\n```","```\r\npublic class GameDTO {\r\n    // ...\r\n\r\n    private int totalPlayers;\r\n\r\n    // constructors, getters and setters\r\n}\r\n```","```\r\nConverter<Collection, Integer> collectionToSize = c -> c.getSource().size();\r\n```","```\r\npropertyMapper.addMappings(\r\n  mapper -> mapper.using(collectionToSize).map(Game::getPlayers, GameDTO::setTotalPlayers)\r\n);\r\n```","```\r\n@Test\r\npublic void whenMapGameWithCustomConverter_thenConvertsToDTO() {\r\n    // setup\r\n    TypeMap<Game, GameDTO> propertyMapper = this.mapper.createTypeMap(Game.class, GameDTO.class);\r\n    Converter<Collection, Integer> collectionToSize = c -> c.getSource().size();\r\n    propertyMapper.addMappings(\r\n      mapper -> mapper.using(collectionToSize).map(Game::getPlayers, GameDTO::setTotalPlayers)\r\n    );\r\n\r\n    // when collection to size converter is provided\r\n    Game game = new Game();\r\n    game.addPlayer(new Player(1L, \"John\"));\r\n    game.addPlayer(new Player(2L, \"Bob\"));\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then it maps the size to a custom field\r\n    assertEquals(2, gameDTO.getTotalPlayers());\r\n}\r\n```","```\r\n@Test\r\npublic void whenUsingProvider_thenMergesGameInstances() {\r\n    // setup\r\n    TypeMap<Game, Game> propertyMapper = this.mapper.createTypeMap(Game.class, Game.class);\r\n    // a provider to fetch a Game instance from a repository\r\n    Provider<Game> gameProvider = p -> this.gameRepository.findById(1L);\r\n    propertyMapper.setProvider(gameProvider);\r\n\r\n    // when a state for update is given\r\n    Game update = new Game(1L, \"Game Updated!\");\r\n    update.setCreator(new Player(1L, \"John\"));\r\n    Game updatedGame = this.mapper.map(update, Game.class);\r\n\r\n    // then it merges the updates over on the provided instance\r\n    assertEquals(1L, updatedGame.getId().longValue());\r\n    assertEquals(\"Game Updated!\", updatedGame.getName());\r\n    assertEquals(\"John\", updatedGame.getCreator().getName());\r\n}\r\n```","```\r\n@Test\r\npublic void whenUsingConditionalIsNull_thenMergesGameInstancesWithoutOverridingId() {\r\n    // setup\r\n    TypeMap<Game, Game> propertyMapper = this.mapper.createTypeMap(Game.class, Game.class);\r\n    propertyMapper.setProvider(p -> this.gameRepository.findById(2L));\r\n    propertyMapper.addMappings(mapper -> mapper.when(Conditions.isNull()).skip(Game::getId, Game::setId));\r\n\r\n    // when game has no id\r\n    Game update = new Game(null, \"Not Persisted Game!\");\r\n    Game updatedGame = this.mapper.map(update, Game.class);\r\n\r\n    // then destination game id is not overwritten\r\n    assertEquals(2L, updatedGame.getId().longValue());\r\n    assertEquals(\"Not Persisted Game!\", updatedGame.getName());\r\n}\r\n```","```\r\nCondition<Long, Long> hasTimestamp = ctx -> ctx.getSource() != null && ctx.getSource() > 0;\r\n```","```\r\nTypeMap<Game, GameDTO> propertyMapper = this.mapper.createTypeMap(Game.class, GameDTO.class);\r\nCondition<Long, Long> hasTimestamp = ctx -> ctx.getSource() != null && ctx.getSource() > 0;\r\npropertyMapper.addMappings(\r\n  mapper -> mapper.when(hasTimestamp).map(Game::getTimestamp, GameDTO::setCreationTime)\r\n);\r\n```","```\r\n@Test\r\npublic void whenUsingCustomConditional_thenConvertsDTOSkipsZeroTimestamp() {\r\n    // setup\r\n    TypeMap<Game, GameDTO> propertyMapper = this.mapper.createTypeMap(Game.class, GameDTO.class);\r\n    Condition<Long, Long> hasTimestamp = ctx -> ctx.getSource() != null && ctx.getSource() > 0;\r\n    propertyMapper.addMappings(\r\n      mapper -> mapper.when(hasTimestamp).map(Game::getTimestamp, GameDTO::setCreationTime)\r\n    );\r\n\r\n    // when game has zero timestamp\r\n    Game game = new Game(1L, \"Game 1\");\r\n    game.setTimestamp(0L);\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then timestamp field is not mapped\r\n    assertEquals(game.getId(), gameDTO.getId());\r\n    assertEquals(game.getName(), gameDTO.getName());\r\n    assertNotEquals(0L ,gameDTO.getCreationTime());\r\n\r\n    // when game has timestamp greater than zero\r\n    game.setTimestamp(Instant.now().getEpochSecond());\r\n    gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then timestamp field is mapped\r\n    assertEquals(game.getId(), gameDTO.getId());\r\n    assertEquals(game.getName(), gameDTO.getName());\r\n    assertEquals(game.getTimestamp() ,gameDTO.getCreationTime());\r\n}\r\n```","```\r\npublic class GameDTO {\r\n    //...\r\n\r\n    private GameMode mode;\r\n    private int maxPlayers;\r\n\r\n    // constructors, getters and setters\r\n}\r\n```","```\r\npublic class GameSettings {\r\n\r\n    private GameMode mode;\r\n    private int maxPlayers;\r\n\r\n    // constructors, getters and setters\r\n}\r\n```","```\r\n@Test\r\npublic void whenUsingLooseMappingStrategy_thenConvertsToDomainAndDTO() {\r\n    // setup\r\n    this.mapper.getConfiguration().setMatchingStrategy(MatchingStrategies.LOOSE);\r\n\r\n    // when dto has flat fields for GameSetting\r\n    GameDTO gameDTO = new GameDTO();\r\n    gameDTO.setMode(GameMode.TURBO);\r\n    gameDTO.setMaxPlayers(8);\r\n    Game game = this.mapper.map(gameDTO, Game.class);\r\n\r\n    // then it converts to inner objects without property mapper\r\n    assertEquals(gameDTO.getMode(), game.getSettings().getMode());\r\n    assertEquals(gameDTO.getMaxPlayers(), game.getSettings().getMaxPlayers());\r\n\r\n    // when the GameSetting's field names match\r\n    game = new Game();\r\n    game.setSettings(new GameSettings(GameMode.NORMAL, 6));\r\n    gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then it flattens the fields on dto\r\n    assertEquals(game.getSettings().getMode(), gameDTO.getMode());\r\n    assertEquals(game.getSettings().getMaxPlayers(), gameDTO.getMaxPlayers());\r\n}\r\n```","```\r\n@Test\r\npublic void whenConfigurationSkipNullEnabled_thenConvertsToDTO() {\r\n    // setup\r\n    this.mapper.getConfiguration().setSkipNullEnabled(true);\r\n    TypeMap<Game, Game> propertyMap = this.mapper.createTypeMap(Game.class, Game.class);\r\n    propertyMap.setProvider(p -> this.gameRepository.findById(2L));\r\n\r\n    // when game has no id\r\n    Game update = new Game(null, \"Not Persisted Game!\");\r\n    Game updatedGame = this.mapper.map(update, Game.class);\r\n\r\n    // then destination game id is not overwritten\r\n    assertEquals(2L, updatedGame.getId().longValue());\r\n    assertEquals(\"Not Persisted Game!\", updatedGame.getName());\r\n}\r\n```","```\r\norg.modelmapper.MappingException: ModelMapper mapping errors:\r\n\r\n1) Error mapping com.bealdung.domain.Game to com.bealdung.dto.GameDTO\r\n\r\n1 error\r\n\t...\r\nCaused by: java.lang.StackOverflowError\r\n\t...\r\n```","```\r\n@Test\r\npublic void whenConfigurationPreferNestedPropertiesDisabled_thenConvertsCircularReferencedToDTO() {\r\n    // setup\r\n    this.mapper.getConfiguration().setPreferNestedProperties(false);\r\n\r\n    // when game has circular reference: Game -> Player -> Game\r\n    Game game = new Game(1L, \"Game 1\");\r\n    Player player = new Player(1L, \"John\");\r\n    player.setCurrentGame(game);\r\n    game.setCreator(player);\r\n    GameDTO gameDTO = this.mapper.map(game, GameDTO.class);\r\n\r\n    // then it resolves without any exception\r\n    assertEquals(game.getId(), gameDTO.getId());\r\n    assertEquals(game.getName(), gameDTO.getName());\r\n}\r\n```"]