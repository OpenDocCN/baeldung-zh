["```\r\narrayIndex = sequence % capacity \r\n```","```\r\nbuffer[++writeSequence % capacity] = element \r\n```","```\r\nelement = buffer[readSequence++ % capacity] \r\n```","```\r\nsize = (writeSequence - readSequence) + 1\r\nisFull = (size == capacity) \r\n```","```\r\nisEmpty = writeSequence < readSequence \r\n```","```\r\npublic CircularBuffer(int capacity) {\r\n    this.capacity = (capacity < 1) ? DEFAULT_CAPACITY : capacity;\r\n    this.data = (E[]) new Object[this.capacity];\r\n    this.readSequence = 0;\r\n    this.writeSequence = -1;\r\n} \r\n```","```\r\npublic boolean offer(E element) {\r\n    boolean isFull = (writeSequence - readSequence) + 1 == capacity;\r\n    if (!isFull) {\r\n        int nextWriteSeq = writeSequence + 1;\r\n        data[nextWriteSeq % capacity] = element;\r\n        writeSequence++;\r\n        return true;\r\n    }\r\n    return false;\r\n} \r\n```","```\r\n@Test\r\npublic void givenCircularBuffer_whenAnElementIsEnqueued_thenSizeIsOne() {\r\n    CircularBuffer buffer = new CircularBuffer<>(defaultCapacity);\r\n\r\n    assertTrue(buffer.offer(\"Square\"));\r\n    assertEquals(1, buffer.size());\r\n} \r\n```","```\r\npublic E poll() {\r\n    boolean isEmpty = writeSequence < readSequence;\r\n    if (!isEmpty) {\r\n        E nextValue = data[readSequence % capacity];\r\n        readSequence++;\r\n        return nextValue;\r\n    }\r\n    return null;\r\n} \r\n```","```\r\n@Test\r\npublic void givenCircularBuffer_whenAnElementIsDequeued_thenElementMatchesEnqueuedElement() {\r\n    CircularBuffer buffer = new CircularBuffer<>(defaultCapacity);\r\n    buffer.offer(\"Triangle\");\r\n    String shape = buffer.poll();\r\n\r\n    assertEquals(\"Triangle\", shape);\r\n} \r\n```","```\r\nprivate volatile int writeSequence = -1, readSequence = 0; \r\n```","```\r\npublic void run() {\r\n    for (int i = 0; i < items.length;) {\r\n        if (buffer.offer(items[i])) {\r\n           System.out.println(\"Produced: \" + items[i]);\r\n            i++;\r\n        }\r\n    }\r\n} \r\n```","```\r\npublic T[] call() {\r\n    T[] items = (T[]) new Object[expectedCount];\r\n    for (int i = 0; i < items.length;) {\r\n        T item = buffer.poll();\r\n        if (item != null) {\r\n            items[i++] = item;\r\n            System.out.println(\"Consumed: \" + item);\r\n        }\r\n    }\r\n    return items;\r\n} \r\n```","```\r\nexecutorService.submit(new Thread(new Producer<String>(buffer)));\r\nexecutorService.submit(new Thread(new Consumer<String>(buffer))); \r\n```","```\r\nProduced: Circle\r\nProduced: Triangle\r\n  Consumed: Circle\r\nProduced: Rectangle\r\n  Consumed: Triangle\r\n  Consumed: Rectangle\r\nProduced: Square\r\nProduced: Rhombus\r\n  Consumed: Square\r\nProduced: Trapezoid\r\n  Consumed: Rhombus\r\n  Consumed: Trapezoid\r\nProduced: Pentagon\r\nProduced: Pentagram\r\nProduced: Hexagon\r\n  Consumed: Pentagon\r\n  Consumed: Pentagram\r\nProduced: Hexagram\r\n  Consumed: Hexagon\r\n  Consumed: Hexagram \r\n```"]