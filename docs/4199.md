# JVM、JRE 和 JDK 之间的区别

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/jvm-vs-jre-vs-jdk>

## **1。概述**

在本文中，我们将通过考虑 JVM、JRE 和 JDK 的组件和用途来讨论它们之间的区别。

## **2。JVM**

Java 虚拟机(JVM)是执行 Java 程序的虚拟机的实现。

JVM 首先解释字节码。然后，它将类别信息存储在内存区域中。最后，它执行 java 编译器生成的字节码。

它是一个抽象的计算机器，有自己的指令集，并在运行时操作各种内存区域。

JVM 的组件包括:

*   类装入器
*   运行时数据区
*   执行引擎

### **2.1。类别加载器**

JVM 的初始任务包括加载、验证和链接字节码。类装入器处理这些任务。

我们有一篇关于[类加载器](/web/20220603210924/https://www.baeldung.com/java-classloaders)的详细文章。

### **2.2。运行时数据区**

JVM 定义了各种内存区域来执行 Java 程序。这些在运行时使用，被称为运行时数据区。其中一些区域在 JVM 启动时创建，在 JVM 退出时销毁，而一些区域在线程创建时创建，在线程退出时销毁。

让我们逐一考虑这些领域:

**法区**

基本上，方法区域类似于编译代码的存储区域。它存储运行时常量池、字段和方法数据、方法和构造函数的代码以及完全限定的类名等结构。JVM 为每个类存储这些结构。

方法区域，也称为永久生成空间(PermGen)，是在 JVM 启动时创建的。这个区域的内存不需要连续。所有的 JVM 线程共享这个内存区域。

**堆区**

JVM 从这个区域为所有的类实例和数组分配内存。

垃圾收集器(GC)回收对象的堆内存。基本上，GC 有三个阶段从对象中回收内存，即。两个次要 GC 和一个主要 GC。

堆内存有三个部分:

*   伊甸园空间——它是年轻一代空间的一部分。当我们创建一个对象时，JVM 从这个空间分配内存
*   幸存者空间——它也是年轻一代空间的一部分。幸存者空间包含在 GC 的次要 GC 阶段幸存下来的现有对象
*   终身空间——这也被称为老一代空间。它保存着长期保存的物品。基本上，为年轻一代对象设置一个阈值，当达到该阈值时，这些对象被移动到保有空间。

JVM 一启动就创建堆区。JVM 的所有线程共享这个区域。堆区域的内存不需要是连续的。

**堆栈区**

将数据存储为帧，每个帧存储局部变量、部分结果和嵌套方法调用。每当 JVM 创建一个新线程时，它就会创建堆栈区域。这个区域对于每个线程都是私有的。

堆栈中的每个条目都称为堆栈帧或激活记录。每个框架包含三个部分:

*   局部变量数组–包含方法的所有局部变量和参数
*   操作数堆栈–用作存储中间计算结果的工作空间
*   帧数据——用于存储部分结果、方法的返回值以及对`Exception`表的引用，该表在异常情况下提供相应的 catch 块信息

JVM 堆栈的内存不需要是连续的。

**PC 寄存器**

每个 JVM 线程都有一个单独的 PC 寄存器，用来存储当前正在执行的指令的地址。如果当前执行的指令是本机方法的一部分，则该值是未定义的。

**原生方法栈**

本地方法是那些用 Java 以外的语言编写的方法。

JVM 提供了调用这些本地方法的能力。本机方法堆栈也称为“C 堆栈”。它们存储本机方法信息。每当本机方法被编译成机器码时，它们通常使用本机方法堆栈来跟踪它们的状态。

每当 JVM 创建一个新线程时，就会创建这些堆栈。因此 JVM 线程不共享这个区域。

### **2.3。执行引擎**

执行引擎使用内存区域中的信息执行指令。它有三个部分:

**译员**

一旦类加载器加载并验证了字节码，解释器就逐行执行字节码。这个执行相当慢。解释器的缺点是，当一个方法被多次调用时，每次都需要新的解释。

然而，JVM 使用 JIT 编译器来减轻这个缺点。

**实时编译器**

JIT 编译器在运行时将经常调用的方法的字节码编译成本机代码。因此它负责 Java 程序的优化。

JVM 自动监视哪些方法正在被执行。一旦一个方法适合 JIT 编译，它就被安排编译成机器码。这种方法被称为热方法。这种编译成机器码的过程发生在一个单独的 JVM 线程上。

因此，它不会中断当前程序的执行。编译成机器码后，运行速度更快。

**垃圾收集器**

Java 使用垃圾收集来处理内存管理。这是一个查看堆内存、确定哪些对象正在使用、哪些没有使用，并最终删除未使用的对象的过程。

GC 是一个守护线程。可以使用`System.` gc `()`方法显式调用它，但是，它不会立即执行，而是由 JVM 决定何时调用 gc。

### **2.4。Java 本地接口**

它充当 Java 代码和本机(C/C++)库之间的接口。

有些情况下，Java 本身不能满足应用程序的需求，例如，实现一个平台相关的特性。

在这些情况下，我们可以使用 JNI 来使运行在 JVM 中的代码能够调用。相反，它使本地方法能够调用 JVM 中运行的代码。

### **2.5。本地库**

这些是特定于平台的库，包含本地方法的实现。

## **3。JRE**

Java 运行时环境(JRE)是一组用于运行 Java 应用程序的软件组件。

JRE 的核心组件包括:

*   Java 虚拟机(JVM)的实现
*   运行 Java 程序所需的类
*   属性文件

我们在上一节讨论了 JVM。这里我们将关注核心类和支持文件。

### **3.1。引导类**

我们将在`jre/lib/`下找到引导类。**这个路径也称为引导类路径。**它包括:

*   `rt.jar`中的运行时类
*   `i18n.jar`中的国际化类
*   `charsets.jar`中的字符转换类
*   其他人

当 JVM 启动时，Bootstrap ClassLoader 加载这些类。

### **3.2。扩展类**

我们可以在`jre/lib/extn/`中找到扩展类，它作为 Java 平台扩展的目录。**这个路径也称为扩展类路径。**

它在`jfxrt.jar`中包含 JavaFX 运行时库，在`localedata.jar`中包含`java.text`和`java.util`包的语言环境数据。用户还可以将定制的 jar 添加到这个目录中。

### **3.3。属性设置**

Java 平台使用这些属性设置来维护其配置。根据它们的用途，它们位于`/jre/lib/`内的不同文件夹中。其中包括:

*   `calendar.properties`中的日历配置
*   `logging.properties`中的记录配置
*   `net.properties`中的网络配置
*   `/jre/lib/deploy/`中的部署属性
*   `/jre/lib/management/`中的管理属性

### **3.4。其他文件**

除了上面提到的文件和类，JRE 还包含其他事务的文件:

*   `jre/lib/security`的安全管理
*   在`jre/lib/applet`放置小程序支持类的目录
*   `jre/lib/fonts`处的字体相关文件及其他

## **4。JDK**

Java 开发工具包(JDK)为开发、编译、调试和执行 Java 程序提供了环境和工具。

JDK 的核心组件包括:

*   Java 运行时环境
*   开发工具

我们在上一节讨论了 JRE。

现在，我们将关注各种开发工具。让我们根据这些工具的用途对它们进行分类:

### 4.1.基本工具

这些工具奠定了 JDK 的基础，用于创建和构建 Java 应用程序。在这些工具中，我们可以找到用于编译、调试、存档、生成 Javadocs 等的实用程序。

它们包括:

*   读取类和接口定义，并将它们编译成类文件
*   `java –`启动 Java 应用程序
*   从 Java 源文件生成 API 文档的 HTML 页面
*   `apt –`根据指定源文件集中的注释，查找并执行注释处理器
*   `appletviewer`–使我们无需网络浏览器即可运行 Java 小程序
*   将 Java 小程序或应用程序打包到一个归档文件中
*   一个命令行调试工具，用于查找和修复 Java 应用程序中的错误
*   从一个 Java 类产生 C 头文件和源文件
*   反汇编类文件并显示类文件中的字段、构造函数和方法的信息
*   `extcheck –`检测目标 Java 归档(JAR)文件和当前安装的扩展 JAR 文件之间的版本冲突

### 4.2.安全工具

这些工具包括用于操作 Java 密钥库的密钥和证书管理工具。

Java 密钥库是授权证书或公钥证书的容器。因此，它经常被基于 Java 的应用程序用于加密、认证和通过 HTTPS 提供服务。

此外，他们还帮助在我们的系统上设置安全策略，并在生产环境中创建可以在这些策略范围内工作的应用程序。其中包括:

*   `keytool –`帮助管理密钥库条目，即加密密钥和证书
*   `jarsigner –`使用密钥库信息生成数字签名的 JAR 文件
*   使我们能够管理定义安装安全策略的外部策略配置文件

一些安全工具也有助于管理 Kerberos 票据。

Kerberos 是一种网络身份验证协议。

它基于票证工作，允许通过非安全网络通信的节点以安全的方式相互证明自己的身份:

*   `kinit –`用于获取和缓存 Kerberos 票据授予票据
*   `ktab –`管理密钥表中的主体名称和密钥对
*   `klist –`显示本地凭据缓存和密钥表中的条目

### 4.3.国际化工具

国际化是设计一个应用程序的过程，以便它可以适应各种语言和地区，而无需进行工程更改。

**为此，JDK 带来了`native2ascii. `这个工具将带有 JRE 支持的字符的文件转换成以 ASCII 或 Unicode 转义编码的文件。**

### 4.4.远程方法调用(RMI)工具

RMI 工具支持 Java 应用程序之间的远程通信，从而为分布式应用程序的开发提供了空间。

RMI 允许在一个 JVM 中运行的对象调用在另一个 JVM 中运行的对象的方法。这些工具包括:

*   使用 Java 远程方法协议(JRMP)或互联网 Orb 间协议(IIOP)为远程对象生成存根、框架和绑定类
*   `rmiregistry –`创建并启动远程对象注册表
*   启动激活系统守护程序。这允许在 Java 虚拟机中注册和激活对象
*   `serialver –`返回指定类的串行版本 UID

### 4.5.Java IDL 和 RMI-IIOP 工具

Java 接口定义语言(IDL)为 Java 平台增加了通用的基于对象的请求代理架构(CORBA)功能。

这些工具使分布式 Java web 应用程序能够使用行业标准对象管理组(OMG)-IDL 调用远程网络服务上的操作。

同样，我们可以使用互联网 InterORB 协议(IIOP)。

RMI-IIOP，即 IIOP 上的 RMI 允许通过 RMI API 对 CORBA 服务器和应用程序进行编程。从而使得以任何符合 CORBA 的语言编写的两个应用程序之间能够通过因特网 InterORB 协议(IIOP)进行连接。

这些工具包括:

*   `tnameserv –`临时命名服务，为对象引用提供一个树形结构的目录
*   IDL-to-Java 编译器，用于为指定的 IDL 文件生成 Java 绑定
*   使客户机能够在 CORBA 环境中透明地定位和调用服务器上的持久对象
*   `servertool –`提供命令行界面，用于向 ORB 守护进程(`orbd`)注册或取消注册持久性服务器，启动和关闭向 ORB 守护进程注册的持久性服务器，等等

### 4.6.Java 部署工具

这些工具有助于在网络上部署 Java 应用程序和小应用程序。它们包括:

*   `pack200 –` 使用 Java `gzip`压缩器将一个 JAR 文件转换成一个`pack200`文件
*   `unpack200 –` 将`pack200`文件转换成 JAR 文件

### 4.7.Java 插件工具

**JDK 为我们提供了`htmlconverter.` 此外，它还与 Java 插件结合使用。**

一方面，Java 插件在流行的浏览器和 Java 平台之间建立了连接。由于这种连接，网站上的小程序可以在浏览器中运行。

另一方面，`htmlconverter` 是一个将包含小程序的 HTML 页面转换成 Java 插件格式的实用程序。

### 4.8.Java Web 启动工具

JDK 带来了`javaws. `我们可以结合 Java Web Start 使用它。

这个工具让我们只需在浏览器上点击一下，就可以下载并启动 Java 应用程序。因此，不需要运行任何安装过程。

### 4.9.监控和管理工具

这些都是很棒的工具，我们可以用它们来监控 JVM 的性能和资源消耗。以下是一些例子:

*   `jconsole –` 提供一个图形控制台，让您监控和管理 Java 应用程序
*   `jps –` 列出目标系统上被检测的 JVM
*   `jstat –` 监控 JVM 统计数据
*   `jstatd –` 监控被检测的 JVM 的创建和终止

### 4.10.故障排除工具

**这些是我们可以用于故障排除任务的实验工具**:

*   `info –`为指定的 Java 进程生成配置信息
*   打印指定进程的共享对象内存映射或堆内存细节
*   `jsadebugd –` 连接到 Java 进程并充当调试服务器
*   `jstack –` 打印给定 Java 进程的 Java 线程的 Java 堆栈跟踪

## **5。结论**

在本文中，我们确定了 JVM、JRE 和 JDK 之间的基本区别在于它们的用法。

首先，我们描述了 JVM 是如何实际执行 Java 字节码的抽象计算机器。

然后，我们解释了如何运行 Java 应用程序，我们使用 JRE。

最后，我们知道如何开发 Java 应用程序，我们使用 JDK。

我们还花了一些时间深入研究该组件的工具和基本概念。