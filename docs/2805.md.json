["```\r\n<dependency>\r\n    <groupId>org.apache.flink</groupId>\r\n    <artifactId>flink-java</artifactId>\r\n    <version>1.2.0</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.apache.flink</groupId>\r\n    <artifactId>flink-test-utils_2.10</artifactId>\r\n    <version>1.2.0</version>\r\n    <scope>test<scope>\r\n</dependency>\r\n```","```\r\nExecutionEnvironment env\r\n  = ExecutionEnvironment.getExecutionEnvironment();\r\n```","```\r\nDataSet<Integer> amounts = env.fromElements(1, 29, 40, 50);\r\n```","```\r\nint threshold = 30;\r\nList<Integer> collect = amounts\r\n  .filter(a -> a > threshold)\r\n  .reduce((integer, t1) -> integer + t1)\r\n  .collect();\r\n\r\nassertThat(collect.get(0)).isEqualTo(90); \r\n```","```\r\nprivate static class Person {\r\n    private int age;\r\n    private String name;\r\n\r\n    // standard constructors/getters/setters\r\n}\r\n```","```\r\nDataSet<Person> personDataSource = env.fromCollection(\r\n  Arrays.asList(\r\n    new Person(23, \"Tom\"),\r\n    new Person(75, \"Michael\")));\r\n```","```\r\nList<Integer> ages = personDataSource\r\n  .map(p -> p.age)\r\n  .collect();\r\n\r\nassertThat(ages).hasSize(2);\r\nassertThat(ages).contains(23, 75);\r\n```","```\r\nTuple3<Integer, String, String> address\r\n  = new Tuple3<>(1, \"5th Avenue\", \"London\");\r\nDataSet<Tuple3<Integer, String, String>> addresses\r\n  = env.fromElements(address);\r\n\r\nTuple2<Integer, String> firstTransaction \r\n  = new Tuple2<>(1, \"Transaction_1\");\r\nDataSet<Tuple2<Integer, String>> transactions \r\n  = env.fromElements(firstTransaction, new Tuple2<>(12, \"Transaction_2\")); \r\n```","```\r\nprivate static class IdKeySelectorTransaction \r\n  implements KeySelector<Tuple2<Integer, String>, Integer> {\r\n    @Override\r\n    public Integer getKey(Tuple2<Integer, String> value) {\r\n        return value.f0;\r\n    }\r\n}\r\n\r\nprivate static class IdKeySelectorAddress \r\n  implements KeySelector<Tuple3<Integer, String, String>, Integer> {\r\n    @Override\r\n    public Integer getKey(Tuple3<Integer, String, String> value) {\r\n        return value.f0;\r\n    }\r\n}\r\n```","```\r\nList<Tuple2<Tuple2<Integer, String>, Tuple3<Integer, String, String>>>\r\n  joined = transactions.join(addresses)\r\n  .where(new IdKeySelectorTransaction())\r\n  .equalTo(new IdKeySelectorAddress())\r\n  .collect();\r\n\r\nassertThat(joined).hasSize(1);\r\nassertThat(joined).contains(new Tuple2<>(firstTransaction, address)); \r\n```","```\r\nTuple2<Integer, String> secondPerson = new Tuple2<>(4, \"Tom\");\r\nTuple2<Integer, String> thirdPerson = new Tuple2<>(5, \"Scott\");\r\nTuple2<Integer, String> fourthPerson = new Tuple2<>(200, \"Michael\");\r\nTuple2<Integer, String> firstPerson = new Tuple2<>(1, \"Jack\");\r\nDataSet<Tuple2<Integer, String>> transactions = env.fromElements(\r\n  fourthPerson, secondPerson, thirdPerson, firstPerson); \r\n```","```\r\nList<Tuple2<Integer, String>> sorted = transactions\r\n  .sortPartition(new IdKeySelectorTransaction(), Order.ASCENDING)\r\n  .collect();\r\n\r\nassertThat(sorted)\r\n  .containsExactly(firstPerson, secondPerson, thirdPerson, fourthPerson);\r\n```","```\r\npublic class LineSplitter implements FlatMapFunction<String, Tuple2<String, Integer>> {\r\n\r\n    @Override\r\n    public void flatMap(String value, Collector<Tuple2<String, Integer>> out) {\r\n        Stream.of(value.toLowerCase().split(\"\\\\W+\"))\r\n          .filter(t -> t.length() > 0)\r\n          .forEach(token -> out.collect(new Tuple2<>(token, 1)));\r\n    }\r\n}\r\n```","```\r\npublic static DataSet<Tuple2<String, Integer>> startWordCount(\r\n  ExecutionEnvironment env, List<String> lines) throws Exception {\r\n    DataSet<String> text = env.fromCollection(lines);\r\n\r\n    return text.flatMap(new LineSplitter())\r\n      .groupBy(0)\r\n      .aggregate(Aggregations.SUM, 1);\r\n}\r\n```","```\r\nList<String> lines = Arrays.asList(\r\n  \"This is a first sentence\",\r\n  \"This is a second sentence with a one word\");\r\n\r\nDataSet<Tuple2<String, Integer>> result = WordCount.startWordCount(env, lines);\r\n\r\nList<Tuple2<String, Integer>> collect = result.collect();\r\n\r\nassertThat(collect).containsExactlyInAnyOrder(\r\n  new Tuple2<>(\"a\", 3), new Tuple2<>(\"sentence\", 2), new Tuple2<>(\"word\", 1),\r\n  new Tuple2<>(\"is\", 2), new Tuple2<>(\"this\", 2), new Tuple2<>(\"second\", 1),\r\n  new Tuple2<>(\"first\", 1), new Tuple2<>(\"with\", 1), new Tuple2<>(\"one\", 1));\r\n```","```\r\nStreamExecutionEnvironment executionEnvironment\r\n = StreamExecutionEnvironment.getExecutionEnvironment();\r\n```","```\r\nDataStream<String> dataStream = executionEnvironment.fromElements(\r\n  \"This is a first sentence\", \r\n  \"This is a second sentence with a one word\");\r\n```","```\r\nSingleOutputStreamOperator<String> upperCase = text.map(String::toUpperCase);\r\n```","```\r\nupperCase.print();\r\nenv.execute();\r\n```","```\r\n1> THIS IS A FIRST SENTENCE\r\n2> THIS IS A SECOND SENTENCE WITH A ONE WORD\r\n```","```\r\nSingleOutputStreamOperator<Tuple2<Integer, Long>> windowed\r\n  = env.fromElements(\r\n  new Tuple2<>(16, ZonedDateTime.now().plusMinutes(25).toInstant().getEpochSecond()),\r\n  new Tuple2<>(15, ZonedDateTime.now().plusMinutes(2).toInstant().getEpochSecond()))\r\n  .assignTimestampsAndWatermarks(\r\n    new BoundedOutOfOrdernessTimestampExtractor\r\n      <Tuple2<Integer, Long>>(Time.seconds(20)) {\r\n\r\n        @Override\r\n        public long extractTimestamp(Tuple2<Integer, Long> element) {\r\n          return element.f1 * 1000;\r\n        }\r\n    });\r\n```","```\r\nSingleOutputStreamOperator<Tuple2<Integer, Long>> reduced = windowed\r\n  .windowAll(TumblingEventTimeWindows.of(Time.seconds(5)))\r\n  .maxBy(0, true);\r\nreduced.print();\r\n```","```\r\n1> (15,1491221519)\r\n```"]