["```\r\n<dependency>\r\n    <groupId>com.amazonaws</groupId>\r\n    <artifactId>amazon-kinesis-client</artifactId>\r\n    <version>1.11.2</version>\r\n</dependency>\r\n```","```\r\n@Bean\r\npublic AmazonKinesis buildAmazonKinesis() {\r\n    BasicAWSCredentials awsCredentials = new BasicAWSCredentials(accessKey, secretKey);\r\n    return AmazonKinesisClientBuilder.standard()\r\n      .withCredentials(new AWSStaticCredentialsProvider(awsCredentials))\r\n      .withRegion(Regions.EU_CENTRAL_1)\r\n      .build();\r\n}\r\n```","```\r\naws.access.key=my-aws-access-key-goes-here\r\naws.secret.key=my-aws-secret-key-goes-here\r\n```","```\r\n@Value(\"${aws.access.key}\")\r\nprivate String accessKey;\r\n\r\n@Value(\"${aws.secret.key}\")\r\nprivate String secretKey;\r\n```","```\r\nGetRecordsRequest recordsRequest = new GetRecordsRequest();\r\nrecordsRequest.setShardIterator(shardIterator.getShardIterator());\r\nrecordsRequest.setLimit(25);\r\n\r\nGetRecordsResult recordsResult = kinesis.getRecords(recordsRequest);\r\nwhile (!recordsResult.getRecords().isEmpty()) {\r\n    recordsResult.getRecords().stream()\r\n      .map(record -> new String(record.getData().array()))\r\n      .forEach(System.out::println);\r\n\r\n    recordsRequest.setShardIterator(recordsResult.getNextShardIterator());\r\n    recordsResult = kinesis.getRecords(recordsRequest);\r\n}\r\n```","```\r\nprivate GetShardIteratorResult shardIterator;\r\n\r\n@PostConstruct\r\nprivate void buildShardIterator() {\r\n    GetShardIteratorRequest readShardsRequest = new GetShardIteratorRequest();\r\n    readShardsRequest.setStreamName(IPS_STREAM);\r\n    readShardsRequest.setShardIteratorType(ShardIteratorType.LATEST);\r\n    readShardsRequest.setShardId(IPS_SHARD_ID);\r\n\r\n    this.shardIterator = kinesis.getShardIterator(readShardsRequest);\r\n}\r\n```","```\r\nList<PutRecordsRequestEntry> entries = IntStream.range(1, 200).mapToObj(ipSuffix -> {\r\n    PutRecordsRequestEntry entry = new PutRecordsRequestEntry();\r\n    entry.setData(ByteBuffer.wrap((\"192.168.0.\" + ipSuffix).getBytes()));\r\n    entry.setPartitionKey(IPS_PARTITION_KEY);\r\n    return entry;\r\n}).collect(Collectors.toList());\r\n\r\nPutRecordsRequest createRecordsRequest = new PutRecordsRequest();\r\ncreateRecordsRequest.setStreamName(IPS_STREAM);\r\ncreateRecordsRequest.setRecords(entries);\r\n\r\nkinesis.putRecords(createRecordsRequest);\r\n```","```\r\n<dependency>\r\n    <groupId>com.amazonaws</groupId>\r\n    <artifactId>amazon-kinesis-producer</artifactId>\r\n    <version>0.13.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>com.amazonaws</groupId>\r\n    <artifactId>amazon-kinesis-client</artifactId>\r\n    <version>1.11.2</version>\r\n</dependency>\r\n```","```\r\npublic class IpProcessor implements IRecordProcessor {\r\n    @Override\r\n    public void initialize(InitializationInput initializationInput) { }\r\n\r\n    @Override\r\n    public void processRecords(ProcessRecordsInput processRecordsInput) {\r\n        processRecordsInput.getRecords()\r\n          .forEach(record -> System.out.println(new String(record.getData().array())));\r\n    }\r\n\r\n    @Override\r\n    public void shutdown(ShutdownInput shutdownInput) { }\r\n}\r\n```","```\r\npublic class IpProcessorFactory implements IRecordProcessorFactory {\r\n    @Override\r\n    public IRecordProcessor createProcessor() {\r\n        return new IpProcessor();\r\n    }\r\n}\r\n```","```\r\nBasicAWSCredentials awsCredentials = new BasicAWSCredentials(accessKey, secretKey);\r\nKinesisClientLibConfiguration consumerConfig = new KinesisClientLibConfiguration(\r\n  APP_NAME, \r\n  IPS_STREAM,\r\n  new AWSStaticCredentialsProvider(awsCredentials), \r\n  IPS_WORKER)\r\n    .withRegionName(Regions.EU_CENTRAL_1.getName());\r\n\r\nfinal Worker worker = new Worker.Builder()\r\n  .recordProcessorFactory(new IpProcessorFactory())\r\n  .config(consumerConfig)\r\n  .build();\r\nCompletableFuture.runAsync(worker.run());\r\n```","```\r\nBasicAWSCredentials awsCredentials = new BasicAWSCredentials(accessKey, secretKey);\r\nKinesisProducerConfiguration producerConfig = new KinesisProducerConfiguration()\r\n  .setCredentialsProvider(new AWSStaticCredentialsProvider(awsCredentials))\r\n  .setVerifyCertificate(false)\r\n  .setRegion(Regions.EU_CENTRAL_1.getName());\r\n\r\nthis.kinesisProducer = new KinesisProducer(producerConfig);\r\n```","```\r\nIntStream.range(1, 200).mapToObj(ipSuffix -> ByteBuffer.wrap((\"192.168.0.\" + ipSuffix).getBytes()))\r\n  .forEach(entry -> kinesisProducer.addUserRecord(IPS_STREAM, IPS_PARTITION_KEY, entry));\r\n```","```\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-stream-binder-kinesis</artifactId>\r\n    <version>1.2.1.RELEASE</version>\r\n</dependency>\r\n```","```\r\ncloud.aws.credentials.access-key=my-aws-access-key\r\ncloud.aws.credentials.secret-key=my-aws-secret-key\r\ncloud.aws.region.static=eu-central-1\r\ncloud.aws.stack.auto=false\r\n```","```\r\nspring.cloud.stream.bindings.input.destination=live-ips\r\nspring.cloud.stream.bindings.input.group=live-ips-group\r\nspring.cloud.stream.bindings.input.content-type=text/plain\r\n```","```\r\n@EnableBinding(Sink.class)\r\npublic class IpConsumer {\r\n\r\n    @StreamListener(Sink.INPUT)\r\n    public void consume(String ip) {\r\n        System.out.println(ip);\r\n    }\r\n}\r\n```","```\r\nspring.cloud.stream.bindings.output.destination=live-ips\r\nspring.cloud.stream.bindings.output.content-type=text/plain\r\n```","```\r\n@Component\r\n@EnableBinding(Source.class)\r\npublic class IpProducer {\r\n\r\n    @Autowired\r\n    private Source source;\r\n\r\n    @Scheduled(fixedDelay = 3000L)\r\n    private void produce() {\r\n        IntStream.range(1, 200).mapToObj(ipSuffix -> \"192.168.0.\" + ipSuffix)\r\n          .forEach(entry -> source.output().send(MessageBuilder.withPayload(entry).build()));\r\n    }\r\n}\r\n```"]