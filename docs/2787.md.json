["```\r\npublic class ConcurrentStack<E> {\r\n\r\n    AtomicReference<Node<E>> top = new AtomicReference<Node<E>>();\r\n\r\n    private static class Node <E> {\r\n        public E item;\r\n        public Node<E> next;\r\n\r\n        // standard constructor\r\n    }\r\n}\r\n```","```\r\npublic void push(E item){\r\n    Node<E> newHead = new Node<E>(item);\r\n    Node<E> oldHead;\r\n\r\n    do {\r\n        oldHead = top.get();\r\n        newHead.next = oldHead;\r\n    } while(!top.compareAndSet(oldHead, newHead));\r\n}\r\n\r\npublic E pop() {\r\n    Node<E> oldHead;\r\n    Node<E> newHead;\r\n    do {\r\n        oldHead = top.get();\r\n        if (oldHead == null) {\r\n            return null;\r\n        }\r\n        newHead = oldHead.next;\r\n    } while (!top.compareAndSet(oldHead, newHead));\r\n\r\n    return oldHead.item;\r\n}\r\n```","```\r\n<dependency>\r\n    <groupId>org.jctools</groupId>\r\n    <artifactId>jctools-core</artifactId>\r\n    <version>2.1.2</version>\r\n</dependency>\r\n```","```\r\nSpscArrayQueue<Integer> queue = new SpscArrayQueue<>(2);\r\n\r\nThread producer1 = new Thread(() -> queue.offer(1));\r\nproducer1.start();\r\nproducer1.join();\r\n\r\nThread producer2 = new Thread(() -> queue.offer(2));\r\nproducer2.start();\r\nproducer2.join();\r\n\r\nSet<Integer> fromQueue = new HashSet<>();\r\nThread consumer = new Thread(() -> queue.drain(fromQueue::add));\r\nconsumer.start();\r\nconsumer.join();\r\n\r\nassertThat(fromQueue).containsOnly(1, 2);\r\n```","```\r\nSpscChunkedArrayQueue<Integer> queue = new SpscChunkedArrayQueue<>(8, 16);\r\nCountDownLatch startConsuming = new CountDownLatch(1);\r\nCountDownLatch awakeProducer = new CountDownLatch(1);\r\n\r\nThread producer = new Thread(() -> {\r\n    IntStream.range(0, queue.capacity()).forEach(i -> {\r\n        assertThat(queue.offer(i)).isTrue();\r\n    });\r\n    assertThat(queue.offer(queue.capacity())).isFalse();\r\n    startConsuming.countDown();\r\n    awakeProducer.await();\r\n    assertThat(queue.offer(queue.capacity())).isTrue();\r\n});\r\n\r\nproducer.start();\r\nstartConsuming.await();\r\n\r\nSet<Integer> fromQueue = new HashSet<>();\r\nqueue.drain(fromQueue::add);\r\nawakeProducer.countDown();\r\nproducer.join();\r\nqueue.drain(fromQueue::add);\r\n\r\nassertThat(fromQueue).containsAll(\r\n  IntStream.range(0, 17).boxed().collect(toSet()));\r\n```","```\r\npublic class MpmcBenchmark {\r\n\r\n    @Param({PARAM_UNSAFE, PARAM_AFU, PARAM_JDK})\r\n    public volatile String implementation;\r\n\r\n    public volatile Queue<Long> queue;\r\n\r\n    @Benchmark\r\n    @Group(GROUP_NAME)\r\n    @GroupThreads(PRODUCER_THREADS_NUMBER)\r\n    public void write(Control control) {\r\n        // noinspection StatementWithEmptyBody\r\n        while (!control.stopMeasurement && !queue.offer(1L)) {\r\n            // intentionally left blank\r\n        }\r\n    }\r\n\r\n    @Benchmark\r\n    @Group(GROUP_NAME)\r\n    @GroupThreads(CONSUMER_THREADS_NUMBER)\r\n    public void read(Control control) {\r\n        // noinspection StatementWithEmptyBody\r\n        while (!control.stopMeasurement && queue.poll() == null) {\r\n            // intentionally left blank\r\n        }\r\n    }\r\n}\r\n```","```\r\nMpmcBenchmark.MyGroup:MyGroup·p0.95 MpmcArrayQueue sample 1052.000 ns/op\r\nMpmcBenchmark.MyGroup:MyGroup·p0.95 MpmcAtomicArrayQueue sample 1106.000 ns/op\r\nMpmcBenchmark.MyGroup:MyGroup·p0.95 ArrayBlockingQueue sample 2364.000 ns/op\r\n```"]