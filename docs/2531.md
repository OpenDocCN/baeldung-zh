# GC 会将内存释放回操作系统吗？

> 原文:[https://web . archive . org/web/20220930061024/https://www . bael dung . com/GC-release-memory](https://web.archive.org/web/20220930061024/https://www.baeldung.com/gc-release-memory)

## 1.介绍

[垃圾收集器(GC)](/web/20220524070404/https://www.baeldung.com/jvm-garbage-collectors) 处理 Java 中的内存管理。因此，程序员不需要显式地处理内存分配和释放。

在 Java 中，JVM 在开始时会预留一定的内存。有时，实际使用的内存明显少于保留的内存量。在这种情况下，我们更愿意将多余的内存归还给操作系统。

这整个过程依赖于用于垃圾收集的算法。因此，我们可以根据所需的行为选择 GC 和 JVM 的类型。

在本教程中，我们将探索 GC 的内存管理及其与操作系统的交互。

## 2.JVM 内存组织

JVM 初始化的时候，内部会创建不同类型的内存区域，比如[堆区、栈区、](/web/20220524070404/https://www.baeldung.com/java-stack-heap)方法区、PC 寄存器、原生方法栈。

GC 处理堆存储。因此，在本文中，我们将重点关注与堆相关的内存交互。

我们可以分别使用[标志](/web/20220524070404/https://www.baeldung.com/jvm-parameters) -Xms 和-Xmx 来指定初始和最大堆大小。如果-Xms 低于-Xmx，这意味着 JVM 在开始时没有将所有保留的内存提交给堆。简而言之，**堆大小从-Xms 开始，可以扩展到-Xmx** 。这允许开发人员配置所需堆内存的大小。

现在，当应用程序运行时，不同的对象在堆内被分配内存。在垃圾收集时，GC 释放未被引用的对象并释放内存。这个被释放的内存目前是堆本身的一部分，因为在每次释放后与操作系统交互是一个 CPU 密集型过程。

对象以分散的方式驻留在堆中。 **GC 需要压缩内存，创建一个空闲块返回 OS** 。它涉及到在返回内存时执行一个**额外的进程。此外，Java 应用程序在后期可能需要额外的内存。为此，**我们需要再次与操作系统沟通，请求更多内存**。此外，**我们不能确保在请求的时间**操作系统中内存的可用性。因此，使用内部堆而不是频繁调用操作系统来获取内存是一种更安全的方法。**

然而，如果我们的应用程序不需要整个堆内存，我们只是阻塞了可用的资源，这些资源本可以被操作系统用于其他应用程序。考虑到这一点，JVM 引入了高效的自动化内存释放技术。

## 3.垃圾收集者

随着不同发布版本的发展，Java 引入了不同类型的 GC。堆和操作系统之间的内存交互依赖于 JVM 和 GC 实现。一些 GC 实现积极支持堆收缩。**堆收缩是将多余的内存从堆中释放回操作系统以优化资源使用的过程。**

例如，并行 GC 不会轻易将未使用的内存释放回操作系统。另一方面，一些 **GCs 分析内存消耗，并据此决定从堆中释放一些空闲内存。** G1、Serial、[谢南多和 Z GCs](/web/20220524070404/https://www.baeldung.com/jvm-experimental-garbage-collectors) 支持堆收缩。

现在让我们来探索这些过程。

### 3.1.垃圾优先(G1) GC

从 Java 9 开始，G1 就是默认的 GC。它支持压缩过程，没有长时间的停顿。使用内部自适应优化算法，它**根据应用使用情况分析所需的 RAM，并在需要时取消提交内存**。

最初的实现支持在完全 GC 之后或者在并发循环事件期间进行堆收缩。然而，在理想情况下，我们希望及时将未使用的内存归还给操作系统，尤其是在应用程序空闲的时候。我们希望 GC 在运行时动态适应应用程序的内存使用。

Java 已经在不同的 GC 中包含了这样的功能。对于 G1， [JEP 346](https://web.archive.org/web/20220524070404/https://openjdk.java.net/jeps/346) 介绍了这些变化。从 Java 12 及更高版本开始，堆收缩在并发的[注释阶段](https://web.archive.org/web/20220524070404/http://hg.openjdk.java.net/jdk/jdk/rev/08041b0d7c08)也是可能的。**当应用程序空闲时，G1 会尝试分析堆的使用情况，并根据需要触发定期垃圾收集**。基于`G1PeriodicGCInvokesConcurrent`选项，G1 可以启动一个并发周期或一个完整的 GC。在循环执行之后，G1 需要调整堆的大小，并将释放的内存返回给操作系统。

### 3.2.串行 GC

串行 GC 也支持堆收缩行为。与 G1 相比，它需要额外的四个完整的 GC 周期来取消提交释放的内存。

### 3.3.ZGC

ZGC 是随着 Java 11 推出的。在 [JEP 351](https://web.archive.org/web/20220524070404/https://openjdk.java.net/jeps/351) 中，它还增强了将未使用的内存归还给操作系统的功能。

### 3.4.Shenandoah GC

[Shenandoah](https://web.archive.org/web/20220524070404/https://wiki.openjdk.java.net/display/shenandoah/Main) 是一个并发 GC。它**异步执行垃圾收集**。消除对完全 GC 的需要极大地有助于应用程序的性能优化。

## 4.使用 JVM 标志

我们之前已经看到，我们可以使用 JVM 命令行选项来指定堆大小。类似地，我们可以使用不同的标志来配置 GC 的默认堆收缩行为:

*   `**-XX:GCTimeRatio**`:指定应用程序执行和 GC 执行之间所需的时间间隔。我们可以用它来延长 GC 的运行时间
*   `**-XX:MinHeapFreeRatio**`:指定垃圾收集后堆中空闲空间的最小预期比例
*   `**-XX:MaxHeapFreeRatio**`:指定垃圾收集后堆中空闲空间的最大预期比例

如果堆中的**可用空闲空间高于使用`-XX:MaxHeapFreeRatio`选项指定的比率，那么 GC 可以将未使用的内存返回给 OS** 。我们可以配置上述标志的值来限制堆中未使用的内存量。我们为并发垃圾收集进程提供了类似的选项:

*   `**-XX:InitiatingHeapOccupancyPercent**`:指定启动并发垃圾收集所需的堆占用率。
*   `**-XX:-ShrinkHeapInSteps**`:立即将堆大小减小到`-XX:MaxHeapFreeRatio`值。默认实现要求此过程有多个垃圾收集周期。

## 5.结论

在本文中，我们看到 Java 提供了不同类型的 GC 来满足不同的需求。GC 可以回收空闲内存并将其返回给主机操作系统。我们可以根据我们的要求选择气相色谱的类型。

我们还探索了如何使用 JVM 参数来调整 GC 行为，以达到期望的性能水平。此外，我们可以选择通过 JVM 动态调整内存利用率。我们应该考虑与我们的应用程序和所涉及的资源的每个选择相关的权衡。