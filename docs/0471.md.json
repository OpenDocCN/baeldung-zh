["```\r\npublic interface GraphNode {\r\n    String getId();\r\n}\r\n```","```\r\npublic class Graph<T extends GraphNode> {\r\n    private final Set<T> nodes;\r\n    private final Map<String, Set<String>> connections;\r\n\r\n    public T getNode(String id) {\r\n        return nodes.stream()\r\n            .filter(node -> node.getId().equals(id))\r\n            .findFirst()\r\n            .orElseThrow(() -> new IllegalArgumentException(\"No node found with ID\"));\r\n    }\r\n\r\n    public Set<T> getConnections(T node) {\r\n        return connections.get(node.getId()).stream()\r\n            .map(this::getNode)\r\n            .collect(Collectors.toSet());\r\n    }\r\n}\r\n```","```\r\npublic interface Scorer<T extends GraphNode> {\r\n    double computeCost(T from, T to);\r\n}\r\n```","```\r\nclass RouteNode<T extends GraphNode> implements Comparable<RouteNode> {\r\n    private final T current;\r\n    private T previous;\r\n    private double routeScore;\r\n    private double estimatedScore;\r\n\r\n    RouteNode(T current) {\r\n        this(current, null, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\r\n    }\r\n\r\n    RouteNode(T current, T previous, double routeScore, double estimatedScore) {\r\n        this.current = current;\r\n        this.previous = previous;\r\n        this.routeScore = routeScore;\r\n        this.estimatedScore = estimatedScore;\r\n    }\r\n}\r\n```","```\r\n@Override\r\npublic int compareTo(RouteNode other) {\r\n    if (this.estimatedScore > other.estimatedScore) {\r\n        return 1;\r\n    } else if (this.estimatedScore < other.estimatedScore) {\r\n        return -1;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n```","```\r\npublic class RouteFinder<T extends GraphNode> {\r\n    private final Graph<T> graph;\r\n    private final Scorer<T> nextNodeScorer;\r\n    private final Scorer<T> targetScorer;\r\n\r\n    public List<T> findRoute(T from, T to) {\r\n        throw new IllegalStateException(\"No route found\");\r\n    }\r\n}\r\n```","```\r\nQueue<RouteNode> openSet = new PriorityQueue<>();\r\nMap<T, RouteNode<T>> allNodes = new HashMap<>();\r\n\r\nRouteNode<T> start = new RouteNode<>(from, null, 0d, targetScorer.computeCost(from, to));\r\nopenSet.add(start);\r\nallNodes.put(from, start);\r\n```","```\r\nwhile (!openSet.isEmpty()) {\r\n    RouteNode<T> next = openSet.poll();\r\n    if (next.getCurrent().equals(to)) {\r\n        List<T> route = new ArrayList<>();\r\n        RouteNode<T> current = next;\r\n        do {\r\n            route.add(0, current.getCurrent());\r\n            current = allNodes.get(current.getPrevious());\r\n        } while (current != null);\r\n        return route;\r\n    }\r\n\r\n    // ...\r\n```","```\r\n graph.getConnections(next.getCurrent()).forEach(connection -> { \r\n        RouteNode<T> nextNode = allNodes.getOrDefault(connection, new RouteNode<>(connection));\r\n        allNodes.put(connection, nextNode);\r\n\r\n   Â     double newScore = next.getRouteScore() + nextNodeScorer.computeCost(next.getCurrent(), connection);\r\n        if (newScore < nextNode.getRouteScore()) {\r\n            nextNode.setPrevious(next.getCurrent());\r\n            nextNode.setRouteScore(newScore);\r\n            nextNode.setEstimatedScore(newScore + targetScorer.computeCost(connection, to));\r\n            openSet.add(nextNode);\r\n        }\r\n    });\r\n\r\n    throw new IllegalStateException(\"No route found\");\r\n}\r\n```","```\r\npublic class Station implements GraphNode {\r\n    private final String id;\r\n    private final String name;\r\n    private final double latitude;\r\n    private final double longitude;\r\n}\r\n```","```\r\npublic class HaversineScorer implements Scorer<Station> {\r\n    @Override\r\n    public double computeCost(Station from, Station to) {\r\n        double R = 6372.8; // Earth's Radius, in kilometers\r\n\r\n        double dLat = Math.toRadians(to.getLatitude() - from.getLatitude());\r\n        double dLon = Math.toRadians(to.getLongitude() - from.getLongitude());\r\n        double lat1 = Math.toRadians(from.getLatitude());\r\n        double lat2 = Math.toRadians(to.getLatitude());\r\n\r\n        double a = Math.pow(Math.sin(dLat / 2),2)\r\n          + Math.pow(Math.sin(dLon / 2),2) * Math.cos(lat1) * Math.cos(lat2);\r\n        double c = 2 * Math.asin(Math.sqrt(a));\r\n        return R * c;\r\n    }\r\n}\r\n```","```\r\npublic void findRoute() {\r\n    List<Station> route = routeFinder.findRoute(underground.getNode(\"74\"), underground.getNode(\"7\"));\r\n\r\n    System.out.println(route.stream().map(Station::getName).collect(Collectors.toList()));\r\n}\r\n```"]