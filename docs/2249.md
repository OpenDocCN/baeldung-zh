# Java 中的折叠技术指南

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/folding-hashing-technique>

## 1.介绍

在本教程中，我们考虑在各种数据结构中使用的散列技术，这些数据结构提供对其元素的恒定时间访问。

我们将更详细地讨论所谓的`folding technique`，并简要介绍中正方形和宁滨技术。

## 2.概观

当我们选择数据结构来存储对象时，其中一个考虑因素是我们是否需要快速访问它们。

Java 实用程序包为我们存储对象提供了相当多的数据结构。有关数据结构的更多信息，请参考我们的 [Java Collections](/web/20220626203003/https://www.baeldung.com/java-collections) 编译页面，其中包含了关于其中几个的指南。

正如我们所知，**这些数据结构中的一些允许我们在常数时间内检索它们的元素，**与它们包含的元素数量无关。

大概，最简单的就是数组了。事实上，我们通过索引来访问数组中的元素。**自然，访问时间不取决于数组的大小。**其实在幕后，很多数据结构大量使用数组。

问题是数组索引必须是数字的，而我们通常喜欢用对象来操作这些数据结构。

为了解决这个问题，许多数据结构试图分配一个数值作为对象的数组索引。**我们称这个值为`hash value`或简称为`hash`。**

## 3.散列法

****[哈希](/web/20220626203003/https://www.baeldung.com/cs/hashing)是将一个对象转换成一个数值**。**执行这些转换的函数被称为`hash functions`。

为了简单起见，让我们考虑将字符串转换成数组索引的哈希函数，也就是说，用有限的`N`从范围`[0, N]`转换成整数。

自然地，**散列函数被应用于各种各样的字符串**。因此，它的“全局”属性变得很重要。

[![Mapping of strings into array indexes](img/ff5864cd72c32dcec494e4cff6dad02d.png)](/web/20220626203003/https://www.baeldung.com/wp-content/uploads/2019/06/strings-to-numbers.png) 
**不幸的是，一个哈希函数不可能总是把不同的字符串转换成不同的数字**。

我们可能很容易说服自己，在任何范围内，字符串的数量都比整数的数量大得多。因此，不可避免地会有一对不相等的字符串，哈希函数会为它们生成相等的值。**这种现象被称为`collision`。**

我们不打算深究哈希函数背后的工程细节，但很明显，一个好的哈希函数应该尝试将它所定义的字符串统一映射成数字。

另一个明显的要求是一个好的散列函数应该是快速的。如果计算哈希值的时间太长，那么我们就不能快速访问元素。

在本教程中，我们考虑一种**技术，它试图在保持快速映射的同时使映射一致**。

## 4.折叠技术

我们的目标是找到一个将字符串转换成数组索引的函数。为了说明这个想法，假设我们希望这个数组有 10 个 <sup>5 个</sup>元素的容量，让我们以字符串`Java language`为例。

### 4.1.描述

让我们从将字符串的字符转换成数字开始。ASCII 是这种操作的一个很好的候选:

[![Convert the string into ascii](img/d45ad605ae0b30504e338313eaf214c3.png)](/web/20220626203003/https://www.baeldung.com/wp-content/uploads/2019/06/convert-to-ascii1.png)

现在，我们将刚刚获得的数字按一定大小分组。通常，我们根据数组的大小选择组大小值，即 10 <sup>5</sup> 。由于我们将字符转换成的数字包含 2 到 3 个数字，不失一般性，我们可以将组大小设置为 2:

[![Arrange string's ascii codes](img/bf8feadb545688d59211773f11caa61d.png)](/web/20220626203003/https://www.baeldung.com/wp-content/uploads/2019/06/arrange-ascii-codes.png)

下一步是将每组中的数字连接起来，就像它们是字符串一样，并求出它们的和:

[![Concatenate and sum up the numbers](img/78cbeff2fbdd1df2308c3ec0fba48a8d.png)](/web/20220626203003/https://www.baeldung.com/wp-content/uploads/2019/06/folding-sum.png)

现在我们必须迈出最后一步。让我们检查一下数字`348933`是否可以作为大小为 10 <sup>5</sup> 的数组的索引。自然，它超过了最大允许值`99999.`。我们可以通过应用模运算符来找到最终结果，从而轻松解决这个问题:

[PRE0]

### 4.2.结束语

我们看到，该算法不包括任何耗时的操作，因此它相当快。输入字符串的每一个字符都对最终结果有贡献。这个事实无疑有助于减少碰撞，但不能完全避免碰撞。

例如，如果我们想跳过折叠，直接对经过 ASCII 转换的输入字符串应用模操作符(忽略溢出问题)

[PRE1]

那么这样的散列函数将为所有最后两个字符与我们的输入字符串相同的字符串产生相同的值:a `ge`、p `age`、lar `ge,` 等等。

从算法的描述中，我们可以很容易地看出，它并不是没有冲突。例如，该算法为`Java language`和`vaJa language`字符串`.` 产生相同的哈希值

## 5.其他技术

折叠技术很常见，但不是唯一的。有时，`binning` 或`mid-square` 技术也可能有用。

我们不使用字符串，而是使用数字来说明他们的想法(假设我们已经以某种方式将字符串转换为数字)。我们不会讨论它们的优缺点，但您可能会在看到算法后形成一种观点。

### 5.1.宁滨技术

假设我们有 100 个整数，我们希望我们的哈希函数将它们映射到一个包含 10 个元素的数组中。然后我们可以把这 100 个整数分成 10 组，这样前 10 个整数在第一个二进制数中结束，后 10 个整数在第二个二进制数中结束，依此类推。：

[![Binning technique](img/ddd0cbe6e2d53d25eb1c62222cf807b5.png)](/web/20220626203003/https://www.baeldung.com/wp-content/uploads/2019/06/binning.png)

### 5.2。中方技术

这个算法是由约翰·冯·诺依曼提出的，它允许我们从一个给定的数字开始产生伪随机数。

[![Mid-square hashing](img/3c88b5ee5b12489e5bb2d3d7fa2f55a5.png)](/web/20220626203003/https://www.baeldung.com/wp-content/uploads/2019/06/mid-square.png) 
让我们用一个具体的例子来说明吧。假设，我们有一个四位数`1111`。根据算法，我们将其平方，从而得到`1234321‬`。现在，我们从中间提取四个数字，例如，`2343`。该算法允许我们重复这个过程，直到我们对结果满意为止。

## 6.结论

在本教程中，我们考虑了几种散列技术。我们详细描述了折叠技术，并简要描述了如何实现宁滨和中间正方形。

和往常一样，我们可能会在我们的 [GitHub 库](https://web.archive.org/web/20220626203003/https://github.com/eugenp/tutorials/tree/master/algorithms-modules/algorithms-miscellaneous-3)上找到相应的代码片段。