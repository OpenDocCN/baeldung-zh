# Java 中的线程模型

> 原文:[https://web . archive . org/web/20220930061024/https://www . bael dung . com/Java-threading-models](https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-threading-models)

## **1。简介**

通常在我们的应用程序中，我们需要能够同时做多件事情。我们可以通过多种方式实现这一点，但其中最关键的是以某种形式实现多任务处理。

**多任务意味着同时运行多个任务**，其中每个任务都在执行其工作。这些任务通常都在同一时间运行，读写相同的内存，与相同的资源交互，但做不同的事情。

## **2。本地线程**

在 Java 中实现多任务的标准方式是使用线程。线程通常在操作系统中都得到支持。我们将在这一层工作的线程称为“本机线程”。

操作系统具有一些我们的应用程序通常不具备的线程能力，这仅仅是因为它与底层硬件的距离更近。这意味着执行本机线程通常更有效。这些线程直接映射到计算机 CPU 上的执行线程，操作系统管理线程到 CPU 内核的映射。

**Java 中的标准线程模型，覆盖所有 JVM 语言，使用原生线程**。从 Java 1.2 开始就是这种情况，不管 JVM 运行在哪个底层系统上，都是这种情况。

这意味着，每当我们在 Java 中使用任何标准线程机制时，我们都在使用本地线程。这包括`java.lang.Thread`、`java.util.concurrent.Executor`、`java.util.concurrent.ExecutorService`等等。

## **3。绿色螺纹**

In software engineering, **one alternative to native threads is green threads**. This is where we are using threads, but they do not directly map to operating system threads. Instead, the underlying architecture manages the threads itself and manages how these map on to operating system threads.

通常，这是通过运行几个本机线程，然后将绿色线程分配到这些本机线程上来执行的。然后，系统可以选择在任何给定时间哪些绿色线程是活动的，以及它们在哪些本机线程上是活动的。

这听起来很复杂，确实如此。但这是一个我们通常不需要关心的复杂问题。底层架构负责所有这些，我们可以像使用本机线程模型一样使用它。

那么我们为什么要这么做呢？本机线程运行起来非常高效，但是启动和停止它们的成本很高。绿色线程有助于避免这种成本，并为架构提供更大的灵活性。如果我们使用的是相对长时间运行的线程，那么原生线程是非常高效的。对于非常短命的工作，启动它们的成本可能会超过使用它们的好处。在这些情况下，绿色线程会变得更加高效。

不幸的是， **Java 没有内置对绿色线程的支持。**

非常早期的版本使用绿色线程而不是本机线程作为标准线程模型。这在 Java 1.2 中发生了变化，从那以后，JVM 级别就不再支持它了。

在库中实现绿色线程也很有挑战性，因为它们需要非常底层的支持才能运行良好。因此，常用的替代品是纤维。

## **4。纤维**

**纤程是多线程的一种替代形式，类似于绿线**。在这两种情况下，我们都没有使用本地线程，而是使用随时运行的底层系统控件。绿色线程和纤程的最大区别在于控制的级别，尤其是谁在控制。

绿色线程是抢占式多任务处理的一种形式。这意味着底层架构完全负责决定在任何给定时间执行哪些线程。

这意味着所有常见的线程问题都适用，我们不知道线程执行的顺序，也不知道哪些线程将同时执行。这也意味着底层系统需要能够在任何时候暂停和重启我们的代码，可能是在一个方法甚至一个语句的中间。

相反，纤程是一种协作多任务的形式，这意味着一个正在运行的线程将继续运行，直到它发出信号表示它可以让位于另一个线程。这意味着纤维之间的合作是我们的责任。这使得我们可以直接控制纤程何时可以暂停执行，而不是由系统来决定。

这也意味着我们需要以一种允许这种情况的方式编写代码。不然就不行了。如果我们的代码没有任何中断点，那么我们还不如根本不使用纤程。

Java 目前没有对纤程的内置支持。有一些库可以将它引入到我们的应用程序中，包括但不限于:

### **4.1。类星体**

Quasar 是一个 Java 库，可以很好地与纯 Java 和 Kotlin 一起工作，并且有一个替代版本可以与 Clojure 一起工作。

它的工作原理是有一个需要与应用程序一起运行的 Java 代理，这个代理负责管理纤程并确保它们正确地协同工作。使用 Java 代理意味着不需要特殊的构建步骤。

Quasar 还需要 Java 11 才能正常工作，因此可能会限制可以使用它的应用程序。旧版本可以在 Java 8 上使用，但是没有得到积极的支持。

### **4.2。基利姆**

Kilim 是一个 Java 库，它提供了与 Quasar 非常相似的功能，但是通过使用字节码编织而不是 Java 代理来实现。这意味着它可以在更多的地方工作，但它使构建过程更加复杂。

Kilim 可以与 Java 7 和更高版本一起工作，即使在没有 Java 代理的情况下也能正常工作。例如，如果不同的一个已经用于仪器或监控。

### **4.3。项目织机**

**[Project Loom](/web/20221126223814/https://www.baeldung.com/openjdk-project-loom) 是 OpenJDK 项目为 JVM 本身添加纤程的实验，而不是作为一个附加库**。这将赋予我们纤维优于线的优势。通过直接在 JVM 上实现它，它可以帮助避免 Java 代理和字节码编织带来的复杂性。

Project Loom 目前还没有发布时间表，但我们现在可以下载早期访问二进制文件，看看事情进展如何。然而，因为现在还很早，我们需要小心任何依赖它的产品代码。

## **5。协同例程**

协同例程是线程和纤程的替代方案。我们可以把协同例程想象成没有任何形式调度的纤程。我们的代码直接决定执行哪些任务，而不是由底层系统来决定。

一般来说，我们编写协同例程，以便它们在其流程的特定点上让步。这些可以被视为函数中的暂停点，在这里它将停止工作，并可能输出一些中间结果。当我们让步时，我们就会停止，直到调用代码出于某种原因决定重新启动我们。这意味着我们的调用代码控制着何时运行的调度。

Kotlin 的标准库中内置了对协同例程的本地支持。如果需要，我们还可以使用其他几个 Java 库来实现它们。

## **6。结论**

我们已经在代码中看到了多任务的几种不同的替代方案，从传统的本机线程到一些非常轻量级的替代方案。为什么不在下次应用程序需要并发时尝试一下呢？