["```\r\n$ java -jar clojure-1.8.0.jar\r\nClojure 1.8.0\r\nuser=>\r\n```","```\r\n$ brew install clojure\r\n```","```\r\n$ clj\r\nClojure 1.10.0\r\nuser=>\r\n```","```\r\n$ curl -O https://download.clojure.org/install/linux-install-1.10.0.411.sh\r\n$ chmod +x linux-install-1.10.0.411.sh\r\n$ sudo ./linux-install-1.10.0.411.sh\r\n```","```\r\nuser=>\r\n```","```\r\n(+ 1 2) ; = 3\r\n```","```\r\n(+ 1 2 3 4 5) ; = 15\r\n```","```\r\n123 ; Long\r\n1.23 ; Double\r\n\"Hello\" ; String\r\ntrue ; Boolean\r\n```","```\r\n42N ; clojure.lang.BigInt\r\n3.14159M ; java.math.BigDecimal\r\n1/3 ; clojure.lang.Ratio\r\n#\"[A-Za-z]+\" ; java.util.regex.Pattern\r\n```","```\r\nuser=> :kw\r\n:kw\r\nuser=> :a\r\n:a\r\n```","```\r\nuser=> (= :a :a)\r\ntrue\r\nuser=> (= :a :b)\r\nfalse\r\nuser=> (= :a \"a\")\r\nfalse\r\n```","```\r\nuser=> (def a 1)\r\n#'user/a\r\nuser=> :a\r\n:a\r\nuser=> a\r\n1\r\n```","```\r\nuser=> (ns new.ns)\r\nnil\r\nnew.ns=>\r\n```","```\r\nuser=> (clojure.string/upper-case \"hello\")\r\n\"HELLO\"\r\nuser=> (upper-case \"hello\") ; This is not visible in the \"user\" namespace\r\nSyntax error compiling at (REPL:1:1).\r\nUnable to resolve symbol: upper-case in this context\r\nuser=> (ns clojure.string)\r\nnil\r\nclojure.string=> (upper-case \"hello\") ; This is visible because we're now in the \"clojure.string\" namespace\r\n\"HELLO\"\r\n```","```\r\nclojure.string=> (require '[clojure.string :as str])\r\nnil\r\nclojure.string=> (str/upper-case \"Hello\")\r\n\"HELLO\"\r\n\r\nuser=> (require '[clojure.string :as str :refer [upper-case]])\r\nnil\r\nuser=> (upper-case \"Hello\")\r\n\"HELLO\"\r\n```","```\r\nuser=> (def a 123)\r\n#'user/a\r\n```","```\r\nuser=> a\r\n123\r\n```","```\r\nuser=> (def b (+ 1 2 3 4 5))\r\n#'user/b\r\nuser=> b\r\n15\r\n```","```\r\nuser=> unknown\r\nSyntax error compiling at (REPL:0:0).\r\nUnable to resolve symbol: unknown in this context\r\nuser=> (def c (+ 1 unknown))\r\nSyntax error compiling at (REPL:1:8).\r\nUnable to resolve symbol: unknown in this context\r\n```","```\r\nuser=> (java.time.Instant/now)\r\n#object[java.time.Instant 0x4b6690c0 \"2019-01-15T07:54:01.516Z\"]\r\nuser=> (java.time.Instant/parse \"2019-01-15T07:55:00Z\")\r\n#object[java.time.Instant 0x6b8d96d9 \"2019-01-15T07:55:00Z\"]\r\nuser=> (java.time.OffsetDateTime/of 2019 01 15 7 56 0 0 java.time.ZoneOffset/UTC)\r\n#object[java.time.OffsetDateTime 0xf80945f \"2019-01-15T07:56Z\"]\r\n```","```\r\nuser=> (java.time.OffsetDateTime/of 2018 01 15 7 57 0 0 (java.time.ZoneOffset/ofHours -5))\r\n#object[java.time.OffsetDateTime 0x1cdc4c27 \"2018-01-15T07:57-05:00\"]\r\n```","```\r\nuser=> (fn [a b]\r\n  (println \"Adding numbers\" a \"and\" b)\r\n  (+ a b)\r\n)\r\n#object[user$eval165$fn__166 0x5644dc81 \"[[emailÂ protected]](/web/20220630012534/https://www.baeldung.com/cdn-cgi/l/email-protection)\"]\r\n```","```\r\nuser=> (def add\r\n  (fn [a b]\r\n    (println \"Adding numbers\" a \"and\" b)\r\n    (+ a b)\r\n  )\r\n)\r\n#'user/add\r\n```","```\r\nuser=> (add 1 2)\r\nAdding numbers 1 and 2\r\n3\r\n```","```\r\nuser=> (defn sub [a b]\r\n  (println \"Subtracting\" b \"from\" a)\r\n  (- a b)\r\n)\r\n#'user/sub\r\nuser=> (sub 5 2)\r\nSubtracting 2 from 5\r\n3\r\n```","```\r\nuser=> (defn sub [a b]\r\n  (def result (- a b))\r\n  (println \"Result: \" result)\r\n  result\r\n)\r\n#'user/sub\r\n```","```\r\nuser=> (sub 1 2)\r\nResult:  -1\r\n-1\r\nuser=> result ; Still visible outside of the function\r\n-1\r\n```","```\r\nuser=> (defn sub [a b]\r\n  (let [result (- a b)]\r\n    (println \"Result: \" result)\r\n    result\r\n  )\r\n)\r\n#'user/sub\r\nuser=> (sub 1 2)\r\nResult:  -1\r\n-1\r\nuser=> result\r\nSyntax error compiling at (REPL:0:0).\r\nUnable to resolve symbol: result in this context\r\n```","```\r\n; Vector\r\nuser=> [1 2 3]\r\n[1 2 3]\r\nuser=> (vector 1 2 3)\r\n[1 2 3]\r\n\r\n; List\r\nuser=> '(1 2 3)\r\n(1 2 3)\r\nuser=> (list 1 2 3)\r\n(1 2 3)\r\n\r\n; Set\r\nuser=> #{1 2 3}\r\n#{1 3 2}\r\nuser=> (hash-set 1 2 3)\r\n#{1 3 2}\r\n\r\n; Map\r\nuser=> {:a 1 :b 2}\r\n{:a 1, :b 2}\r\nuser=> (hash-map :a 1 :b 2)\r\n{:b 2, :a 1}\r\n```","```\r\nuser=> (seq [1 2 3])\r\n(1 2 3)\r\nuser=> (seq #{1 2 3})\r\n(1 3 2)\r\nuser=> (seq {:a 1 2 3})\r\n([:a 1] [2 3])\r\n```","```\r\nuser=> (my-vector 2) ; [1 2 3]\r\n3\r\n```","```\r\nuser=> (my-map :b)\r\n2\r\n```","```\r\nuser=> (first my-vector)\r\n1\r\nuser=> (last my-list)\r\n3\r\nuser=> (next my-vector)\r\n(2 3)\r\n```","```\r\nuser=> (keys my-map)\r\n(:a :b)\r\nuser=> (vals my-map)\r\n(1 2)\r\n```","```\r\nuser=> (my-set 1)\r\n1\r\nuser=> (my-set 5)\r\nnil\r\n```","```\r\nuser=> (vector? [1 2 3]) ; A vector is a vector\r\ntrue\r\nuser=> (vector? #{1 2 3}) ; A set is not a vector\r\nfalse\r\nuser=> (list? '(1 2 3)) ; A list is a list\r\ntrue\r\nuser=> (list? [1 2 3]) ; A vector is not a list\r\nfalse\r\nuser=> (map? {:a 1 :b 2}) ; A map is a map\r\ntrue\r\nuser=> (map? #{1 2 3}) ; A set is not a map\r\nfalse\r\nuser=> (seq? '(1 2 3)) ; A list is a seq\r\ntrue\r\nuser=> (seq? [1 2 3]) ; A vector is not a seq\r\nfalse\r\nuser=> (seq? (seq [1 2 3])) ; A vector can be converted into a seq\r\ntrue\r\nuser=> (associative? {:a 1 :b 2}) ; A map is associative\r\ntrue\r\nuser=> (associative? [1 2 3]) ; A vector is associative\r\ntrue\r\nuser=> (associative? '(1 2 3)) ; A list is not associative\r\nfalse\r\n```","```\r\nuser=> (conj [1 2 3] 4) ; Adds to the end\r\n[1 2 3 4]\r\nuser=> (conj '(1 2 3) 4) ; Adds to the beginning\r\n(4 1 2 3)\r\nuser=> (conj #{1 2 3} 4) ; Unordered\r\n#{1 4 3 2}\r\nuser=> (conj #{1 2 3} 3) ; Adding an already present entry does nothing\r\n#{1 3 2}\r\n```","```\r\nuser=> (disj #{1 2 3} 2) ; Removes the entry\r\n#{1 3}\r\nuser=> (disj #{1 2 3} 4) ; Does nothing because the entry wasn't present\r\n#{1 3 2}\r\n```","```\r\nuser=> (assoc {:a 1 :b 2} :c 3) ; Adds a new key\r\n{:a 1, :b 2, :c 3}\r\nuser=> (assoc {:a 1 :b 2} :b 3) ; Updates an existing key\r\n{:a 1, :b 3}\r\nuser=> (dissoc {:a 1 :b 2} :b) ; Removes an existing key\r\n{:a 1}\r\nuser=> (dissoc {:a 1 :b 2} :c) ; Does nothing because the key wasn't present\r\n{:a 1, :b 2}\r\n```","```\r\nuser=> (map inc [1 2 3]) ; Increment every value in the vector\r\n(2 3 4)\r\nuser=> (map inc #{1 2 3}) ; Increment every value in the set\r\n(2 4 3)\r\n\r\nuser=> (filter odd? [1 2 3 4 5]) ; Only return odd values\r\n(1 3 5)\r\nuser=> (remove odd? [1 2 3 4 5]) ; Only return non-odd values\r\n(2 4)\r\n\r\nuser=> (reduce + [1 2 3 4 5]) ; Add all of the values together, returning the sum\r\n15\r\n```","```\r\nuser=> (if true 1 2)\r\n1\r\nuser=> (if false 1 2)\r\n2\r\n```","```\r\nuser=> (if (> 1 2) \"True\" \"False\")\r\n\"False\"\r\n```","```\r\nuser=> (if (odd? 1) \"1 is odd\" \"1 is even\")\r\n\"1 is odd\"\r\n```","```\r\nuser=> (if 0 \"True\" \"False\")\r\n\"True\"\r\nuser=> (if [] \"True\" \"False\")\r\n\"True\"\r\nuser=> (if nil \"True\" \"False\")\r\n\"False\"\r\n```","```\r\nuser=> (loop [accum [] i 0]\r\n  (if (= i 10)\r\n    accum\r\n    (recur (conj accum i) (inc i))\r\n  ))\r\n[0 1 2 3 4 5 6 7 8 9]\r\n```"]