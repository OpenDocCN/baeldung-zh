["```\r\nField f = Unsafe.class.getDeclaredField(\"theUnsafe\");\r\nf.setAccessible(true);\r\nunsafe = (Unsafe) f.get(null);\r\n```","```\r\nclass InitializationOrdering {\r\n    private long a;\r\n\r\n    public InitializationOrdering() {\r\n        this.a = 1;\r\n    }\r\n\r\n    public long getA() {\r\n        return this.a;\r\n    }\r\n}\r\n```","```\r\nInitializationOrdering o1 = new InitializationOrdering();\r\nassertEquals(o1.getA(), 1);\r\n```","```\r\nInitializationOrdering o3 \r\n  = (InitializationOrdering) unsafe.allocateInstance(InitializationOrdering.class);\r\n\r\nassertEquals(o3.getA(), 0);\r\n```","```\r\nclass SecretHolder {\r\n    private int SECRET_VALUE = 0;\r\n\r\n    public boolean secretIsDisclosed() {\r\n        return SECRET_VALUE == 1;\r\n    }\r\n}\r\n```","```\r\nSecretHolder secretHolder = new SecretHolder();\r\n\r\nField f = secretHolder.getClass().getDeclaredField(\"SECRET_VALUE\");\r\nunsafe.putInt(secretHolder, unsafe.objectFieldOffset(f), 1);\r\n\r\nassertTrue(secretHolder.secretIsDisclosed());\r\n```","```\r\n@Test(expected = IOException.class)\r\npublic void givenUnsafeThrowException_whenThrowCheckedException_thenNotNeedToCatchIt() {\r\n    unsafe.throwException(new IOException());\r\n}\r\n```","```\r\nclass OffHeapArray {\r\n    private final static int BYTE = 1;\r\n    private long size;\r\n    private long address;\r\n\r\n    public OffHeapArray(long size) throws NoSuchFieldException, IllegalAccessException {\r\n        this.size = size;\r\n        address = getUnsafe().allocateMemory(size * BYTE);\r\n    }\r\n\r\n    private Unsafe getUnsafe() throws IllegalAccessException, NoSuchFieldException {\r\n        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n        f.setAccessible(true);\r\n        return (Unsafe) f.get(null);\r\n    }\r\n\r\n    public void set(long i, byte value) throws NoSuchFieldException, IllegalAccessException {\r\n        getUnsafe().putByte(address + i * BYTE, value);\r\n    }\r\n\r\n    public int get(long idx) throws NoSuchFieldException, IllegalAccessException {\r\n        return getUnsafe().getByte(address + idx * BYTE);\r\n    }\r\n\r\n    public long size() {\r\n        return size;\r\n    }\r\n\r\n    public void freeMemory() throws NoSuchFieldException, IllegalAccessException {\r\n        getUnsafe().freeMemory(address);\r\n    }\r\n```","```\r\n}\r\n```","```\r\nlong SUPER_SIZE = (long) Integer.MAX_VALUE * 2;\r\nOffHeapArray array = new OffHeapArray(SUPER_SIZE);\r\n```","```\r\nint sum = 0;\r\nfor (int i = 0; i < 100; i++) {\r\n    array.set((long) Integer.MAX_VALUE + i, (byte) 3);\r\n    sum += array.get((long) Integer.MAX_VALUE + i);\r\n}\r\n\r\nassertEquals(array.size(), SUPER_SIZE);\r\nassertEquals(sum, 300);\r\n```","```\r\nclass CASCounter {\r\n    private Unsafe unsafe;\r\n    private volatile long counter = 0;\r\n    private long offset;\r\n\r\n    private Unsafe getUnsafe() throws IllegalAccessException, NoSuchFieldException {\r\n        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n        f.setAccessible(true);\r\n        return (Unsafe) f.get(null);\r\n    }\r\n\r\n    public CASCounter() throws Exception {\r\n        unsafe = getUnsafe();\r\n        offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(\"counter\"));\r\n    }\r\n\r\n    public void increment() {\r\n        long before = counter;\r\n        while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) {\r\n            before = counter;\r\n        }\r\n    }\r\n\r\n    public long getCounter() {\r\n        return counter;\r\n    }\r\n}\r\n```","```\r\nint NUM_OF_THREADS = 1_000;\r\nint NUM_OF_INCREMENTS = 10_000;\r\nExecutorService service = Executors.newFixedThreadPool(NUM_OF_THREADS);\r\nCASCounter casCounter = new CASCounter();\r\n\r\nIntStream.rangeClosed(0, NUM_OF_THREADS - 1)\r\n  .forEach(i -> service.submit(() -> IntStream\r\n    .rangeClosed(0, NUM_OF_INCREMENTS - 1)\r\n    .forEach(j -> casCounter.increment())));\r\n```","```\r\nassertEquals(NUM_OF_INCREMENTS * NUM_OF_THREADS, casCounter.getCounter());\r\n```"]