# 一个更好的刀的 Spring 自定义注释

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/spring-annotation-bean-pre-processor>

## **1。概述**

在本教程中，我们将使用 bean 后处理器实现一个定制的 Spring 注释**。**

那么这有什么帮助呢？简而言之——我们可以重用同一个 bean，而不必创建多个相同类型的相似 bean。

我们将在一个简单的项目中为 DAO 实现这样做——用一个单一的、灵活的`GenericDao`来替换它们。

## **2。肚子**

我们需要`spring-core`、`spring-aop`和`spring-context-support`罐子来完成这项工作。我们可以在我们的`pom.xml`中声明`spring-context-support`。

[PRE0]

如果你想获得 Spring 依赖的新版本——查看一下 maven 知识库。

## **3。新通用刀**

大多数 Spring / JPA / Hibernate 实现使用标准的 DAO——通常每个实体一个。

我们将用一个`GenericDao`来代替那个解决方案；我们将编写一个定制的注释处理器，并使用那个`GenericDao`实现:

### **3.1。通用刀**

[PRE1]

在真实的场景中，您当然需要连接一个 [PersistenceContext](https://web.archive.org/web/20220815044713/https://docs.oracle.com/javaee/7/api/javax/persistence/PersistenceContext.html) 并实际提供这些方法的实现。目前，我们将尽可能简单地解决这个问题。

现在，让我们为定制注入创建注释。

### **3.2。数据访问**

[PRE2]

我们将使用上面的注释注入一个`GenericDao`,如下所示:

[PRE3]

也许你们中的一些人会问，“Spring 如何识别我们的`DataAccess`注释？”。不会——默认情况下不会。

但是我们可以告诉 Spring 通过一个定制的`[BeanPostProcessor](https://web.archive.org/web/20220815044713/https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html)`来识别注释——接下来让我们来实现它。

### **3.3。`DataAccessAnnotationProcessor`**

[PRE4]

接下来——这是我们刚刚使用的`DataAccessFieldCallback`的实现:

### **3.4。`DataAccessFieldCallback`**

[PRE5]

这是一个相当好的实现，但其中最重要的部分是`doWith()`方法:

[PRE6]

这将告诉 Spring 基于运行时通过`@DataAccess`注释注入的对象来初始化 bean。

`beanName`将确保我们将获得 bean 的唯一实例，因为——在这种情况下——我们确实希望根据通过`@DataAccess`注释注入的实体创建单个对象`GenericDao`。

最后，接下来让我们在 Spring 配置中使用这个新的 bean 处理器。

### **3.5。`CustomAnnotationConfiguration`**

[PRE7]

这里重要的一点是,`[@ComponentScan](https://web.archive.org/web/20220815044713/https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html)`注释的值需要指向我们的定制 bean post 处理器所在的包，并确保它在运行时被 Spring 扫描和自动连接。

## **4。测试新刀**

让我们从一个支持 Spring 的测试和两个简单的示例实体类开始吧—`Person`和`Account`。

[PRE8]

我们在`DataAccess`注释的帮助下注入了一些`GenericDao`的实例。为了测试新的 beans 是否被正确注入，我们需要覆盖:

1.  如果注射成功
2.  如果具有相同实体的 bean 实例是相同的
3.  如果`GenericDao`中的方法实际上如预期的那样工作

第一点实际上被 Spring 本身覆盖了——因为如果 bean 不能被连接进来，框架会很早抛出一个异常。

为了测试第 2 点，我们需要查看两个都使用了`Person`类的`GenericDao`实例:

[PRE9]

我们不希望`personGenericDao`等于`accountGenericDao`。

但是我们确实希望`personGenericDao`和`anotherPersonGenericDao`是完全相同的实例。

为了测试第 3 点，我们在这里只测试一些简单的与持久性相关的逻辑:

[PRE10]

## **5。结论**

在本文中，我们在 Spring 中实现了一个非常酷的自定义注释——还有一个`BeanPostProcessor`。总的目标是摆脱我们通常在持久层中拥有的多个 DAO 实现，并使用一个好的、简单的通用实现，而不会在这个过程中丢失任何东西。

所有这些示例和代码片段的实现**可以在** [**我的 GitHub 项目**](https://web.archive.org/web/20220815044713/https://github.com/eugenp/tutorials/tree/master/spring-core-3) 中找到——这是一个基于 Eclipse 的项目，所以它应该很容易导入并按原样运行。