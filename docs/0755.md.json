["```\r\npublic class MinMaxHeap<T extends Comparable<T>> {\r\n    private List<T> array;\r\n    private int capacity;\r\n    private int indicator;\r\n}\r\n```","```\r\nprivate int getLeftChildIndex(int i) {\r\n   return 2 * i;\r\n}\r\n\r\nprivate int getRightChildIndex(int i) {\r\n    return ((2 * i) + 1);\r\n}\r\n```","```\r\nprivate int getParentIndex(int i) {\r\n   return i / 2;\r\n}\r\n\r\nprivate int getGrandparentIndex(int i) {\r\n   return i / 4;\r\n}\r\n```","```\r\npublic class MinMaxHeap<T extends Comparable<T>> {\r\n    private List<T> array;\r\n    private int capacity;\r\n    private int indicator;\r\n\r\n    MinMaxHeap(int capacity) {\r\n        array = new ArrayList<>();\r\n        this.capacity = capacity;\r\n        indicator = 1;\r\n    }\r\n\r\n    MinMaxHeap(List<T> array) {\r\n        this.array = array;\r\n        this.capacity = array.size();\r\n        this.indicator = array.size() + 1;\r\n    }\r\n}\r\n```","```\r\npublic List<T> create() {\r\n    for (int i = Math.floorDiv(array.size(), 2); i >= 1; i--) {\r\n        pushDown(array, i);\r\n    }\r\n    return array;\r\n}\r\n```","```\r\nprivate void pushDown(List<T> array, int i) {\r\n    if (isEvenLevel(i)) {\r\n        pushDownMin(array, i);\r\n    } else {\r\n        pushDownMax(array, i);\r\n    }\r\n}\r\n```","```\r\nprivate void pushDownMin(List<T> h, int i) {\r\n    while (getLeftChildIndex(i) < indicator) {\r\n       int indexOfSmallest = getIndexOfSmallestChildOrGrandChild(h, i);\r\n          //...\r\n          i = indexOfSmallest;\r\n    }\r\n }\r\n```","```\r\nif (h.get(indexOfSmallest - 1).compareTo(h.get(i - 1)) < 0) {\r\n    //...\r\n} else {\r\n    break;\r\n}\r\n```","```\r\nif (getParentIndex(getParentIndex(indexOfSmallest)) == i) {\r\n       if (h.get(indexOfSmallest - 1).compareTo(h.get(i - 1)) < 0) {\r\n          swap(indexOfSmallest - 1, i - 1, h);\r\n          if (h.get(indexOfSmallest - 1)\r\n            .compareTo(h.get(getParentIndex(indexOfSmallest) - 1)) > 0) {\r\n             swap(indexOfSmallest - 1, getParentIndex(indexOfSmallest) - 1, h);\r\n           }\r\n        }\r\n  } else if (h.get(indexOfSmallest - 1).compareTo(h.get(i - 1)) < 0) {\r\n      swap(indexOfSmallest - 1, i - 1, h);\r\n }\r\n```","```\r\nprivate int getIndexOfSmallestChildOrGrandChild(List<T> h, int i) {\r\n    int minIndex = getLeftChildIndex(i);\r\n    T minValue = h.get(minIndex - 1);\r\n    // rest of the implementation\r\n}\r\n```","```\r\nif (getRightChildIndex(i) < indicator) {\r\n    if (h.get(getRightChildIndex(i) - 1).compareTo(minValue) < 0) {\r\n        minValue = h.get(getRightChildIndex(i));\r\n        minIndex = getRightChildIndex(i);\r\n    }\r\n} else {\r\n     return minIndex;\r\n}\r\n```","```\r\n@Test\r\npublic void givenUnOrderedArray_WhenCreateMinMaxHeap_ThenIsEqualWithMinMaxHeapOrdered() {\r\n    List<Integer> list = Arrays.asList(34, 12, 28, 9, 30, 19, 1, 40);\r\n    MinMaxHeap<Integer> minMaxHeap = new MinMaxHeap<>(list);\r\n    minMaxHeap.create();\r\n    Assert.assertEquals(List.of(1, 40, 34, 9, 30, 19, 28, 12), list);\r\n}\r\n```","```\r\npublic void insert(T item) {\r\n    if (isEmpty()) {\r\n        array.add(item);\r\n        indicator++;\r\n    } else if (!isFull()) {\r\n        array.add(item);\r\n        pushUp(array, indicator);\r\n        indicator++;\r\n    } else {\r\n        throw new RuntimeException(\"invalid operation !!!\");\r\n    }\r\n }\r\n```","```\r\nprivate void pushUp(List<T>h,int i) {\r\n    if (i != 1) {\r\n        if (isEvenLevel(i)) {\r\n            if (h.get(i - 1).compareTo(h.get(getParentIndex(i) - 1)) < 0) {\r\n                pushUpMin(h, i);\r\n            } else {\r\n                swap(i - 1, getParentIndex(i) - 1, h);\r\n                i = getParentIndex(i);\r\n                pushUpMax(h, i);\r\n            }\r\n        } else if (h.get(i - 1).compareTo(h.get(getParentIndex(i) - 1)) > 0) {\r\n            pushUpMax(h, i);\r\n        } else {\r\n            swap(i - 1, getParentIndex(i) - 1, h);\r\n            i = getParentIndex(i);\r\n            pushUpMin(h, i);\r\n        }\r\n    }\r\n}\r\n```","```\r\nprivate void pushUpMin(List<T> h , int i) {\r\n    while(hasGrandparent(i) && h.get(i - 1)\r\n      .compareTo(h.get(getGrandparentIndex(i) - 1)) < 0) {\r\n        swap(i - 1, getGrandparentIndex(i) - 1, h);\r\n        i = getGrandparentIndex(i);\r\n    }\r\n}\r\n```","```\r\n@Test\r\npublic void givenNewElement_WhenInserted_ThenIsEqualWithMinMaxHeapOrdered() {\r\n    MinMaxHeap<Integer> minMaxHeap = new MinMaxHeap(8);\r\n    minMaxHeap.insert(34);\r\n    minMaxHeap.insert(12);\r\n    minMaxHeap.insert(28);\r\n    minMaxHeap.insert(9);\r\n    minMaxHeap.insert(30);\r\n    minMaxHeap.insert(19);\r\n    minMaxHeap.insert(1);\r\n    minMaxHeap.insert(40);\r\n    Assert.assertEquals(List.of(1, 40, 28, 12, 30, 19, 9, 34),\r\n      minMaxHeap.getMinMaxHeap());\r\n}\r\n```","```\r\npublic T min() {\r\n    if (!isEmpty()) {\r\n        return array.get(0);\r\n    }\r\n    return null;\r\n}\r\n```","```\r\npublic T max() {\r\n    if (!isEmpty()) {\r\n        if (indicator == 2) {\r\n            return array.get(0);\r\n        }\r\n        if (indicator == 3) {\r\n            return array.get(1);\r\n        }\r\n        return array.get(1).compareTo(array.get(2)) < 0 ? array.get(2) : array.get(1);\r\n    }\r\n    return null;\r\n}\r\n```","```\r\npublic T removeMin() {\r\n    T min = min();\r\n    if (min != null) {\r\n       if (indicator == 2) {\r\n         array.remove(indicator--);\r\n         return min;\r\n       }\r\n       array.set(0, array.get(--indicator - 1));\r\n       array.remove(indicator - 1);\r\n       pushDown(array, 1);\r\n    }\r\n    return min;\r\n}\r\n```","```\r\npublic T removeMax() {\r\n    T max = max();\r\n    if (max != null) {\r\n        int maxIndex;\r\n        if (indicator == 2) {\r\n            maxIndex = 0;\r\n            array.remove(--indicator - 1);\r\n            return max;\r\n        } else if (indicator == 3) {\r\n            maxIndex = 1;\r\n            array.remove(--indicator - 1);\r\n            return max;\r\n        } else {\r\n            maxIndex = array.get(1).compareTo(array.get(2)) < 0 ? 2 : 1;\r\n        }\r\n        array.set(maxIndex, array.get(--indicator - 1));\r\n        array.remove(indicator - 1);\r\n        pushDown(array, maxIndex + 1);\r\n    }\r\n    return max;\r\n}\r\n```"]