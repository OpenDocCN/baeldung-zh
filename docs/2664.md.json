["```\r\nExecutor executor = Executors.newSingleThreadExecutor();\r\nexecutor.execute(() -> System.out.println(\"Hello World\"));\r\n```","```\r\nExecutorService executorService = Executors.newFixedThreadPool(10);\r\nFuture<String> future = executorService.submit(() -> \"Hello World\");\r\n// some operations\r\nString result = future.get();\r\n```","```\r\nThreadPoolExecutor executor = \r\n  (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\r\nexecutor.submit(() -> {\r\n    Thread.sleep(1000);\r\n    return null;\r\n});\r\nexecutor.submit(() -> {\r\n    Thread.sleep(1000);\r\n    return null;\r\n});\r\nexecutor.submit(() -> {\r\n    Thread.sleep(1000);\r\n    return null;\r\n});\r\n\r\nassertEquals(2, executor.getPoolSize());\r\nassertEquals(1, executor.getQueue().size());\r\n```","```\r\nThreadPoolExecutor executor = \r\n  (ThreadPoolExecutor) Executors.newCachedThreadPool();\r\nexecutor.submit(() -> {\r\n    Thread.sleep(1000);\r\n    return null;\r\n});\r\nexecutor.submit(() -> {\r\n    Thread.sleep(1000);\r\n    return null;\r\n});\r\nexecutor.submit(() -> {\r\n    Thread.sleep(1000);\r\n    return null;\r\n});\r\n\r\nassertEquals(3, executor.getPoolSize());\r\nassertEquals(0, executor.getQueue().size());\r\n```","```\r\nAtomicInteger counter = new AtomicInteger();\r\n\r\nExecutorService executor = Executors.newSingleThreadExecutor();\r\nexecutor.submit(() -> {\r\n    counter.set(1);\r\n});\r\nexecutor.submit(() -> {\r\n    counter.compareAndSet(1, 2);\r\n});\r\n```","```\r\nScheduledExecutorService executor = Executors.newScheduledThreadPool(5);\r\nexecutor.schedule(() -> {\r\n    System.out.println(\"Hello World\");\r\n}, 500, TimeUnit.MILLISECONDS);\r\n```","```\r\nCountDownLatch lock = new CountDownLatch(3);\r\n\r\nScheduledExecutorService executor = Executors.newScheduledThreadPool(5);\r\nScheduledFuture<?> future = executor.scheduleAtFixedRate(() -> {\r\n    System.out.println(\"Hello World\");\r\n    lock.countDown();\r\n}, 500, 100, TimeUnit.MILLISECONDS);\r\n\r\nlock.await(1000, TimeUnit.MILLISECONDS);\r\nfuture.cancel(true);\r\n```","```\r\nstatic class TreeNode {\r\n\r\n    int value;\r\n\r\n    Set<TreeNode> children;\r\n\r\n    TreeNode(int value, TreeNode... children) {\r\n        this.value = value;\r\n        this.children = Sets.newHashSet(children);\r\n    }\r\n}\r\n```","```\r\npublic static class CountingTask extends RecursiveTask<Integer> {\r\n\r\n    private final TreeNode node;\r\n\r\n    public CountingTask(TreeNode node) {\r\n        this.node = node;\r\n    }\r\n\r\n    @Override\r\n    protected Integer compute() {\r\n        return node.value + node.children.stream()\r\n          .map(childNode -> new CountingTask(childNode).fork())\r\n          .collect(Collectors.summingInt(ForkJoinTask::join));\r\n    }\r\n}\r\n```","```\r\nTreeNode tree = new TreeNode(5,\r\n  new TreeNode(3), new TreeNode(2,\r\n    new TreeNode(2), new TreeNode(8)));\r\n\r\nForkJoinPool forkJoinPool = ForkJoinPool.commonPool();\r\nint sum = forkJoinPool.invoke(new CountingTask(tree));\r\n```","```\r\n<dependency>\r\n    <groupId>com.google.guava</groupId>\r\n    <artifactId>guava</artifactId>\r\n    <version>31.0.1-jre</version>\r\n</dependency>\r\n```","```\r\nExecutor executor = MoreExecutors.directExecutor();\r\n\r\nAtomicBoolean executed = new AtomicBoolean();\r\n\r\nexecutor.execute(() -> {\r\n    try {\r\n        Thread.sleep(500);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    executed.set(true);\r\n});\r\n\r\nassertTrue(executed.get());\r\n```","```\r\nThreadPoolExecutor executor = \r\n  (ThreadPoolExecutor) Executors.newFixedThreadPool(5);\r\nExecutorService executorService = \r\n  MoreExecutors.getExitingExecutorService(executor, \r\n    100, TimeUnit.MILLISECONDS);\r\n\r\nexecutorService.submit(() -> {\r\n    while (true) {\r\n    }\r\n});\r\n```","```\r\nExecutorService executorService = Executors.newCachedThreadPool();\r\nListeningExecutorService listeningExecutorService = \r\n  MoreExecutors.listeningDecorator(executorService);\r\n\r\nListenableFuture<String> future1 = \r\n  listeningExecutorService.submit(() -> \"Hello\");\r\nListenableFuture<String> future2 = \r\n  listeningExecutorService.submit(() -> \"World\");\r\n\r\nString greeting = Futures.allAsList(future1, future2).get()\r\n  .stream()\r\n  .collect(Collectors.joining(\" \"));\r\nassertEquals(\"Hello World\", greeting);\r\n```"]