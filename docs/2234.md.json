["```\r\npublic class Tree<T> {\r\n    private T value;\r\n    private List<Tree<T>> children;\r\n\r\n    private Tree(T value) {\r\n        this.value = value;\r\n        this.children = new ArrayList<>();\r\n    }\r\n\r\n    public static <T> Tree<T> of(T value) {\r\n        return new Tree<>(value);\r\n    }\r\n\r\n    public Tree<T> addChild(T value) {\r\n        Tree<T> newChild = new Tree<>(value);\r\n        children.add(newChild);\r\n        return newChild;\r\n    }\r\n}\r\n```","```\r\npublic static <T> Optional<Tree<T>> search(T value, Tree<T> root) {\r\n    //...\r\n}\r\n```","```\r\nQueue<Tree<T>> queue = new ArrayDeque<>();\r\nqueue.add(root);\r\n```","```\r\nwhile(!queue.isEmpty()) {\r\n    Tree<T> currentNode = queue.remove();\r\n}\r\n```","```\r\nif (currentNode.getValue().equals(value)) {\r\n    return Optional.of(currentNode);\r\n} else {\r\n    queue.addAll(currentNode.getChildren());\r\n}\r\n```","```\r\nreturn Optional.empty();\r\n```","```\r\nTree<Integer> root = Tree.of(10);\r\nTree<Integer> rootFirstChild = root.addChild(2);\r\nTree<Integer> depthMostChild = rootFirstChild.addChild(3);\r\nTree<Integer> rootSecondChild = root.addChild(4);\r\n```","```\r\nBreadthFirstSearchAlgorithm.search(4, root)\r\n```","```\r\n[main] DEBUG  c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 10\r\n[main] DEBUG  c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 2 \r\n[main] DEBUG  c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 4\r\n```","```\r\npublic class Node<T> {\r\n    private T value;\r\n    private Set<Node<T>> neighbors;\r\n\r\n    public Node(T value) {\r\n        this.value = value;\r\n        this.neighbors = new HashSet<>();\r\n    }\r\n\r\n    public void connect(Node<T> node) {\r\n        if (this == node) throw new IllegalArgumentException(\"Can't connect node to itself\");\r\n        this.neighbors.add(node);\r\n        node.neighbors.add(this);\r\n    }\r\n}\r\n```","```\r\npublic static <T> Optional<Node<T>> search(T value, Node<T> start) {\r\n    Queue<Node<T>> queue = new ArrayDeque<>();\r\n    queue.add(start);\r\n\r\n    Node<T> currentNode;\r\n\r\n    while (!queue.isEmpty()) {\r\n        currentNode = queue.remove();\r\n\r\n        if (currentNode.getValue().equals(value)) {\r\n            return Optional.of(currentNode);\r\n        } else {\r\n            queue.addAll(currentNode.getNeighbors());\r\n        }\r\n    }\r\n\r\n    return Optional.empty();\r\n}\r\n```","```\r\nwhile (!queue.isEmpty()) {\r\n    currentNode = queue.remove();\r\n    LOGGER.debug(\"Visited node with value: {}\", currentNode.getValue());\r\n\r\n    if (currentNode.getValue().equals(value)) {\r\n        return Optional.of(currentNode);\r\n    } else {\r\n        alreadyVisited.add(currentNode);\r\n        queue.addAll(currentNode.getNeighbors());\r\n        queue.removeAll(alreadyVisited);\r\n    }\r\n}\r\n\r\nreturn Optional.empty();\r\n```","```\r\nSet<Node<T>> alreadyVisited = new HashSet<>();\r\n```","```\r\nalreadyVisited.add(currentNode);\r\n```","```\r\nqueue.removeAll(alreadyVisited);\r\n```","```\r\nNode<Integer> start = new Node<>(10);\r\nNode<Integer> firstNeighbor = new Node<>(2);\r\nstart.connect(firstNeighbor);\r\n\r\nNode<Integer> firstNeighborNeighbor = new Node<>(3);\r\nfirstNeighbor.connect(firstNeighborNeighbor);\r\nfirstNeighborNeighbor.connect(start);\r\n\r\nNode<Integer> secondNeighbor = new Node<>(4);\r\nstart.connect(secondNeighbor);\r\n```","```\r\nBreadthFirstSearchAlgorithm.search(4, firstNeighborNeighbor);\r\n```","```\r\n[main] DEBUG c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 3 \r\n[main] DEBUG c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 2 \r\n[main] DEBUG c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 10 \r\n[main] DEBUG c.b.a.b.BreadthFirstSearchAlgorithm - Visited node with value: 4\r\n```"]