# Java 中匹配日期模式的正则表达式

> 原文：<https://web.archive.org/web/20220930061024/https://www.baeldung.com/java-date-regular-expressions>

## **1。简介**

如果使用得当，正则表达式是匹配各种模式的强大工具。

在本文中，我们将使用`java.util.regex`包来确定给定的`String`是否包含有效日期。

关于正则表达式的介绍，请参考[我们的 Java 正则表达式 API 指南](/web/20220628094754/https://www.baeldung.com/regular-expressions-java)。

## **2。日期格式概述**

我们将定义一个与国际公历相关的有效日期。我们的格式将遵循一般模式:`YYYY-MM-DD.`

让我们也包含一个`leap`年的概念，即包含 2 月 29 日这一天的一年。**根据公历，如果一年的数字除了能被`100`整除的以外，还能被`4`整除，我们称之为`leap`。**

在所有其他情况下 **`,`** 我们称一年为`regular`。

有效日期的示例:

*   `2017-12-31`
*   `2020-02-29`
*   `2400-02-29`

无效日期的示例:

*   `2017/12/31`:不正确的令牌分隔符
*   `2018-1-1`:缺少前导零
*   四月的天数计算错误
*   `2100-02-29`:今年不是闰年，因为数值除以`100`，所以二月被限制为 28 天

## **3。实施解决方案**

因为我们要使用正则表达式来匹配日期，所以让我们先画出一个接口`DateMatcher`，它提供了一个`matches`方法:

```
public interface DateMatcher {
    boolean matches(String date);
}
```

我们将在下面一步一步地介绍实现，最终构建完整的解决方案。

### **3.1。匹配宽格式**

我们将首先创建一个非常简单的原型来处理匹配器的格式约束:

```
class FormattedDateMatcher implements DateMatcher {

    private static Pattern DATE_PATTERN = Pattern.compile(
      "^\\d{4}-\\d{2}-\\d{2}$");

    @Override
    public boolean matches(String date) {
        return DATE_PATTERN.matcher(date).matches();
    }
}
```

这里我们指定**一个有效的日期必须由三组用破折号分隔的整数组成。**第一组由四个整数组成，其余两组各有两个整数。

匹配日期:`2017-12-31`、`2018-01-31`、`0000-00-00`、`1029-99-72`

不匹配的日期:`2018-01`、`2018-01-XX`、`2020/02/29`

### **3.2。匹配特定的日期格式**

我们的第二个例子接受日期标记的范围以及我们的格式约束。为了简单起见，我们将我们的兴趣限制在 1900-2999 年。

既然我们已经成功匹配了常规日期格式，我们需要进一步约束它，以确保日期实际上是正确的:

```
^((19|2[0-9])[0-9]{2})-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$
```

这里我们介绍了需要匹配的三个`groups`整数范围:

*   `(19|2[0-9])[0-9]{2}`通过匹配一个以`19`或`2X`开头，后跟几个任意数字的数字，覆盖有限的年份范围。
*   `0[1-9]|1[012]`匹配`01-12`范围内的月份数
*   `0[1-9]|[12][0-9]|3[01]`匹配`01-31`范围内的日期

匹配日期:`1900-01-01`、`2205-02-31`、`2999-12-31`

不匹配的日期:`1899-12-31`、`2018-05-35`、`2018-13-05`、`3000-01-01`、`2018-01-XX`

### **3.3。匹配 2 月 29 日**

为了正确匹配闰年，我们必须首先**确定我们何时遇到了闰年**，然后确保我们接受 2 月 29 日作为这些年的有效日期。

由于在我们的限制范围内闰年的数量足够大，我们应该使用适当的整除规则来过滤它们:

*   `If the number formed by the last two digits in a number is divisible by 4, the original number is divisible by 4`
*   `If the last two digits of the number are 00, the number is divisible by 100`

这里有一个解决方案:

```
^((2000|2400|2800|(19|2[0-9])(0[48]|[2468][048]|[13579][26]))-02-29)$
```

该模式由以下部分组成:

*   `2000|2400|2800`在`1900-2999`的限定范围内，用`400`的分隔符匹配一组闰年
*   `19|2[0-9](0[48]|[2468][048]|[13579][26]))`匹配所有有`4`分隔线且没有`100`分隔线的`white-list`年组合
*   `-02-29`匹配`February 2nd`

匹配日期:`2020-02-29`、`2024-02-29`、`2400-02-29`

不匹配的日期:`2019-02-29`、`2100-02-29`、`3200-02-29`、`2020/02/29`

### **3.4。匹配二月的一般日子**

除了匹配闰年的 2 月 29 日，**我们还需要匹配所有年份中 2 月(1-28)的所有其他日子**:

```
^(((19|2[0-9])[0-9]{2})-02-(0[1-9]|1[0-9]|2[0-8]))$
```

匹配日期:`2018-02-01`、`2019-02-13`、`2020-02-25`

不匹配的日期:`2000-02-30`、 `2400-02-62`、`2018/02/28`

### **3.5。匹配 31 天的月份**

一月、三月、五月、七月、八月、十月和十二月应该匹配 1 到 31 天:

```
^(((19|2[0-9])[0-9]{2})-(0[13578]|10|12)-(0[1-9]|[12][0-9]|3[01]))$
```

匹配日期:`2018-01-31`、`2021-07-31`、`2022-08-31`

不匹配的日期:`2018-01-32`、`2019-03-64`、`2018/01/31`

### 3.6。匹配 30 天的月份

四月、六月、九月和十一月应该匹配 1 到 30 天:

```
^(((19|2[0-9])[0-9]{2})-(0[469]|11)-(0[1-9]|[12][0-9]|30))$
```

匹配日期:`2018-04-30`、`2019-06-30`、`2020-09-30`

不匹配的日期:`2018-04-31`、`2019-06-31`、`2018/04/30`

### **3.7 级。格里戈维奇的约会**

现在我们可以**将上面所有的模式组合成一个匹配器，得到一个满足所有约束的完整的`GregorianDateMatcher`** :

```
class GregorianDateMatcher implements DateMatcher {

    private static Pattern DATE_PATTERN = Pattern.compile(
      "^((2000|2400|2800|(19|2[0-9])(0[48]|[2468][048]|[13579][26]))-02-29)$" 
      + "|^(((19|2[0-9])[0-9]{2})-02-(0[1-9]|1[0-9]|2[0-8]))$"
      + "|^(((19|2[0-9])[0-9]{2})-(0[13578]|10|12)-(0[1-9]|[12][0-9]|3[01]))$" 
      + "|^(((19|2[0-9])[0-9]{2})-(0[469]|11)-(0[1-9]|[12][0-9]|30))$");

    @Override
    public boolean matches(String date) {
        return DATE_PATTERN.matcher(date).matches();
    }
}
```

**我们使用了一个`alternation`字符“|”来匹配四个分支中的至少一个**。因此，二月的有效日期要么匹配闰年 2 月 29 日的第一个分支，要么匹配从`1`到`28`的任何一天的第二个分支。剩余月份的日期与第三和第四个分支相匹配。

因为我们没有优化这种模式以获得更好的可读性，所以请随意尝试一下它的长度。

此时，我们已经满足了我们在开始时引入的所有约束。

### **3.8。关于性能的说明**

**解析复杂的正则表达式可能会显著影响执行流程的性能。**本文的主要目的不是学习一种有效的方法来测试一个字符串在一组所有可能的日期中的成员资格。

如果需要一种可靠而快速的方法来验证日期，可以考虑使用 Java8 提供的`LocalDate.parse()`。

## **4。结论**

在本文中，我们学习了如何使用正则表达式来匹配严格格式化的公历日期，方法是提供格式、范围和月份长度的规则。

本文中的所有代码都可以在 Github 上的[处获得。这是一个基于 Maven 的项目，因此应该很容易导入和运行。](https://web.archive.org/web/20220628094754/https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-datetime-string)