["```\r\n<dependencyManagement>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>software.amazon.awssdk</groupId>\r\n            <artifactId>bom</artifactId>\r\n            <version>2.10.1</version>\r\n            <type>pom</type>\r\n            <scope>import</scope>\r\n        </dependency>\r\n    </dependencies>\r\n</dependencyManagement>\r\n\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>software.amazon.awssdk</groupId>\r\n        <artifactId>s3</artifactId>\r\n        <scope>compile</scope>\r\n    </dependency>\r\n\r\n    <dependency>\r\n        <artifactId>netty-nio-client</artifactId>\r\n        <groupId>software.amazon.awssdk</groupId>\r\n        <scope>compile</scope>\r\n    </dependency>\r\n</dependencies>\r\n```","```\r\n@Configuration\r\n@EnableConfigurationProperties(S3ClientConfigurarionProperties.class)\r\npublic class S3ClientConfiguration {\r\n    @Bean\r\n    public S3AsyncClient s3client(S3ClientConfigurarionProperties s3props, \r\n      AwsCredentialsProvider credentialsProvider) {\r\n        SdkAsyncHttpClient httpClient = NettyNioAsyncHttpClient.builder()\r\n          .writeTimeout(Duration.ZERO)\r\n          .maxConcurrency(64)\r\n          .build();\r\n        S3Configuration serviceConfiguration = S3Configuration.builder()\r\n          .checksumValidationEnabled(false)\r\n          .chunkedEncodingEnabled(true)\r\n          .build();\r\n        S3AsyncClientBuilder b = S3AsyncClient.builder().httpClient(httpClient)\r\n          .region(s3props.getRegion())\r\n          .credentialsProvider(credentialsProvider)\r\n          .serviceConfiguration(serviceConfiguration);\r\n\r\n        if (s3props.getEndpoint() != null) {\r\n            b = b.endpointOverride(s3props.getEndpoint());\r\n        }\r\n        return b.build();\r\n    }\r\n}\r\n```","```\r\n@Bean\r\npublic AwsCredentialsProvider awsCredentialsProvider(S3ClientConfigurarionProperties s3props) {\r\n    if (StringUtils.isBlank(s3props.getAccessKeyId())) {\r\n        return DefaultCredentialsProvider.create();\r\n    } else {\r\n        return () -> {\r\n            return AwsBasicCredentials.create(\r\n              s3props.getAccessKeyId(),\r\n              s3props.getSecretAccessKey());\r\n        };\r\n    }\r\n}\r\n```","```\r\n@RestController\r\n@RequestMapping(\"/inbox\")\r\n@Slf4j\r\npublic class UploadResource {\r\n    private final S3AsyncClient s3client;\r\n    private final S3ClientConfigurarionProperties s3config;\r\n\r\n    public UploadResource(S3AsyncClient s3client, S3ClientConfigurarionProperties s3config) {\r\n        this.s3client = s3client;\r\n        this.s3config = s3config;        \r\n    }\r\n\r\n    @PostMapping\r\n    public Mono<ResponseEntity<UploadResult>> uploadHandler(\r\n      @RequestHeader HttpHeaders headers, \r\n      @RequestBody Flux<ByteBuffer> body) {\r\n      // ... see section 6\r\n    }\r\n\r\n    @RequestMapping(\r\n      consumes = MediaType.MULTIPART_FORM_DATA_VALUE,\r\n      method = {RequestMethod.POST, RequestMethod.PUT})\r\n    public Mono<ResponseEntity<UploadResult>> multipartUploadHandler(\r\n      @RequestHeader HttpHeaders headers,\r\n      @RequestBody Flux<Part> parts ) {\r\n      // ... see section 7\r\n    }\r\n}\r\n```","```\r\n@PostMapping\r\npublic Mono<ResponseEntity<UploadResult>> uploadHandler(@RequestHeader HttpHeaders headers,\r\n  @RequestBody Flux<ByteBuffer> body) {\r\n    // ... some validation code omitted\r\n    String fileKey = UUID.randomUUID().toString();\r\n    MediaType mediaType = headers.getContentType();\r\n\r\n    if (mediaType == null) {\r\n        mediaType = MediaType.APPLICATION_OCTET_STREAM;\r\n    }\r\n    CompletableFuture future = s3client\r\n      .putObject(PutObjectRequest.builder()\r\n        .bucket(s3config.getBucket())\r\n        .contentLength(length)\r\n        .key(fileKey.toString())\r\n        .contentType(mediaType.toString())\r\n        .metadata(metadata)\r\n        .build(), \r\n      AsyncRequestBody.fromPublisher(body));\r\n\r\n    return Mono.fromFuture(future)\r\n      .map((response) -> {\r\n        checkResult(response);\r\n        return ResponseEntity\r\n          .status(HttpStatus.CREATED)\r\n          .body(new UploadResult(HttpStatus.CREATED, new String[] {fileKey}));\r\n        });\r\n}\r\n```","```\r\nreturn parts\r\n  .ofType(FilePart.class)\r\n  .flatMap((part)-> saveFile(headers, part))\r\n  .collect(Collectors.toList())\r\n  .map((keys)-> new UploadResult(HttpStatus.CREATED, keys)));\r\n```","```\r\nclass UploadState {\r\n    String bucket;\r\n    String filekey;\r\n    String uploadId;\r\n    int partCounter;\r\n    Map<Integer, CompletedPart> completedParts = new HashMap<>();\r\n    int buffered = 0;\r\n    // ... getters/setters omitted\r\n    UploadState(String bucket, String filekey) {\r\n        this.bucket = bucket;\r\n        this.filekey = filekey;\r\n    }\r\n}\r\n```","```\r\nMono<String> saveFile(HttpHeaders headers,String bucket, FilePart part) {\r\n    String filekey = UUID.randomUUID().toString();\r\n    Map<String, String> metadata = new HashMap<String, String>();\r\n    String filename = part.filename();\r\n    if ( filename == null ) {\r\n        filename = filekey;\r\n    }       \r\n    metadata.put(\"filename\", filename);    \r\n    MediaType mt = part.headers().getContentType();\r\n    if ( mt == null ) {\r\n        mt = MediaType.APPLICATION_OCTET_STREAM;\r\n    }\r\n    UploadState uploadState = new UploadState(bucket,filekey);     \r\n    CompletableFuture<CreateMultipartUploadResponse> uploadRequest = s3client\r\n      .createMultipartUpload(CreateMultipartUploadRequest.builder()\r\n        .contentType(mt.toString())\r\n        .key(filekey)\r\n        .metadata(metadata)\r\n        .bucket(bucket)\r\n        .build());\r\n\r\n    return Mono\r\n      .fromFuture(uploadRequest)\r\n      .flatMapMany((response) -> {\r\n          checkResult(response);              \r\n          uploadState.uploadId = response.uploadId();\r\n          return part.content();\r\n      })\r\n      .bufferUntil((buffer) -> {\r\n          uploadState.buffered += buffer.readableByteCount();\r\n          if ( uploadState.buffered >= s3config.getMultipartMinPartSize() ) {\r\n              uploadState.buffered = 0;\r\n              return true;\r\n          } else {\r\n              return false;\r\n          }\r\n      })\r\n      .map((buffers) -> concatBuffers(buffers))\r\n      .flatMap((buffer) -> uploadPart(uploadState,buffer))\r\n      .reduce(uploadState,(state,completedPart) -> {\r\n          state.completedParts.put(completedPart.partNumber(), completedPart);              \r\n          return state;\r\n      })\r\n      .flatMap((state) -> completeUpload(state))\r\n      .map((response) -> {\r\n          checkResult(response);\r\n          return  uploadState.filekey;\r\n      });\r\n}\r\n```","```\r\nprivate Mono<CompletedPart> uploadPart(UploadState uploadState, ByteBuffer buffer) {\r\n    final int partNumber = ++uploadState.partCounter;\r\n    CompletableFuture<UploadPartResponse> request = s3client.uploadPart(UploadPartRequest.builder()\r\n        .bucket(uploadState.bucket)\r\n        .key(uploadState.filekey)\r\n        .partNumber(partNumber)\r\n        .uploadId(uploadState.uploadId)\r\n        .contentLength((long) buffer.capacity())\r\n        .build(), \r\n        AsyncRequestBody.fromPublisher(Mono.just(buffer)));\r\n\r\n    return Mono\r\n      .fromFuture(request)\r\n      .map((uploadPartResult) -> {              \r\n          checkResult(uploadPartResult);\r\n          return CompletedPart.builder()\r\n            .eTag(uploadPartResult.eTag())\r\n            .partNumber(partNumber)\r\n            .build();\r\n      });\r\n}\r\n```","```\r\nprivate Mono<CompleteMultipartUploadResponse> completeUpload(UploadState state) {        \r\n    CompletedMultipartUpload multipartUpload = CompletedMultipartUpload.builder()\r\n        .parts(state.completedParts.values())\r\n        .build();\r\n    return Mono.fromFuture(s3client.completeMultipartUpload(CompleteMultipartUploadRequest.builder()\r\n        .bucket(state.bucket)\r\n        .uploadId(state.uploadId)\r\n        .multipartUpload(multipartUpload)\r\n        .key(state.filekey)\r\n        .build()));\r\n}\r\n```","```\r\n@GetMapping(path=\"/{filekey}\")\r\nMono<ResponseEntity<Flux<ByteBuffer>>> downloadFile(@PathVariable(\"filekey\") String filekey) {    \r\n    GetObjectRequest request = GetObjectRequest.builder()\r\n      .bucket(s3config.getBucket())\r\n      .key(filekey)\r\n      .build();\r\n\r\n    return Mono.fromFuture(s3client.getObject(request,new FluxResponseProvider()))\r\n      .map(response -> {\r\n        checkResult(response.sdkResponse);\r\n        String filename = getMetadataItem(response.sdkResponse,\"filename\",filekey);            \r\n        return ResponseEntity.ok()\r\n          .header(HttpHeaders.CONTENT_TYPE, response.sdkResponse.contentType())\r\n          .header(HttpHeaders.CONTENT_LENGTH, Long.toString(response.sdkResponse.contentLength()))\r\n          .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + filename + \"\\\"\")\r\n          .body(response.flux);\r\n      });\r\n}\r\n```","```\r\nclass FluxResponseProvider implements AsyncResponseTransformer<GetObjectResponse,FluxResponse> {    \r\n    private FluxResponse response;\r\n    @Override\r\n    public CompletableFuture<FluxResponse> prepare() {\r\n        response = new FluxResponse();\r\n        return response.cf;\r\n    }\r\n\r\n    @Override\r\n    public void onResponse(GetObjectResponse sdkResponse) {            \r\n        this.response.sdkResponse = sdkResponse;\r\n    }\r\n\r\n    @Override\r\n    public void onStream(SdkPublisher<ByteBuffer> publisher) {\r\n        response.flux = Flux.from(publisher);\r\n        response.cf.complete(response);            \r\n    }\r\n\r\n    @Override\r\n    public void exceptionOccurred(Throwable error) {\r\n        response.cf.completeExceptionally(error);\r\n    }\r\n}\r\n```","```\r\nclass FluxResponse {\r\n    final CompletableFuture<FluxResponse> cf = new CompletableFuture<>();\r\n    GetObjectResponse sdkResponse;\r\n    Flux<ByteBuffer> flux;\r\n}\r\n```"]