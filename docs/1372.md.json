["```\r\n<dependency>\r\n    <groupId>io.vavr</groupId>\r\n    <artifactId>vavr</artifactId>\r\n    <version>0.9.2</version>\r\n</dependency>\r\n```","```\r\nString initialValue = \"Welcome to \";\r\nFuture<String> resultFuture = Future.of(() -> someComputation());\r\n```","```\r\nString result = resultFuture.getOrElse(\"Failed to get underlying value.\");\r\n```","```\r\nOption<Try<String>> futureOption = resultFuture.getValue();\r\nTry<String> futureTry = futureOption.get();\r\nString result = futureTry.get();\r\n```","```\r\nresultFuture.isEmpty();\r\n```","```\r\n@Test\r\npublic void whenChangeExecutorService_thenCorrect() {\r\n    String result = Future.of(newSingleThreadExecutor(), () -> HELLO)\r\n      .getOrElse(error);\r\n\r\n    assertThat(result)\r\n      .isEqualTo(HELLO);\r\n}\r\n```","```\r\nFuture<String> resultFuture = Future.of(() -> appendData(initialValue))\r\n  .onSuccess(v -> System.out.println(\"Successfully Completed - Result: \" + v))\r\n  .onFailure(v -> System.out.println(\"Failed - Result: \" + v));\r\n```","```\r\nFuture<String> resultFuture = Future.of(() -> appendData(initialValue))\r\n  .andThen(finalResult -> System.out.println(\"Completed - 1: \" + finalResult))\r\n  .andThen(finalResult -> System.out.println(\"Completed - 2: \" + finalResult));\r\n```","```\r\nresultFuture.await();\r\n```","```\r\nresultFuture.cancel();\r\n```","```\r\nresultFuture.executorService();\r\n```","```\r\n@Test\r\npublic void whenDivideByZero_thenGetThrowable2() {\r\n    Future<Integer> resultFuture = Future.of(() -> 10 / 0)\r\n      .await();\r\n\r\n    assertThat(resultFuture.getCause().get().getMessage())\r\n      .isEqualTo(\"/ by zero\");\r\n}\r\n```","```\r\n@Test\r\npublic void whenDivideByZero_thenGetThrowable1() {\r\n    Future<Integer> resultFuture = Future.of(() -> 10 / 0);\r\n\r\n    assertThatThrownBy(resultFuture::get)\r\n      .isInstanceOf(ArithmeticException.class);\r\n}\r\n```","```\r\n@Test\r\npublic void whenDivideByZero_thenCorrect() {\r\n    Future<Integer> resultFuture = Future.of(() -> 10 / 0)\r\n      .await();\r\n\r\n    assertThat(resultFuture.isCompleted()).isTrue();\r\n    assertThat(resultFuture.isSuccess()).isFalse();\r\n    assertThat(resultFuture.isFailure()).isTrue();\r\n}\r\n```","```\r\n@Test\r\npublic void whenCallMap_thenCorrect() {\r\n    Future<String> futureResult = Future.of(() -> \"from Baeldung\")\r\n      .map(a -> \"Hello \" + a)\r\n      .await();\r\n\r\n    assertThat(futureResult.get())\r\n      .isEqualTo(\"Hello from Baeldung\");\r\n}\r\n```","```\r\n@Test\r\npublic void whenCallFlatMap_thenCorrect() {\r\n    Future<Object> futureMap = Future.of(() -> 1)\r\n      .flatMap((i) -> Future.of(() -> \"Hello: \" + i));\r\n\r\n    assertThat(futureMap.get()).isEqualTo(\"Hello: 1\");\r\n}\r\n```","```\r\n@Test\r\npublic void whenTransform_thenCorrect() {\r\n    Future<Object> future = Future.of(() -> 5)\r\n      .transformValue(result -> Try.of(() -> HELLO + result.get()));\r\n\r\n    assertThat(future.get()).isEqualTo(HELLO + 5);\r\n}\r\n```","```\r\n@Test\r\npublic void whenCallZip_thenCorrect() {\r\n    Future<String> f1 = Future.of(() -> \"hello1\");\r\n    Future<String> f2 = Future.of(() -> \"hello2\");\r\n\r\n    assertThat(f1.zip(f2).get())\r\n      .isEqualTo(Tuple.of(\"hello1\", \"hello2\"));\r\n}\r\n```","```\r\n@Test\r\npublic void whenConvertToCompletableFuture_thenCorrect()\r\n  throws Exception {\r\n\r\n    CompletableFuture<String> convertedFuture = Future.of(() -> HELLO)\r\n      .toCompletableFuture();\r\n\r\n    assertThat(convertedFuture.get())\r\n      .isEqualTo(HELLO);\r\n}\r\n```","```\r\n@Test\r\npublic void whenFutureFails_thenGetErrorMessage() {\r\n    Future<String> future = Future.of(() -> \"Hello\".substring(-1))\r\n      .recover(x -> \"fallback value\");\r\n\r\n    assertThat(future.get())\r\n      .isEqualTo(\"fallback value\");\r\n}\r\n```","```\r\n@Test\r\npublic void whenFutureFails_thenGetAnotherFuture() {\r\n    Future<String> future = Future.of(() -> \"Hello\".substring(-1))\r\n      .recoverWith(x -> Future.of(() -> \"fallback value\"));\r\n\r\n    assertThat(future.get())\r\n      .isEqualTo(\"fallback value\");\r\n}\r\n```","```\r\n@Test\r\npublic void whenBothFuturesFail_thenGetErrorMessage() {\r\n    Future<String> f1 = Future.of(() -> \"Hello\".substring(-1));\r\n    Future<String> f2 = Future.of(() -> \"Hello\".substring(-2));\r\n\r\n    Future<String> errorMessageFuture = f1.fallbackTo(f2);\r\n    Future<Throwable> errorMessage = errorMessageFuture.failed();\r\n\r\n    assertThat(\r\n      errorMessage.get().getMessage())\r\n      .isEqualTo(\"String index out of range: -1\");\r\n}\r\n```"]